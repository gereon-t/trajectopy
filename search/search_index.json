{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Trajectopy - Trajectory Evaluation in Python Trajectopy is a Python package with an optional graphical user interface for empirical trajectory evaluation."},{"location":"#key-features","title":"Key Features","text":"<p>Trajectopy offers a range of features, including:</p> <ul> <li>Interactive GUI: A user-friendly interface that enables seamless interaction with your trajectory data, making it easy to visualize, align, and compare trajectories.</li> <li>Alignment: An advanced trajectory alignment algorithm that can be tailored to the specific application and supports a similarity transformation, a leverarm and a time shift estimation.</li> <li>Comparison: Absolute and relative trajectory comparison metrics (ATE and RPE) that can be computed using various pose-matching methods.</li> <li>Data Import/Export: Support for importing and exporting data, ensuring compatibility with your existing workflows.</li> <li>Customizable Visualization: Powered by Plotly or Matplotlib, trajectopy offers a range of interactive plots that can be customized to your needs. (Demo)</li> </ul>"},{"location":"#citation","title":"Citation","text":"<p>If you use this library for any academic work, please cite our original paper.</p> <pre><code>@article{Tombrink2024,\nurl = {https://doi.org/10.1515/jag-2024-0040},\ntitle = {Spatio-temporal trajectory alignment for trajectory evaluation},\nauthor = {Gereon Tombrink and Ansgar Dreier and Lasse Klingbeil and Heiner Kuhlmann},\njournal = {Journal of Applied Geodesy},\ndoi = {doi:10.1515/jag-2024-0040},\nyear = {2024},\ncodeurl = {https://github.com/gereon-t/trajectopy},\n}\n</code></pre>"},{"location":"Getting_Started/","title":"Getting Started","text":""},{"location":"Getting_Started/#installation-with-gui","title":"Installation (with GUI)","text":"<p>It is recommended to install trajectopy with the GUI using the following command:</p> <pre><code>pip install \"trajectopy[gui]\"\n</code></pre> <p>Run</p> <pre><code>trajectopy\n</code></pre>"},{"location":"Getting_Started/#installation-without-gui","title":"Installation (without GUI)","text":"<p>To install trajectopy without the GUI, use the following command:</p> <pre><code>pip install trajectopy\n</code></pre> <p>Now you can use trajectopy as a Python package in your scripts.</p>"},{"location":"Getting_Started/#command-line-options-gui-version-only","title":"Command Line Options (GUI version only)","text":"<p><pre><code>usage: trajectopy [-h] [--version] [--single-thread] [--report-settings REPORT_SETTINGS] [--mpl-settings MPL_SETTINGS] [--report-path REPORT_PATH] [--mapbox-token MAPBOX_TOKEN]\n\nTrajectopy - Trajectory Evaluation in Python\n\noptions:\n  -h, --help            show this help message and exit\n  --version, -v\n  --single-thread       Disable multithreading\n  --report-settings REPORT_SETTINGS\n                        Path to JSON report settings file that will override the default settings.\n  --mpl-settings MPL_SETTINGS\n                        Path to JSON matplotlib plot settings file that will override the default settings.\n  --report-path, -o REPORT_PATH\n                        Output directory for all reports of one session. If not specified, a temporary directory will be used.\n  --mapbox-token MAPBOX_TOKEN\n                        Mapbox token to use Mapbox map styles in trajectory plots.\n</code></pre> Trajectopy allows users to customize the report output path and settings. By default, reports are stored in a temporary directory that will be deleted when the program exits. If you want to keep the reports, you can specify a custom output path using the <code>--report-path</code> option. The report settings can be customized using a JSON file. The report settings file must include all available settings. You can find a sample file here.</p> <p>Example: <pre><code>trajectopy -s custom.json -o ./persistent_report_directory\n</code></pre></p>"},{"location":"Getting_Started/#importing-trajectories","title":"Importing Trajectories","text":"<p>Trajectories can be imported using the \"Add\" button below the trajectory table or by dragging files into the area of the trajectory table. Trajectory files must be ASCII files with a csv-like layout, by default, trajectopy filters for the \".traj\" extension. The default column structure that can be read without any configuration is the following:</p> time position x position y position z quaternion x quaternion y quaternion z quaternion w <p>Columns are expected to be separated by commas by default.</p> <p>It is recommended to provide a header at the beginning of the trajectory file. Header entries always begin with a \"#\". Below you can find a table of all allowed header entries and their meaning.</p> Header Description #name The name provided here is displayed in the table view and in plots of the trajectory #epsg EPSG Code of the datum of the input positions. Required, if geodetic datum transformations or map plots are desired. Default: 0, meaning local coordinates without any known geodetic datum #fields Describes the columns of the ASCII trajectory file. Separated with commas.  field name Meaning t time l arc lengths in meters px position x / lat (degrees only) py position y / lon (degrees only)  pz position z qx quaternion x qy quaternion y qz quaternion z qw quaternion w ex euler angle x ey euler angle y ez euler angle z vx speed x vy speed y vz speed z  Example: \"#fields t,px,py,pz\" Note: The only column that is allowed to appear multiple times is the \"t\" column. #delimiter Delimiter used to separate the columns within the file. Default: \",\" #nframe Definition of the navigation-frame the orientations of the trajectory refer to. Choices: \"enu\": East North Up or \"ned\": North East Down. Default: \"enu\" #rot_unit Unit of the orientations. Choices: \"deg\": Degree, \"rad\": Radians. Default: \"rad\" #gps_week GPS week number of the trajectory. Only relevant if \"time_format\" is \"gps_sow\". Default: 0 #time_format Format of the timestamps / dates. Choices: \"unix\": Unix timestamps (since 01-01-1970), \"datetime\": Human readable date-times. \"gps_sow\": GPS Seconds Of Week (SOW). In this case, \"#gps_week\" must be provided. Default: \"unix\" #time_offset Offset in seconds that is applied to the imported timestamps. Default: 0.0 #datetime_format Format of the datetimes. Only relevant if \"time_format\" is \"datetime\". Default: \"%Y-%m-%d %H:%M:%S.%f\" #datetime_timezone Time zone of the timestamps. During import, all timestamps are converted to UTC considering the input time zone. Choices: Time zone or \"GPS\" #sorting Sorting of the input data. Choices: \"time\": Chronologically sorted data (usually the case), \"arc_length\": Spatially sorted data, i.e. along the arc length. Default: \"time\""},{"location":"Getting_Started/#choosing-the-plotting-backend","title":"Choosing the Plotting Backend","text":"<p>Since version 2.2.0, you can choose between two plotting backends: <code>matplotlib</code> and <code>plotly</code>. By default the <code>matplotlib</code> backend is used for quick and simple plotting. If you want to create advanced interactive HTML reports, you can switch to the <code>plotly</code> backend by clicking \"Plotting\" in the menu bar and selecting the desired backend.</p>"},{"location":"Getting_Started/#keyboard-shortcuts-gui-version-only","title":"Keyboard Shortcuts (GUI version only)","text":"Key Action Ctrl + C Copy selected entry E Export selected entry M Merge selected trajectories P View properties of selected entry / entries R Set selected trajectory as reference Shift + R Unset selected trajectory as reference S Open trajectory settings T Transform selected trajectories to a different coordinate system. U Rename selected entry V Plot all selected trajectories"},{"location":"Python_Package_Usage/","title":"Python Package Usage","text":"<p>In addition to the GUI, trajectopy can also be used as a Python package. The package provides a set of functions to evaluate and visualize the quality of trajectory. Trajectopy is designed to be easy to use and to provide a high level of customization.</p>"},{"location":"Python_Package_Usage/#absolute-trajectory-error-ate","title":"Absolute Trajectory Error (ATE)","text":"<p>Computing the Absolute Trajectory Error (ATE) between two trajectories is a common evaluation metric in the field of visual odometry and SLAM. The ATE is calculated by aligning the two trajectories and then computing the pose-wise difference between the aligned trajectories.</p> <pre><code>import trajectopy as tpy\n\ngt_traj = tpy.Trajectory.from_file(\"./example_data/KITTI_gt.traj\")\nest_traj = tpy.Trajectory.from_file(\"./example_data/KITTI_ORB.traj\")\n\nate_result = tpy.ate(trajectory_gt=gt_traj, trajectory_est=est_traj)\n</code></pre>"},{"location":"Python_Package_Usage/#relative-pose-error-rpe","title":"Relative Pose Error (RPE)","text":"<p>The Relative Pose Error (RPE) is another common evaluation metric. The RPE measures the relative pose difference between two trajectories at different time or distance intervals.</p> <pre><code>import trajectopy as tpy\n\ngt_traj = tpy.Trajectory.from_file(\"./example_data/KITTI_gt.traj\")\nest_traj = tpy.Trajectory.from_file(\"./example_data/KITTI_ORB.traj\")\n\nrpe_result = tpy.rpe(trajectory_gt=gt_traj, trajectory_est=est_traj)\n</code></pre>"},{"location":"Python_Package_Usage/#single-trajectory-evaluation-report","title":"Single Trajectory Evaluation Report","text":"<p>The results of a single trajectory comparison can be visualized in a HTML report.</p> <pre><code># Import\ngt_traj = tpy.Trajectory.from_file(\"./example_data/KITTI_gt.traj\")\nest_traj = tpy.Trajectory.from_file(\"./example_data/KITTI_ORB.traj\")\n\n# Evaluation\nate_result = tpy.ate(trajectory_gt=gt_traj, trajectory_est=est_traj)\nrpe_result = tpy.rpe(trajectory_gt=gt_traj, trajectory_est=est_traj)\n\n# Report\nreport_settings = tpy.ReportSettings(ate_unit_is_mm=False, scatter_marker_size=8)\nreport = tpy.create_deviation_report(ate_result=ate_result, rpe_result=rpe_result, report_settings=report_settings)\ntpy.show_report(report_text=report, filepath=\"reports/report.html\") \n</code></pre>"},{"location":"Python_Package_Usage/#multi-trajectory-evaluation-report","title":"Multi Trajectory Evaluation Report","text":"<p>Multiple trajectory comparisons can be visualized in a single HTML report.</p> <pre><code>import trajectopy as tpy\n\n# Import\ngt_traj = tpy.Trajectory.from_file(\"./example_data/KITTI_gt.traj\")\nest_traj_1 = tpy.Trajectory.from_file(\"./example_data/KITTI_ORB.traj\")\nest_traj_2 = tpy.Trajectory.from_file(\"./example_data/KITTI_SPTAM.traj\")\n\n# Evaluation 1\nate_result_1 = tpy.ate(trajectory_gt=gt_traj, trajectory_est=est_traj_1)\nrpe_result_1 = tpy.rpe(trajectory_gt=gt_traj, trajectory_est=est_traj_1)\n\n# Evaluation 2\nate_result_2 = tpy.ate(trajectory_gt=gt_traj, trajectory_est=est_traj_2)\nrpe_result_2 = tpy.rpe(trajectory_gt=gt_traj, trajectory_est=est_traj_2)\n\n# Report\nmulti_report = tpy.create_deviation_report(\n    ate_result=[ate_result_1, ate_result_2], rpe_result=[rpe_result_1, rpe_result_2]\n)\ntpy.show_report(report_text=multi_report, filepath=\"reports/report.html\")\n</code></pre>"},{"location":"Python_Package_Usage/#matplotlib-plotting","title":"Matplotlib Plotting","text":"<p>In addition to the HTML-based plotting, trajectopy also supports Matplotlib-based plotting. In the below example, all available plotting functions are demonstrated.</p> <pre><code>import matplotlib.pyplot as plt\nimport trajectopy as tpy\n\n# importing\ngt = tpy.Trajectory.from_file(\"./example_data/KITTI_gt.traj\")\norb = tpy.Trajectory.from_file(\"./example_data/KITTI_ORB.traj\")\nsptam = tpy.Trajectory.from_file(\"./example_data/KITTI_SPTAM.traj\")\ntpy.plot_trajectories([gt, orb])\n\n# evaluation\nalignment = tpy.estimate_alignment(gt, orb)\nate_result_orb = tpy.ate(gt, orb)\nate_result_sptam = tpy.ate(gt, sptam)\nrpe_result = tpy.rpe(gt, orb)\n\n# alignment parameter plots\ntpy.plot_covariance_heatmap(alignment.position_parameters)\ntpy.plot_correlation_heatmap(alignment.position_parameters)\n\n# ATE plots\ntpy.plot_compact_ate_hist(ate_result_orb)\ntpy.plot_ate([ate_result_orb, ate_result_sptam])\ntpy.plot_ate_bars([ate_result_orb, ate_result_sptam], mode=\"positions\")\ntpy.plot_ate_bars([ate_result_orb, ate_result_sptam], mode=\"rotations\")\ntpy.plot_ate_edf(ate_result_orb)\ntpy.scatter_ate(ate_result_orb)\n\n# RPE plot\ntpy.plot_rpe(rpe_result)\n\nplt.show()\n</code></pre>"},{"location":"settings/","title":"Settings","text":""},{"location":"settings/#choosing-the-plotting-backend","title":"Choosing the Plotting Backend","text":"<p>Since version 2.2.0, you can choose between two plotting backends: <code>matplotlib</code> and <code>plotly</code>. By default the <code>matplotlib</code> backend is used for quick and simple plotting. If you want to create advanced interactive HTML reports, you can switch to the <code>plotly</code> backend by clicking \"Plotting\" in the menu bar and selecting the desired backend.</p>"},{"location":"settings/#processing-settings","title":"Processing Settings","text":"<p>Trajectopy offers a range of processing options that can be applied to the imported trajectories. These options are:</p> Option Description Alignment Alignment of two trajectories using least squares adjustment. The implemented approach can handle a similarity transformation (translation, rotation, scale), a lever arm (3d vector), and a time shift (scalar). Each parameter can be included or exluded from the adjustment depending on the individual sensor modalities using the <code>AlignmentSettings</code>. In addition, preprocessing steps and stochastics can also be configured. Matching Matching of two trajectories to establish pose-to-pose correspondencies. After matching both trajectories will have the same number of poses. You can choose from different matching methods in the <code>MatchingSettings</code>. Comparison Comparison of two trajectories using absolute (ATE) and relative (RPE) metrics. The relative comparison can be configured using the <code>RelativeComparisonSettings</code>."},{"location":"settings/#alignment-settings","title":"Alignment Settings","text":""},{"location":"settings/#preprocessing-settings","title":"Preprocessing Settings","text":"<ul> <li><code>min_speed</code> (float): Only poses with a speed above this threshold are considered for alignment (meters/second).</li> <li><code>time_start</code> (float): Only poses with a timestamp above this threshold are considered for alignment. The timestamp is given in seconds and is relative to the first common timestamp of both matched trajectories.</li> <li><code>time_end</code> (float): Only poses with a timestamp below this threshold are considered for alignment. The timestamp is given in seconds and is relative to the first common timestamp of both matched trajectories.</li> </ul>"},{"location":"settings/#estimation-settings","title":"Estimation Settings","text":"<ul> <li><code>translation_x</code> (boolean): Enable or disable x-translation of the similarity transformation.</li> <li><code>translation_y</code> (boolean): Enable or disable y-translation of the similarity transformation.</li> <li><code>translation_z</code> (boolean): Enable or disable z-translation of the similarity transformation.</li> <li><code>rotation_x</code> (boolean): Enable or disable rotation around the X-axis of the similarity transformation.</li> <li><code>rotation_y</code> (boolean): Enable or disable rotation around the Y-axis of the similarity transformation.</li> <li><code>rotation_z</code> (boolean): Enable or disable rotation around the Z-axis of the similarity transformation.</li> <li><code>scale</code> (boolean): Enable or disable scaling of the similarity transformation.</li> <li><code>time_shift</code> (boolean): Enable or disable the estimation of time shift.</li> <li><code>leverarm_x</code> (boolean): Enable or disable estimation of lever arm in the X-axis.</li> <li><code>leverarm_y</code> (boolean): Enable or disable estimation of lever arm in the Y-axis.</li> <li><code>leverarm_z</code> (boolean): Enable or disable estimation of lever arm in the Z-axis.</li> <li><code>sensor_rotation</code> (boolean): Enable or disable computation of sensor rotation offsets. Independent of the least squares adjustment, constant offsets between the roll, pitch and yaw angles of both trajectories are computed. This is a brute-force alignment of the orientations and should only be used as a last resort if the orientations of both trajectories are not aligned. Usually, most rotational misalignments are related to different n-frame definitions and can be solved by setting the <code>n_frame</code> parameter correctly (ned or enu) within the .traj file header. Try this before using the sensor rotation option.</li> </ul>"},{"location":"settings/#stochastics-settings","title":"Stochastics Settings","text":"<ul> <li><code>std_xy_from</code> (float): Standard deviation of XY source position components in meters.</li> <li><code>std_z_from</code> (float): Standard deviation of Z source position component in meters.</li> <li><code>std_xy_to</code> (float): Standard deviation of XY target position components in meters.</li> <li><code>std_z_to</code> (float): Standard deviation of Z target position component in meters.</li> <li><code>std_roll_pitch</code> (float): Standard deviation of roll and pitch in radians.</li> <li><code>std_yaw</code> (float): Standard deviation of yaw in radians.</li> <li><code>std_speed_to</code> (float): Standard deviation of platform speed in (meters per second).</li> <li><code>error_probability</code> (float): Probability of error used for stochastic testing.</li> <li><code>variance_estimation</code> (boolean): Enable or disable the estimation of the variance factor for a-posteriori variance computation.</li> </ul>"},{"location":"settings/#threshold-settings","title":"Threshold Settings","text":"<p>Usually, these settings can be left at their default values.</p> <ul> <li><code>metric_threshold</code> (float): Iteration threshold for the least squares adjustment regarding the metric parameters.</li> <li><code>time_threshold</code> (float): Iteration threshold in seconds for the least squares adjustment regarding the time shift parameter.</li> </ul>"},{"location":"settings/#matching-settings","title":"Matching Settings","text":"<ul> <li><code>method</code> (<code>MatchingMethod</code>): The method used for trajectory matching. Choices: <code>MatchingMethod.NEAREST_SPATIAL</code>, <code>MatchingMethod.NEAREST_TEMPORAL</code>, <code>MatchingMethod.INTERPOLATION</code>, <code>MatchingMethod.NEAREST_SPATIAL_INTERPOLATED</code>. The methods are described below.</li> <li><code>max_time_diff</code> (float): Maximum allowed time difference in seconds when matching two trajectories using their timestamps.</li> <li><code>max_distance</code> (float): Maximum allowed distance in meters between matched positions during spatial matching.</li> <li><code>max_gap_size</code> (float): Maximum allowed gap size in seconds within a trajectory during matching.</li> <li><code>k_nearest</code> (integer): The number of nearest neighbors to consider during spatial interpolation matching.</li> </ul>"},{"location":"settings/#matching-methods","title":"Matching Methods","text":""},{"location":"settings/#nearest-spatial","title":"Nearest Spatial","text":"<p>This method matches two trajectories by finding the nearest pose in the target trajectory for each pose in the source trajectory. The distance between two poses is computed using the Euclidean distance between their positions.</p>"},{"location":"settings/#nearest-temporal","title":"Nearest Temporal","text":"<p>This method matches two trajectories using their timestamps by finding the nearest timestamp in the target trajectory for each timestamp in the source trajectory.</p>"},{"location":"settings/#interpolation","title":"Interpolation","text":"<p>This method matches two trajectories by interpolating the timestamps of one trajectory to the timestamps of the other trajectory. The interpolation is linear for both positions and rotations (SLERP).</p>"},{"location":"settings/#nearest-spatial-interpolated","title":"Nearest Spatial Interpolated","text":"<p>This method matches both trajectories spatially by requesting the nearest k positions from the reference trajectory for each pose in the test trajectory. Then, an interpolation is performed using a 3d line fit of the k nearest positions. After this operation, both trajectories will have the length of the test trajectory. This method does not support rotation matching.</p>"},{"location":"settings/#relative-comparison-settings","title":"Relative Comparison Settings","text":"<ul> <li> <p><code>pair_min_distance</code> (float): Minimum pose pair distance to be considered during RPE (Relative Pose Error) computation.</p> </li> <li> <p><code>pair_max_distance</code> (float): Maximum pose pair distance to be considered during RPE computation.</p> </li> <li> <p><code>pair_distance_step</code> (float): Step in which the pose pair distance increases.</p> </li> <li> <p><code>pair_distance_unit</code> (<code>Unit</code>): Unit of the pose pair distance. Choices: <code>Unit.METER</code>, <code>Unit.SECOND</code>.</p> </li> <li> <p><code>use_all_pose_pairs</code> (boolean): If enabled, overlapping pose pairs will be used for relative metrics calculation.</p> </li> </ul>"},{"location":"settings/#rpe-background","title":"RPE Background","text":"<p>For this metric, relative pose-pair differences are compared. The distance between two poses can be specified by the user and can be either time- or distance-based. The comparison involves finding pose pairs separated by a specific distance or time interval, computing the relative translation and rotation between the reference and estimated pose pairs, and calculating the translational and rotational difference normalized by the distance or time that separated the poses.</p> <ol> <li>Find pose pair separated by e.g. 100 m in reference trajectory. This pair represents the start and end poses of a sequence of size .</li> <li>Find the corresponding pose pair in estimated trajectory</li> <li> <p>Compute relative translation and rotation between the reference pose pair</p> <p> </p> </li> <li> <p>Compute relative translation and rotation between the estimated pose pair</p> <p> </p> </li> <li> <p>Compute transformation between 3) and 4)</p> </li> <li> <p>Compute translation and rotation error from 5)</p> </li> <li> <p>Divide 6) by the distance or the time that separated both poses (e.g. 100 m).</p> </li> </ol> <p>This metric does not require both trajectories to be aligned. Units are m/m: %, deg/m for distance based comparison and m/s, deg/s for time-based comparison. </p> <p>Example:</p> <ul> <li>Minimum pose distance: 100</li> <li>Maximum pose distance: 800</li> <li>Distance step: 100</li> <li>Distance unit: Meter</li> </ul> <p>Results in pose distances: [100 m, 200 m, 300 m, 400 m, 500 m, 600 m, 700 m, 800 m]</p> <p>Furthermore, the user can choose to either use consecutive pose pairs (non-overlapping) or all posible pairs (overlapping).</p>"},{"location":"settings/#report-settings","title":"Report Settings","text":""},{"location":"settings/#visualization-settings","title":"Visualization Settings","text":"<ul> <li><code>single_plot_height</code> (int): The height of a single plot. Default value is 450.</li> <li><code>two_subplots_height</code> (int): The height of two subplots. Default value is 540.</li> <li><code>three_subplots_height</code> (int): The height of three subplots. Default value is 750.</li> <li><code>scatter_max_std</code> (float): The upper colorbar limit is set to the mean plus this value times the standard deviation of the data. This is useful to prevent outliers from dominating the colorbar. Default value is 4.0.</li> <li><code>ate_unit_is_mm</code> (bool): Indicates whether the unit of Absolute Trajectory Error (ATE) is millimeters. Default value is False.</li> <li><code>directed_ate</code> (bool): Indicates whether the ATE is split into along-, horizontal-cross- and vertical-cross-track direction. Default value is True.</li> <li><code>histogram_opacity</code> (float): The opacity of the histogram bars. Default value is 0.7.</li> <li><code>histogram_bargap</code> (float): The gap between histogram bars. Default value is 0.1.</li> <li><code>histogram_barmode</code> (str): The mode of displaying histogram bars. Default value is \"overlay\".</li> <li><code>histogram_yaxis_title</code> (str): The title of the y-axis in the histogram. Default value is \"Count\".</li> <li><code>plot_mode</code> (str): The mode of displaying plots. Default value is \"lines+markers\".</li> <li><code>scatter_mode</code> (str): The mode of displaying scatter plots. Default value is \"markers\".</li> <li><code>scatter_colorscale</code> (str): The colorscale for scatter plots. Default value is \"RdYlBu_r\".</li> <li><code>scatter_axis_order</code> (str): The order of the axes in scatter plots. Default value is \"xy\". If 3d plotting is desired, also specify \"z\".</li> <li><code>scatter_marker_size</code> (int): The size of markers in scatter plots. Default value is 5.</li> <li><code>scatter_show_individual_dofs</code> (bool): Indicates whether to show scatter plots for each degree of freedom. Default value is False.</li> </ul>"},{"location":"settings/#ate-frame-definition","title":"ATE Frame Definition","text":"<p>By default, the ATE is split into along-, horizontal-cross- and vertical-cross-track directions. The along-track direction is defined as positive in the direction of travel. The horizontal cross-track direction is defined as positive to the right of the along-track direction. The vertical cross-track direction is defined as positive upwards. The following image illustrates the frame definition.</p> <p></p>"},{"location":"settings/#mapbox-settings","title":"Mapbox Settings","text":"<p>These settings currently only apply to trajectory only plots without deviations.</p> <ul> <li><code>scatter_plot_on_map</code> (bool): Indicates whether the trajectory should be plotted onto a map. Default value is False.</li> <li><code>scatter_mapbox_style</code> (str): The style of the map. For some styles, a Mapbox token is required. Default value is \"open-street-map\".</li> <li><code>scatter_mapbox_zoom</code> (int): The zoom level of the map. Default value is 15.</li> <li><code>scatter_mapbox_token</code> (str): The Mapbox token. Default value is \"\".</li> </ul> <p>The mapbox token can be obtained from https://www.mapbox.com/ after creating a free account. The token can be set in multiple ways:</p> <ul> <li>As a command line argument <code>--mapbox_token</code>.</li> <li>As an environment variable <code>MAPBOX_TOKEN</code>.</li> <li>Directly in the settings file.</li> <li>In the GUI settings dialog.</li> <li>By placing a file named <code>.mapbox_token</code> in the current working directory.</li> </ul>"},{"location":"settings/#position-units-and-names","title":"Position Units and Names","text":"<ul> <li><code>pos_x_name</code> (string): Name for the X-axis position. Default: \"x\".</li> <li><code>pos_y_name</code> (string): Name for the Y-axis position. Default: \"y\".</li> <li><code>pos_z_name</code> (string): Name for the Z-axis position. Default: \"z\".</li> <li><code>pos_x_unit</code> (string): Unit for the X-axis position, Default: \"m\".</li> <li><code>pos_y_unit</code> (string): Unit for the Y-axis position, Default: \"m\".</li> <li><code>pos_z_unit</code> (string): Unit for the Z-axis position, Default: \"m\".</li> <li><code>directed_pos_dev_x_name</code> (string): Name for the directed position deviation in along-track direction. Default: \"along\".</li> <li><code>directed_pos_dev_y_name</code> (string): Name for the directed position deviation in horizontal cross-track direction. Default: \"cross-h\".</li> <li><code>directed_pos_dev_z_name</code> (string): Name for the directed position deviation in vertical cross-track direction. Default: \"cross-v\".</li> </ul>"},{"location":"settings/#rotation-units-and-names","title":"Rotation Units and Names","text":"<ul> <li><code>rot_x_name</code> (string): Name for the roll rotation. Default: \"roll\".</li> <li><code>rot_y_name</code> (string): Name for the pitch rotation. Default: \"pitch\".</li> <li><code>rot_z_name</code> (string): Name for the yaw rotation. Default: \"yaw\".</li> <li><code>rot_unit</code> (string): Unit symbol for rotation. Default: \"\u00b0\".</li> </ul>"},{"location":"settings/#export-settings","title":"Export Settings","text":"<ul> <li><code>single_plot_export</code> (ExportSettings): The export settings for single plots. Default value is an instance of ExportSettings with width=800 and height=450.</li> <li><code>two_subplots_export</code> (ExportSettings): The export settings for two subplots. Default value is an instance of ExportSettings with width=800 and height=540.</li> <li><code>three_subplots_export</code> (ExportSettings): The export settings for three subplots. Default value is an instance of ExportSettings with width=800 and height=750.</li> </ul>"},{"location":"settings/#export-settings_1","title":"Export Settings","text":"<ul> <li><code>format</code> (string): The export format. Choices: \"png\", \"svg\", \"jpeg\", \"webp\". Default: \"png\".</li> <li><code>height</code> (integer): The export height in pixels. Default: 500.</li> <li><code>width</code> (integer): The export width in pixels. Default: 800.</li> <li><code>scale</code> (integer): The export scale. Default: 6.</li> </ul>"},{"location":"settings/#matplotlib-plotting-settings-mplplotsettings","title":"Matplotlib Plotting Settings (MPLPlotSettings)","text":"<ul> <li><code>colorbar_show_zero_crossing</code> (bool): Indicates whether the colorbar should show zero. Default value is True.</li> <li><code>colorbar_steps</code> (int): The number of steps in the colorbar. Default value is 4.</li> <li><code>scatter_hide_axes</code> (bool): Indicates whether the axis should be hidden. Default value is False.</li> <li><code>scatter_smooth</code> (bool): Indicates whether the data defining the color of a scatter plot should be smoothed. Default value is False.</li> <li><code>scatter_smooth_window</code> (int): The window size for smoothing the scatter plot. Default value is 5.</li> <li><code>colorbar_max_std</code> (float): The upper colorbar limit is set to the mean plus this value times the standard deviation of the data. This is useful to prevent outliers from dominating the colorbar. Default value is 3.0.</li> <li><code>ate_unit_is_mm</code> (bool): Indicates whether the unit of Absolute Trajectory Error (ATE) is millimeters. Default value is False.</li> <li><code>hist_as_stairs</code> (bool): Indicates whether the histogram should be displayed as stairs. Default value is False.</li> <li><code>directed_ate</code> (bool): Indicates whether the ATE is split into along-, horizontal-cross- and vertical-cross-track direction. Default value is False.</li> <li><code>scatter_3d</code> (bool): Indicates whether the scatter plot should be 3D. Default value is False.</li> <li><code>dofs_tab</code> (bool): Indicates whether the degrees of freedom tab should be shown. Default value is True.</li> <li><code>velocity_tab</code> (bool): Indicates whether the velocity tab should be shown. Default value is True.</li> <li><code>height_tab</code> (bool): Indicates whether the height tab should be shown. Default value is True.</li> </ul>"},{"location":"Documentation/ATEResult/","title":"ATEResult","text":""},{"location":"Documentation/ATEResult/#module-trajectopycoreevaluationate_result","title":"module <code>trajectopy.core.evaluation.ate_result</code>","text":"<p>Trajectopy - Trajectory Evaluation in Python </p> <p>Gereon Tombrink, 2025 tombrink@igg.uni-bonn.de </p>"},{"location":"Documentation/ATEResult/#class-ateresult","title":"class <code>ATEResult</code>","text":"<p>This class represents a set of absolute trajectory deviations </p> <p>Absolute trajectory deviations describe absolute pose deviations between two trajectories. The deviations are calculated by comparing pairs of positions and orientations in the test and reference trajectory. </p> <p>Attributes:</p> <ul> <li><code>trajectory</code> (Trajectory):  The trajectory the deviations are belonging to </li> <li><code>abs_dev</code> (AbsoluteTrajectoryDeviations):  The absolute trajectory deviations </li> <li><code>name</code> (str):  The name of the result </li> </ul>"},{"location":"Documentation/ATEResult/#method-ateresult__init__","title":"method <code>ATEResult.__init__</code>","text":"<pre><code>__init__(\n    trajectory: trajectopy.trajectory.Trajectory,\n    abs_dev: trajectopy.core.evaluation.deviations.AbsoluteTrajectoryDeviations,\n    name: str = ''\n) \u2192 None\n</code></pre>"},{"location":"Documentation/ATEResult/#property-ateresultcolumns","title":"property ATEResult.columns","text":"<p>Returns the column names of the dataframe </p>"},{"location":"Documentation/ATEResult/#property-ateresulthas_orientation","title":"property ATEResult.has_orientation","text":"<p>Returns True if orientation is available </p>"},{"location":"Documentation/ATEResult/#property-ateresultpos_ate","title":"property ATEResult.pos_ate","text":"<p>Returns mean of 3d position deviations </p>"},{"location":"Documentation/ATEResult/#property-ateresultpos_bias_along","title":"property ATEResult.pos_bias_along","text":"<p>Returns along track bias </p>"},{"location":"Documentation/ATEResult/#property-ateresultpos_bias_cross_h","title":"property ATEResult.pos_bias_cross_h","text":"<p>Returns horizontal cross track bias </p>"},{"location":"Documentation/ATEResult/#property-ateresultpos_bias_cross_v","title":"property ATEResult.pos_bias_cross_v","text":"<p>Returns vertical cross track bias </p>"},{"location":"Documentation/ATEResult/#property-ateresultpos_bias_x","title":"property ATEResult.pos_bias_x","text":"<p>Returns x bias </p>"},{"location":"Documentation/ATEResult/#property-ateresultpos_bias_y","title":"property ATEResult.pos_bias_y","text":"<p>Returns y bias </p>"},{"location":"Documentation/ATEResult/#property-ateresultpos_bias_z","title":"property ATEResult.pos_bias_z","text":"<p>Returns z bias </p>"},{"location":"Documentation/ATEResult/#property-ateresultpos_dev_along","title":"property ATEResult.pos_dev_along","text":"<p>Returns deviations of along track deviations </p>"},{"location":"Documentation/ATEResult/#property-ateresultpos_dev_comb","title":"property ATEResult.pos_dev_comb","text":"<p>Returns position deviations combined using the L2 norm </p>"},{"location":"Documentation/ATEResult/#property-ateresultpos_dev_cross_h","title":"property ATEResult.pos_dev_cross_h","text":"<p>Returns deviations of horizontal cross track deviations </p>"},{"location":"Documentation/ATEResult/#property-ateresultpos_dev_cross_v","title":"property ATEResult.pos_dev_cross_v","text":"<p>Returns deviations of vertical cross track deviations </p>"},{"location":"Documentation/ATEResult/#property-ateresultpos_dev_max","title":"property ATEResult.pos_dev_max","text":"<p>Returns max of 3d position deviations </p>"},{"location":"Documentation/ATEResult/#property-ateresultpos_dev_median","title":"property ATEResult.pos_dev_median","text":"<p>Returns min of 3d position deviations </p>"},{"location":"Documentation/ATEResult/#property-ateresultpos_dev_min","title":"property ATEResult.pos_dev_min","text":"<p>Returns min of 3d position deviations </p>"},{"location":"Documentation/ATEResult/#property-ateresultpos_dev_rms","title":"property ATEResult.pos_dev_rms","text":"<p>Returns RMS of 3d positions </p>"},{"location":"Documentation/ATEResult/#property-ateresultpos_dev_std","title":"property ATEResult.pos_dev_std","text":"<p>Returns std of 3d position deviations </p>"},{"location":"Documentation/ATEResult/#property-ateresultpos_dev_x","title":"property ATEResult.pos_dev_x","text":"<p>Returns x deviations </p>"},{"location":"Documentation/ATEResult/#property-ateresultpos_dev_y","title":"property ATEResult.pos_dev_y","text":"<p>Returns y deviations </p>"},{"location":"Documentation/ATEResult/#property-ateresultpos_dev_z","title":"property ATEResult.pos_dev_z","text":"<p>Returns z deviations </p>"},{"location":"Documentation/ATEResult/#property-ateresultpos_rms_along","title":"property ATEResult.pos_rms_along","text":"<p>Returns RMS of along track deviations </p>"},{"location":"Documentation/ATEResult/#property-ateresultpos_rms_cross_h","title":"property ATEResult.pos_rms_cross_h","text":"<p>Returns RMS of horizontal cross track deviations </p>"},{"location":"Documentation/ATEResult/#property-ateresultpos_rms_cross_v","title":"property ATEResult.pos_rms_cross_v","text":"<p>Returns RMS of vertical cross track deviations </p>"},{"location":"Documentation/ATEResult/#property-ateresultpos_rms_x","title":"property ATEResult.pos_rms_x","text":"<p>Returns RMS of x deviations </p>"},{"location":"Documentation/ATEResult/#property-ateresultpos_rms_y","title":"property ATEResult.pos_rms_y","text":"<p>Returns RMS of y deviations </p>"},{"location":"Documentation/ATEResult/#property-ateresultpos_rms_z","title":"property ATEResult.pos_rms_z","text":"<p>Returns RMS of z deviations </p>"},{"location":"Documentation/ATEResult/#property-ateresultproperty_dict","title":"property ATEResult.property_dict","text":""},{"location":"Documentation/ATEResult/#property-ateresultrot_ate","title":"property ATEResult.rot_ate","text":"<p>Returns mean of rotation deviations </p>"},{"location":"Documentation/ATEResult/#property-ateresultrot_bias_x","title":"property ATEResult.rot_bias_x","text":"<p>Returns roll bias </p>"},{"location":"Documentation/ATEResult/#property-ateresultrot_bias_y","title":"property ATEResult.rot_bias_y","text":"<p>Returns pitch bias </p>"},{"location":"Documentation/ATEResult/#property-ateresultrot_bias_z","title":"property ATEResult.rot_bias_z","text":"<p>Returns yaw bias </p>"},{"location":"Documentation/ATEResult/#property-ateresultrot_dev_comb","title":"property ATEResult.rot_dev_comb","text":"<p>Returns rotation deviations as single rotation angles </p>"},{"location":"Documentation/ATEResult/#property-ateresultrot_dev_max","title":"property ATEResult.rot_dev_max","text":"<p>Returns max of rotations </p>"},{"location":"Documentation/ATEResult/#property-ateresultrot_dev_median","title":"property ATEResult.rot_dev_median","text":"<p>Returns median of rotations </p>"},{"location":"Documentation/ATEResult/#property-ateresultrot_dev_min","title":"property ATEResult.rot_dev_min","text":"<p>Returns min of rotations </p>"},{"location":"Documentation/ATEResult/#property-ateresultrot_dev_rms","title":"property ATEResult.rot_dev_rms","text":"<p>Returns RMS of rotations </p>"},{"location":"Documentation/ATEResult/#property-ateresultrot_dev_std","title":"property ATEResult.rot_dev_std","text":"<p>Returns STD of rotations </p>"},{"location":"Documentation/ATEResult/#property-ateresultrot_dev_x","title":"property ATEResult.rot_dev_x","text":"<p>Returns roll deviations </p>"},{"location":"Documentation/ATEResult/#property-ateresultrot_dev_y","title":"property ATEResult.rot_dev_y","text":"<p>Returns pitch deviations </p>"},{"location":"Documentation/ATEResult/#property-ateresultrot_dev_z","title":"property ATEResult.rot_dev_z","text":"<p>Returns yaw deviations </p>"},{"location":"Documentation/ATEResult/#property-ateresultrot_rms_x","title":"property ATEResult.rot_rms_x","text":"<p>Returns RMS of roll deviations </p>"},{"location":"Documentation/ATEResult/#property-ateresultrot_rms_y","title":"property ATEResult.rot_rms_y","text":"<p>Returns RMS of pitch deviations </p>"},{"location":"Documentation/ATEResult/#property-ateresultrot_rms_z","title":"property ATEResult.rot_rms_z","text":"<p>Returns RMS of yaw deviations </p>"},{"location":"Documentation/ATEResult/#handler-ateresultrot_bias_xyz","title":"handler ATEResult.rot_bias_xyz","text":""},{"location":"Documentation/ATEResult/#handler-ateresultrot_dev_xyz","title":"handler ATEResult.rot_dev_xyz","text":""},{"location":"Documentation/ATEResult/#classmethod-ateresultfrom_file","title":"classmethod <code>ATEResult.from_file</code>","text":"<pre><code>from_file(filename: str)\n</code></pre>"},{"location":"Documentation/ATEResult/#method-ateresultto_dataframe","title":"method <code>ATEResult.to_dataframe</code>","text":"<pre><code>to_dataframe() \u2192 DataFrame\n</code></pre> <p>Exports results as pandas dataframe </p>"},{"location":"Documentation/ATEResult/#method-ateresultto_file","title":"method <code>ATEResult.to_file</code>","text":"<pre><code>to_file(filename: str, mode: str = 'a') \u2192 None\n</code></pre> <p>Exports results as csv </p>"},{"location":"Documentation/Alignment/","title":"Alignment","text":""},{"location":"Documentation/Alignment/#module-trajectopyalignment","title":"module <code>trajectopy.alignment</code>","text":"<p>Trajectopy - Trajectory Evaluation in Python </p> <p>Gereon Tombrink, 2025 tombrink@igg.uni-bonn.de </p>"},{"location":"Documentation/Alignment/#function-estimate_alignment","title":"function <code>estimate_alignment</code>","text":"<pre><code>estimate_alignment(\n    traj_from: trajectopy.trajectory.Trajectory,\n    traj_to: trajectopy.trajectory.Trajectory,\n    alignment_settings: trajectopy.settings.AlignmentSettings = AlignmentSettings(preprocessing=AlignmentPreprocessing(min_speed=0.0, time_start=0.0, time_end=0.0), estimation_settings=AlignmentEstimationSettings(translation_x=True, translation_y=True, translation_z=True, rotation_x=True, rotation_y=True, rotation_z=True, scale=False, time_shift=False, leverarm_x=False, leverarm_y=False, leverarm_z=False, sensor_rotation=False), stochastics=AlignmentStochastics(std_xy_from=1.0, std_z_from=1.0, std_xy_to=1.0, std_z_to=1.0, std_roll_pitch=0.017453292519943295, std_yaw=0.017453292519943295, std_speed=1.0, error_probability=0.05, variance_estimation=False), metric_threshold=0.0001, time_threshold=0.0001),\n    matching_settings: trajectopy.settings.MatchingSettings = MatchingSettings(method=&lt;MatchingMethod.INTERPOLATION: 'interpolation'&gt;, max_time_diff=0.01, max_distance=0.0, max_gap_size=10.0, k_nearest=10)\n) \u2192 AlignmentResult\n</code></pre> <p>Aligns two trajectories </p> <p>Performs a  - Helmert  - Leverarm  - Time shift </p> <p>estimation depending on the configuration. After this, the estimated parameters are applied to the 'traj_from' trajectory. </p> <p>Args:</p> <ul> <li>traj_from (Trajectory) </li> <li>traj_to (Trajectory) </li> <li>alignment_settings (AlignmentSettings, optional): Settings for the alignment process. Defaults to AlignmentSettings(). </li> <li>matching_settings (MatchingSettings, optional): Settings for the matching process. Defaults to MatchingSettings(). </li> </ul> <p>Returns:</p> <ul> <li><code>AlignmentResult</code>:  Result of the alignment process </li> </ul>"},{"location":"Documentation/Custom_Alignment/","title":"Importing a custom alignment","text":"<p>You can import a custom alignment by importing a custom result file. The result file is a CSV file with the following structure:</p> <pre><code>#type Alignment\n#name My Custom Alignment\n1.23,True\n4.56,True\n7.89,True\n0.00,True\n0.10,True\n0.20,True\n1.00,False\n0.00,False\n0.00,False\n0.00,False\n0.00,False\n0.00,False\n0.00,False\n0.00,False\n</code></pre> <p>The first line of the file is a comment that indicates the type of the file. This line is mandatory. The second line is a comment that indicates the name of the alignment. The rest of the lines are the parameter values followed by a boolean value that indicates whether the parameter is enabled or not. The order of the parameters are:</p> <ul> <li><code>similarity translation x [m]</code></li> <li><code>similarity translation y [m]</code></li> <li><code>similarity translation z [m]</code></li> <li><code>similarity rotation x [rad]</code></li> <li><code>similarity rotation y [rad]</code></li> <li><code>similarity rotation z [rad]</code></li> <li><code>similarity scale x</code></li> <li><code>time shift [s]</code></li> <li><code>leverarm x [m]</code></li> <li><code>leverarm y [m]</code></li> <li><code>leverarm z [m]</code></li> <li><code>sensor rotation x [rad]</code></li> <li><code>sensor rotation y [rad]</code></li> <li><code>sensor rotation z [rad]</code></li> </ul>"},{"location":"Documentation/Custom_Plotting/","title":"Custom Matplotlib Plotting","text":"<p>You can customize the style of the plots by placing a <code>custom.mplstyle</code> file in the current working directory. The default style that Trajectopy uses is:</p> <pre><code>figure.figsize: 8, 6\nfigure.facecolor: white\n\nfont.size: 12\nfont.family: serif\nfont.serif: Times New Roman, DejaVu Serif\n\naxes.facecolor: white\naxes.edgecolor: black\naxes.linewidth: 0.8\naxes.labelsize: 14\naxes.titlesize: 14\naxes.grid: True\naxes.axisbelow: True\naxes.prop_cycle: cycler(\"color\", [\"#1E88E5\", \"#FFC107\", \"#004D40\", \"#D81B60\", \"#2bd2bb\", \"#a3bbf1\", \"#3c41fd\", \"#cc5510\", \"#3b0732\", \"#88122b\", \"#bccb70\", \"#dc9c54\"])\n\ngrid.color: gray\ngrid.alpha: 0.3\ngrid.linewidth: 0.5\naxes.grid.which: major\n\nxtick.labelsize: 12\nytick.labelsize: 12\nxtick.direction: in\nytick.direction: in\nxtick.major.size: 5\nytick.major.size: 5\n\nlines.linewidth: 1.5\nlines.linestyle: -\nlines.marker: .\nlines.markersize: 6\n\nlegend.frameon: True\nlegend.facecolor: white\nlegend.edgecolor: black\nlegend.loc: best\nlegend.framealpha: 1\n\nsavefig.dpi: 600\nsavefig.format: pdf\nsavefig.bbox: tight\n</code></pre>"},{"location":"Documentation/Evaluation/","title":"Evaluation","text":""},{"location":"Documentation/Evaluation/#module-trajectopyevaluation","title":"module <code>trajectopy.evaluation</code>","text":"<p>Trajectopy - Trajectory Evaluation in Python </p> <p>Gereon Tombrink, 2025 tombrink@igg.uni-bonn.de </p>"},{"location":"Documentation/Evaluation/#function-ate","title":"function <code>ate</code>","text":"<pre><code>ate(\n    trajectory_gt: trajectopy.trajectory.Trajectory,\n    trajectory_est: trajectopy.trajectory.Trajectory,\n    settings: trajectopy.settings.ProcessingSettings = ProcessingSettings(alignment=AlignmentSettings(preprocessing=AlignmentPreprocessing(min_speed=0.0, time_start=0.0, time_end=0.0), estimation_settings=AlignmentEstimationSettings(translation_x=True, translation_y=True, translation_z=True, rotation_x=True, rotation_y=True, rotation_z=True, scale=False, time_shift=False, leverarm_x=False, leverarm_y=False, leverarm_z=False, sensor_rotation=False), stochastics=AlignmentStochastics(std_xy_from=1.0, std_z_from=1.0, std_xy_to=1.0, std_z_to=1.0, std_roll_pitch=0.017453292519943295, std_yaw=0.017453292519943295, std_speed=1.0, error_probability=0.05, variance_estimation=False), metric_threshold=0.0001, time_threshold=0.0001), matching=MatchingSettings(method=&lt;MatchingMethod.INTERPOLATION: 'interpolation'&gt;, max_time_diff=0.01, max_distance=0.0, max_gap_size=10.0, k_nearest=10), relative_comparison=RelativeComparisonSettings(pair_min_distance=100.0, pair_max_distance=800.0, pair_distance_step=100.0, pair_distance_unit=&lt;PairDistanceUnit.METER: 'meter'&gt;, use_all_pose_pairs=True), approximation=ApproximationSettings(position_interval_size=0.15, position_min_observations=25, rotation_window_size=0.15), sorting=SortingSettings(discard_missing=True, voxel_size=0.05, movement_threshold=0.005, k_nearest=4)),\n    return_alignment: bool = False,\n    align: bool = True\n) \u2192 Union[trajectopy.core.evaluation.ate_result.ATEResult, Tuple[trajectopy.core.evaluation.ate_result.ATEResult, trajectopy.core.alignment.result.AlignmentResult]]\n</code></pre> <p>Computes the absolute trajectory error (ATE) between two trajectories. </p> <p>Args:</p> <ul> <li><code>trajectory_gt</code> (Trajectory):  Ground truth trajectory. </li> <li><code>trajectory_est</code> (Trajectory):  Estimated trajectory. </li> <li><code>settings</code> (ProcessingSettings, optional):  Processing settings. </li> <li><code>return_alignment</code> (bool, optional):  Whether to return the alignment result. </li> </ul> <p>Description: </p> <p>The ATE is computed by first matching the estimated trajectory to the ground truth trajectory. Then, the alignment between the two trajectories is estimated. The estimated trajectory is aligned to the ground truth trajectory using the estimated alignment. Finally, the ATE is computed by comparing the aligned estimated trajectory to the ground truth trajectory. </p> <p>Returns:</p> <ul> <li><code>ATEResult</code>:  Result of the ATE computation. </li> </ul>"},{"location":"Documentation/Evaluation/#function-rpe","title":"function <code>rpe</code>","text":"<pre><code>rpe(\n    trajectory_gt: trajectopy.trajectory.Trajectory,\n    trajectory_est: trajectopy.trajectory.Trajectory,\n    settings: trajectopy.settings.ProcessingSettings = ProcessingSettings(alignment=AlignmentSettings(preprocessing=AlignmentPreprocessing(min_speed=0.0, time_start=0.0, time_end=0.0), estimation_settings=AlignmentEstimationSettings(translation_x=True, translation_y=True, translation_z=True, rotation_x=True, rotation_y=True, rotation_z=True, scale=False, time_shift=False, leverarm_x=False, leverarm_y=False, leverarm_z=False, sensor_rotation=False), stochastics=AlignmentStochastics(std_xy_from=1.0, std_z_from=1.0, std_xy_to=1.0, std_z_to=1.0, std_roll_pitch=0.017453292519943295, std_yaw=0.017453292519943295, std_speed=1.0, error_probability=0.05, variance_estimation=False), metric_threshold=0.0001, time_threshold=0.0001), matching=MatchingSettings(method=&lt;MatchingMethod.INTERPOLATION: 'interpolation'&gt;, max_time_diff=0.01, max_distance=0.0, max_gap_size=10.0, k_nearest=10), relative_comparison=RelativeComparisonSettings(pair_min_distance=100.0, pair_max_distance=800.0, pair_distance_step=100.0, pair_distance_unit=&lt;PairDistanceUnit.METER: 'meter'&gt;, use_all_pose_pairs=True), approximation=ApproximationSettings(position_interval_size=0.15, position_min_observations=25, rotation_window_size=0.15), sorting=SortingSettings(discard_missing=True, voxel_size=0.05, movement_threshold=0.005, k_nearest=4))\n) \u2192 RPEResult\n</code></pre> <p>Computes the relative pose error (RPE) between two trajectories. </p> <p>Args:</p> <ul> <li><code>trajectory_gt</code> (Trajectory):  Ground truth trajectory. </li> <li><code>trajectory_est</code> (Trajectory):  Estimated trajectory. </li> <li><code>settings</code> (ProcessingSettings, optional):  Processing settings. </li> </ul> <p>Description: </p> <p>The RPE is computed by comparing the relative poses between the estimated and ground truth trajectories. The pose distances are either defined in meters or in seconds depending on the settings. </p> <p>Returns:</p> <ul> <li><code>RPEResult</code>:  Result of the RPE computation. </li> </ul>"},{"location":"Documentation/Matching/","title":"Matching","text":""},{"location":"Documentation/Matching/#module-trajectopymatching","title":"module <code>trajectopy.matching</code>","text":"<p>Trajectopy - Trajectory Evaluation in Python </p> <p>Gereon Tombrink, 2025 tombrink@igg.uni-bonn.de </p>"},{"location":"Documentation/Matching/#function-match_trajectories","title":"function <code>match_trajectories</code>","text":"<pre><code>match_trajectories(\n    traj_from: trajectopy.trajectory.Trajectory,\n    traj_to: trajectopy.trajectory.Trajectory,\n    settings: trajectopy.settings.MatchingSettings = MatchingSettings(method=&lt;MatchingMethod.INTERPOLATION: 'interpolation'&gt;, max_time_diff=0.01, max_distance=0.0, max_gap_size=10.0, k_nearest=10),\n    inplace: bool = True\n) \u2192 Tuple[trajectopy.trajectory.Trajectory, trajectopy.trajectory.Trajectory]\n</code></pre> <p>Matches two trajectories using the specified method </p> <p>Args:</p> <ul> <li><code>traj_from</code> (Trajectory):  Trajectory to match </li> <li><code>traj_to</code> (Trajectory):  Reference trajectory </li> <li><code>settings</code> (MatchingSettings, optional):  Matching settings. Defaults to MatchingSettings(). </li> <li><code>inplace</code> (bool, optional):  Whether to modify the input trajectories. Defaults to True. </li> </ul> <p>Supported methods: </p> <ul> <li>MatchingMethod.INTERPOLATION: Interpolates the test trajectory onto the reference trajectory using its timestamps </li> <li>MatchingMethod.NEAREST_TEMPORAL: Find the nearest temporal match without interpolation </li> <li>MatchingMethod.NEAREST_SPATIAL: Find the nearest spatial match without interpolation </li> <li>MatchingMethod.NEAREST_SPATIAL_INTERPOLATED: Find the nearest n spatial matches and spatially interpolate using a 3d line </li> </ul> <p>Nearest Spatial </p> <p>This method matches two trajectories by finding the nearest pose in the target trajectory for each pose in the source trajectory. The distance between two poses is computed using the Euclidean distance between their positions. </p> <p>Nearest Temporal </p> <p>This method matches two trajectories using their timestamps by finding the nearest timestamp in the target trajectory for each timestamp in the source trajectory. </p> <p>Interpolation </p> <p>This method matches two trajectories by interpolating the timestamps of one trajectory to the timestamps of the other trajectory. The interpolation is linear for both positions and rotations (SLERP). </p> <p>Nearest Spatial Interpolated </p> <p>This method matches both trajectories spatially by requesting the nearest k positions from the reference trajectory for each pose in the test trajectory. Then, an interpolation is performed using a 3d line fit of the k nearest positions. After this operation, both trajectories will have the length of the test trajectory. This method does not support rotation matching. </p> <p>Returns:</p> <ul> <li><code>Tuple[Trajectory, Trajectory]</code>:  Matched trajectories </li> </ul>"},{"location":"Documentation/Matching/#function-do_overlap","title":"function <code>do_overlap</code>","text":"<pre><code>do_overlap(\n    traj_test: trajectopy.trajectory.Trajectory,\n    traj_ref: trajectopy.trajectory.Trajectory\n) \u2192 bool\n</code></pre> <p>Checks if two trajectories overlap </p> <p>Args:</p> <ul> <li><code>traj_test</code> (Trajectory):  Test trajectory </li> <li><code>traj_ref</code> (Trajectory):  Reference trajectory </li> </ul> <p>Returns:</p> <ul> <li><code>bool</code>:  True if the trajectories overlap, False otherwise </li> </ul>"},{"location":"Documentation/Matching/#function-match_trajectories_interpolation","title":"function <code>match_trajectories_interpolation</code>","text":"<pre><code>match_trajectories_interpolation(\n    traj_test: trajectopy.trajectory.Trajectory,\n    traj_ref: trajectopy.trajectory.Trajectory,\n    max_gap_size: float = 10.0\n) \u2192 Tuple[trajectopy.trajectory.Trajectory, trajectopy.trajectory.Trajectory]\n</code></pre> <p>Ensures that both trajectories are sampled in the same way </p> <p>This method will intersect both trajectories with each other and then approximate the trajectory with the higher data rate onto the other trajectory. The sorting and the arc lengths of both trajectories are identical after the call of this method. </p> <p>Args:</p> <ul> <li><code>traj_test</code> (Trajectory):  Test trajectory </li> <li><code>traj_ref</code> (Trajectory):  Reference trajectory </li> </ul> <p>Returns:</p> <ul> <li><code>Tuple[Trajectory, Trajectory]</code>:  Both trajectories with the  same sampling. The instance  which called this method is  the first returned trajectory. </li> </ul>"},{"location":"Documentation/Matching/#function-match_trajectories_temporal","title":"function <code>match_trajectories_temporal</code>","text":"<pre><code>match_trajectories_temporal(\n    traj_test: trajectopy.trajectory.Trajectory,\n    traj_ref: trajectopy.trajectory.Trajectory,\n    max_distance: float = 0.01\n) \u2192 Tuple[trajectopy.trajectory.Trajectory, trajectopy.trajectory.Trajectory]\n</code></pre> <p>This method matches both trajectories temporally </p> <p>After this operation, both trajectories will have the length of the test trajectory. This means, that the reference trajectory may be modified. </p> <p>Args:</p> <ul> <li><code>traj_test</code> (Trajectory):  Test trajectory </li> <li><code>traj_ref</code> (Trajectory):  Reference trajectory </li> <li><code>max_distance</code> (float, optional):  Maximum distance between two timestamps.  Defaults to 0.1. </li> </ul> <p>Returns:</p> <ul> <li><code>Tuple[Trajectory, Trajectory]</code>:  Matched trajectories </li> </ul>"},{"location":"Documentation/Matching/#function-match_trajectories_spatial","title":"function <code>match_trajectories_spatial</code>","text":"<pre><code>match_trajectories_spatial(\n    traj_test: trajectopy.trajectory.Trajectory,\n    traj_ref: trajectopy.trajectory.Trajectory,\n    max_distance: float = 0.0\n) \u2192 Tuple[trajectopy.trajectory.Trajectory, trajectopy.trajectory.Trajectory]\n</code></pre> <p>This method matches both trajectories spatially </p> <p>After this operation, both trajectories will have the length of the test trajectory. This means, that the reference trajectory may be modified. </p> <p>Args:</p> <ul> <li><code>traj_from</code> (Trajectory):  Test trajectory </li> <li><code>traj_to</code> (Trajectory):  Reference trajectory </li> <li><code>max_distance</code> (float, optional):  Maximum distance between two poses.  Defaults to None. This means all  matches are accepted. </li> </ul> <p>Returns:</p> <ul> <li><code>Tuple[Trajectory, Trajectory]</code>:  Matched trajectories </li> </ul>"},{"location":"Documentation/Matching/#function-match_trajectories_spatial_interpolation","title":"function <code>match_trajectories_spatial_interpolation</code>","text":"<pre><code>match_trajectories_spatial_interpolation(\n    traj_test: trajectopy.trajectory.Trajectory,\n    traj_ref: trajectopy.trajectory.Trajectory,\n    max_distance: float = 0.0,\n    k_nearest: int = 10\n) \u2192 Tuple[trajectopy.trajectory.Trajectory, trajectopy.trajectory.Trajectory]\n</code></pre> <p>This method matches both trajectories spatially by requesting the nearest two poses from the reference trajectory for each pose in the test trajectory. Then, an interpolation is performed between the two nearest poses. </p> <p>After this operation, both trajectories will have the length of the test trajectory. This means, that the reference trajectory may be modified. </p> <p>Args:</p> <ul> <li><code>traj_from</code> (Trajectory):  Test trajectory </li> <li><code>traj_to</code> (Trajectory):  Reference trajectory </li> <li><code>max_distance</code> (float, optional):  Maximum distance between two poses.  Defaults to None. This means all  matches are accepted. </li> <li><code>k_nearest</code> (int, optional):  Number of nearest poses to request from  the reference trajectory. Defaults to 10. </li> </ul> <p>Returns:</p> <ul> <li><code>Tuple[Trajectory, Trajectory]</code>:  Matched trajectories </li> </ul>"},{"location":"Documentation/Matching/#function-rough_timestamp_matching","title":"function <code>rough_timestamp_matching</code>","text":"<pre><code>rough_timestamp_matching(\n    traj_ref: trajectopy.trajectory.Trajectory,\n    traj_test: trajectopy.trajectory.Trajectory,\n    max_distance: float = 0.0\n) \u2192 float\n</code></pre> <p>This method roughly matches two trajectories temporally </p> <p>Args:</p> <ul> <li><code>traj_from</code> (Trajectory):  Test trajectory </li> <li><code>traj_to</code> (Trajectory):  Reference trajectory </li> </ul> <p>Returns:</p> <ul> <li><code>float</code>:  Mean time offset </li> </ul>"},{"location":"Documentation/Merging/","title":"Merging","text":""},{"location":"Documentation/Merging/#module-trajectopymerging","title":"module <code>trajectopy.merging</code>","text":"<p>Trajectopy - Trajectory Evaluation in Python </p> <p>Gereon Tombrink, 2025 tombrink@igg.uni-bonn.de </p>"},{"location":"Documentation/Merging/#function-merge_trajectories","title":"function <code>merge_trajectories</code>","text":"<pre><code>merge_trajectories(\n    trajectories: List[trajectopy.trajectory.Trajectory]\n) \u2192 Trajectory\n</code></pre> <p>Merges a list of trajectories into one trajectory. </p> <p>This function ignores EPSG codes and merges the trajectories based on their timestamps. Therefore, all trajectories should be in the same coordinate system before merging. </p> <p>Args:</p> <ul> <li><code>list[Trajectory]</code>:  List of trajectories to merge. </li> </ul> <p>Returns:</p> <ul> <li><code>Trajectory</code>:  Merged trajectory. </li> </ul>"},{"location":"Documentation/Merging/#function-average_trajectories","title":"function <code>average_trajectories</code>","text":"<pre><code>average_trajectories(\n    trajectories: List[trajectopy.trajectory.Trajectory]\n) \u2192 Trajectory\n</code></pre> <p>Averages a list of trajectories into one trajectory. </p> <p>This function ignores EPSG codes and averages trajectories. </p> <p>Args:</p> <ul> <li><code>list[Trajectory]</code>:  List of trajectories to average. </li> </ul> <p>Returns:</p> <ul> <li><code>Trajectory</code>:  Averaged trajectory. </li> </ul>"},{"location":"Documentation/Plotting/","title":"Plotting","text":""},{"location":"Documentation/Plotting/#module-trajectopyplotting","title":"module <code>trajectopy.plotting</code>","text":"<p>Trajectopy - Trajectory Evaluation in Python </p> <p>Gereon Tombrink, 2025 tombrink@igg.uni-bonn.de </p>"},{"location":"Documentation/Plotting/#function-plot_trajectories","title":"function <code>plot_trajectories</code>","text":"<pre><code>plot_trajectories(\n    trajectories: List[trajectopy.trajectory.Trajectory],\n    scatter_3d: bool = False\n) \u2192 Tuple[matplotlib.figure.Figure, matplotlib.figure.Figure, Optional[matplotlib.figure.Figure]]\n</code></pre> <p>Plots the trajectories in 2d or 3d using matplotlib. </p> <p>Args:</p> <ul> <li><code>trajectories</code> (List[Trajectory]):  List of trajectories to plot. </li> <li><code>dim</code> (int, optional):  Dimension of the plot. Defaults to 2. </li> </ul> <p>This function creates one 2D or 3D plot for the xy(z) coordinates of the trajectories, one subplot for the xyz coordinates and one subplot for the rpy angles. </p> <p>Returns:</p> <ul> <li><code>Tuple[Figure, Figure, Union[Figure, None]]</code>:  Figures for the position, xyz and rpy plots. </li> </ul>"},{"location":"Documentation/Plotting/#function-plot_correlation_heatmap","title":"function <code>plot_correlation_heatmap</code>","text":"<pre><code>plot_correlation_heatmap(\n    estimated_parameters: trajectopy.core.alignment.parameters.AlignmentParameters,\n    enabled_only: bool = True\n) \u2192 Figure\n</code></pre> <p>Plots the correlation heatmap of the alignment parameters using matplotlib. </p> <p>Args:</p> <ul> <li><code>estimated_parameters</code> (AlignmentParameters):  Estimated parameters. </li> <li><code>enabled_only</code> (bool, optional):  Whether to consider only enabled parameters. Defaults to True. </li> </ul> <p>Returns:</p> <ul> <li><code>plt.Figure</code>:  Correlation heatmap figure. </li> </ul>"},{"location":"Documentation/Plotting/#function-plot_covariance_heatmap","title":"function <code>plot_covariance_heatmap</code>","text":"<pre><code>plot_covariance_heatmap(\n    estimated_parameters: trajectopy.core.alignment.parameters.AlignmentParameters,\n    enabled_only: bool = True\n) \u2192 Figure\n</code></pre> <p>Plots the covariance heatmap of the alignment parameters using matplotlib. </p> <p>Args:</p> <ul> <li><code>estimated_parameters</code> (AlignmentParameters):  Estimated parameters. </li> <li><code>enabled_only</code> (bool, optional):  Whether to consider only enabled parameters. Defaults to True. </li> </ul> <p>Returns:</p> <ul> <li><code>plt.Figure</code>:  Covariance heatmap figure. </li> </ul>"},{"location":"Documentation/Plotting/#function-plot_ate_3d","title":"function <code>plot_ate_3d</code>","text":"<pre><code>plot_ate_3d(\n    ate_results: List[trajectopy.core.evaluation.ate_result.ATEResult],\n    plot_settings: trajectopy.settings.MPLPlotSettings = MPLPlotSettings(colorbar_show_zero_crossing=True, colorbar_steps=4, colorbar_max_std=3.0, scatter_hide_axes=False, scatter_3d=False, scatter_smooth=False, scatter_smooth_window=5, ate_unit_is_mm=False, hist_as_stairs=False, directed_ate=False, dofs_tab=True, velocity_tab=True, height_tab=True)\n) \u2192 Figure\n</code></pre> <p>Plots the ATE results in 2D using matplotlib. </p> <p>Args:</p> <ul> <li><code>ate_results</code> (List[ATEResult]):  List of ATE results. </li> <li><code>plot_settings</code> (MPLPlotSettings, optional):  Plot settings. Defaults to MPLPlotSettings(). </li> </ul> <p>Returns:</p> <ul> <li><code>Figure</code>:  Figure containing the plot. </li> </ul>"},{"location":"Documentation/Plotting/#function-plot_ate_bars","title":"function <code>plot_ate_bars</code>","text":"<pre><code>plot_ate_bars(\n    ate_results: List[trajectopy.core.evaluation.ate_result.ATEResult],\n    plot_settings: trajectopy.settings.MPLPlotSettings = MPLPlotSettings(colorbar_show_zero_crossing=True, colorbar_steps=4, colorbar_max_std=3.0, scatter_hide_axes=False, scatter_3d=False, scatter_smooth=False, scatter_smooth_window=5, ate_unit_is_mm=False, hist_as_stairs=False, directed_ate=False, dofs_tab=True, velocity_tab=True, height_tab=True),\n    mode: str = 'positions'\n) \u2192 Figure\n</code></pre> <p>Plots multiple ATE results as bars for different characteristics (min, max, mean, median, rms, std) using matplotlib. </p> <p>Args:</p> <ul> <li><code>ate_result</code> (List[ATEResult]):  List of ATE results. </li> <li><code>plot_settings</code> (MPLPlotSettings, optional):  Plot settings. Defaults to MPLPlotSettings(). </li> <li><code>mode</code> (str, optional):  Mode to plot. Either 'positions' or 'rotations'. Defaults to 'positions'. </li> </ul> <p>Returns:</p> <ul> <li><code>Figure</code>:  Bar plot figure. </li> </ul>"},{"location":"Documentation/Plotting/#function-plot_compact_ate_hist","title":"function <code>plot_compact_ate_hist</code>","text":"<pre><code>plot_compact_ate_hist(\n    ate_result: trajectopy.core.evaluation.ate_result.ATEResult,\n    plot_settings: trajectopy.settings.MPLPlotSettings = MPLPlotSettings(colorbar_show_zero_crossing=True, colorbar_steps=4, colorbar_max_std=3.0, scatter_hide_axes=False, scatter_3d=False, scatter_smooth=False, scatter_smooth_window=5, ate_unit_is_mm=False, hist_as_stairs=False, directed_ate=False, dofs_tab=True, velocity_tab=True, height_tab=True)\n) \u2192 Figure\n</code></pre> <p>Plots compact ATE histograms for the given ATEResult. The plot contains histograms for the position deviations and, if available, the rotation deviations. </p> <p>Args:</p> <ul> <li><code>ate_result</code> (ATEResult):  ATE result to plot. </li> <li><code>plot_settings</code> (MPLPlotSettings, optional):  Plot settings. Defaults to MPLPlotSettings(). </li> </ul> <p>Returns:</p> <ul> <li><code>Figure</code>:  Figure containing the plot. </li> </ul>"},{"location":"Documentation/Plotting/#function-plot_ate","title":"function <code>plot_ate</code>","text":"<pre><code>plot_ate(\n    ate_results: Union[trajectopy.core.evaluation.ate_result.ATEResult, List[trajectopy.core.evaluation.ate_result.ATEResult]],\n    plot_settings: trajectopy.settings.MPLPlotSettings = MPLPlotSettings(colorbar_show_zero_crossing=True, colorbar_steps=4, colorbar_max_std=3.0, scatter_hide_axes=False, scatter_3d=False, scatter_smooth=False, scatter_smooth_window=5, ate_unit_is_mm=False, hist_as_stairs=False, directed_ate=False, dofs_tab=True, velocity_tab=True, height_tab=True)\n) \u2192 Figure\n</code></pre> <p>Plots ATE for the given ATEResult(s) as a line plot using matplotlib. If available, the plot contains the position and rotation deviations. The x-axis depends on the sorting of the trajectory. </p> <p>Args:</p> <ul> <li><code>ate_results</code> (Union[ATEResult, List[ATEResult]]):  ATE result(s) to plot. </li> <li><code>plot_settings</code> (MPLPlotSettings, optional):  Plot settings. Defaults to MPLPlotSettings(). </li> </ul> <p>Returns:</p> <ul> <li><code>Figure</code>:  Figure containing the plot. </li> </ul>"},{"location":"Documentation/Plotting/#function-plot_ate_dof","title":"function <code>plot_ate_dof</code>","text":"<pre><code>plot_ate_dof(\n    ate_result: trajectopy.core.evaluation.ate_result.ATEResult,\n    plot_settings: trajectopy.settings.MPLPlotSettings = MPLPlotSettings(colorbar_show_zero_crossing=True, colorbar_steps=4, colorbar_max_std=3.0, scatter_hide_axes=False, scatter_3d=False, scatter_smooth=False, scatter_smooth_window=5, ate_unit_is_mm=False, hist_as_stairs=False, directed_ate=False, dofs_tab=True, velocity_tab=True, height_tab=True)\n) \u2192 Figure\n</code></pre> <p>Plots ATE DOF (Degrees of Freedom) for the given ATEResult(s) as a line plot using matplotlib. The DOF plot shows the deviations in the x, y, and z directions for position and rotation. </p> <p>Args:</p> <ul> <li><code>ate_results</code> (Union[ATEResult, List[ATEResult]]):  ATE result(s) to plot. </li> <li><code>plot_settings</code> (MPLPlotSettings, optional):  Plot settings. Defaults to MPLPlotSettings(). </li> </ul> <p>Returns:</p> <ul> <li><code>Figure</code>:  Figure containing the plot. </li> </ul>"},{"location":"Documentation/Plotting/#function-plot_ate_edf","title":"function <code>plot_ate_edf</code>","text":"<pre><code>plot_ate_edf(\n    ate_results: Union[trajectopy.core.evaluation.ate_result.ATEResult, List[trajectopy.core.evaluation.ate_result.ATEResult]],\n    plot_settings: trajectopy.settings.MPLPlotSettings = MPLPlotSettings(colorbar_show_zero_crossing=True, colorbar_steps=4, colorbar_max_std=3.0, scatter_hide_axes=False, scatter_3d=False, scatter_smooth=False, scatter_smooth_window=5, ate_unit_is_mm=False, hist_as_stairs=False, directed_ate=False, dofs_tab=True, velocity_tab=True, height_tab=True)\n) \u2192 Figure\n</code></pre> <p>Plots ATE EDF for the given ATEResult(s) as a line plot using matplotlib. The EDF (Empirical Distribution Function) shows the cummulative probability of the deviations. Using this plot, one can easily see how many percent of the deviations are below a certain value. </p> <p>Args:</p> <ul> <li><code>ate_results</code> (Union[ATEResult, List[ATEResult]]):  ATE result to plot. </li> <li><code>plot_settings</code> (MPLPlotSettings, optional):  Plot settings. Defaults to MPLPlotSettings(). </li> </ul> <p>Returns:</p> <ul> <li><code>Figure</code>:  Figure containing the plot. </li> </ul>"},{"location":"Documentation/Plotting/#function-plot_rpe","title":"function <code>plot_rpe</code>","text":"<pre><code>plot_rpe(\n    rpe_results: List[trajectopy.core.evaluation.rpe_result.RPEResult]\n) \u2192 Tuple[matplotlib.figure.Figure, matplotlib.figure.Figure]\n</code></pre> <p>Plots the RPE results as a line plot with violin plots for the position and rotation deviations. </p> <p>Depending on the pair distance unit, the unit of the position deviations is either in meters/meters (%) or meters/seconds. The unit of the rotation deviations is respectively in degrees/m or degrees/second. </p> <p>Args:</p> <ul> <li><code>rpe_results</code> (list[RelativeTrajectoryDeviations]):  list of RelativeTrajectoryDeviations </li> </ul> <p>Returns:</p> <ul> <li><code>Tuple[Figure, Figure]</code>:  metric and time RPE plots </li> </ul>"},{"location":"Documentation/Plotting/#function-scatter_ate","title":"function <code>scatter_ate</code>","text":"<pre><code>scatter_ate(\n    ate_result: trajectopy.core.evaluation.ate_result.ATEResult,\n    plot_settings: trajectopy.settings.MPLPlotSettings = MPLPlotSettings(colorbar_show_zero_crossing=True, colorbar_steps=4, colorbar_max_std=3.0, scatter_hide_axes=False, scatter_3d=False, scatter_smooth=False, scatter_smooth_window=5, ate_unit_is_mm=False, hist_as_stairs=False, directed_ate=False, dofs_tab=True, velocity_tab=True, height_tab=True)\n) \u2192 Tuple[matplotlib.figure.Figure, matplotlib.figure.Figure]\n</code></pre> <p>Plots the ATE results as a scatter plot with color-coded deviations. </p> <p>Args:</p> <ul> <li><code>ate_result</code> (ATEResult):  ATE result to plot. </li> <li><code>plot_settings</code> (MPLPlotSettings, optional):  Plot settings. Defaults to MPLPlotSettings(). </li> </ul>"},{"location":"Documentation/Plotting_On_Map/","title":"Plotting Trajectories on a Map","text":"<p>To plot trajectories on a map, several requirements must be met:</p> <ul> <li>The trajectory must have valid EPSG information.</li> <li>The plotting backend must be set to <code>plotly</code>.</li> <li>The <code>scatter_plot_on_map</code> option must be enabled.</li> <li>For <code>scatter_mapbox_style</code> other than <code>open-street-map</code>, a Mapbox access token (<code>scatter_mapbox_token</code>) must be provided. The mapbox token can be obtained after free registration at Mapbox.</li> </ul>"},{"location":"Documentation/RPEResult/","title":"RPEResult","text":""},{"location":"Documentation/RPEResult/#module-trajectopycoreevaluationrpe_result","title":"module <code>trajectopy.core.evaluation.rpe_result</code>","text":"<p>Trajectopy - Trajectory Evaluation in Python </p> <p>Gereon Tombrink, 2025 tombrink@igg.uni-bonn.de </p>"},{"location":"Documentation/RPEResult/#class-rperesult","title":"class <code>RPEResult</code>","text":"<p>This class represents a set of relative trajectory deviations </p> <p>Relative trajectory deviations describe relative pose deviations between two trajectories. The deviations are calculated by comparing pairs of positions and orientations in the test and reference trajectory. </p> <p>Attributes:</p> <ul> <li><code>rpe_dev</code> (RelativeTrajectoryDeviations):  The relative trajectory deviations. </li> <li><code>name</code> (str):  Name of the deviation set. </li> </ul>"},{"location":"Documentation/RPEResult/#method-rperesult__init__","title":"method <code>RPEResult.__init__</code>","text":"<pre><code>__init__(\n    rpe_dev: trajectopy.core.evaluation.deviations.RelativeTrajectoryDeviations,\n    name: str\n) \u2192 None\n</code></pre>"},{"location":"Documentation/RPEResult/#property-rperesultall_pair_distances","title":"property RPEResult.all_pair_distances","text":""},{"location":"Documentation/RPEResult/#property-rperesultall_rot_devs","title":"property RPEResult.all_rot_devs","text":""},{"location":"Documentation/RPEResult/#property-rperesultcolumns","title":"property RPEResult.columns","text":""},{"location":"Documentation/RPEResult/#property-rperesultdrift_factor","title":"property RPEResult.drift_factor","text":""},{"location":"Documentation/RPEResult/#property-rperesultdynamic_pos_dict","title":"property RPEResult.dynamic_pos_dict","text":""},{"location":"Documentation/RPEResult/#property-rperesultdynamic_rot_dict","title":"property RPEResult.dynamic_rot_dict","text":""},{"location":"Documentation/RPEResult/#property-rperesulthas_rot_dev","title":"property RPEResult.has_rot_dev","text":""},{"location":"Documentation/RPEResult/#property-rperesultmean_pair_distances","title":"property RPEResult.mean_pair_distances","text":""},{"location":"Documentation/RPEResult/#property-rperesultnum_pairs","title":"property RPEResult.num_pairs","text":""},{"location":"Documentation/RPEResult/#property-rperesultpair_distance_unit","title":"property RPEResult.pair_distance_unit","text":""},{"location":"Documentation/RPEResult/#property-rperesultpos_dev_all","title":"property RPEResult.pos_dev_all","text":""},{"location":"Documentation/RPEResult/#property-rperesultpos_dev_max","title":"property RPEResult.pos_dev_max","text":""},{"location":"Documentation/RPEResult/#property-rperesultpos_dev_mean","title":"property RPEResult.pos_dev_mean","text":""},{"location":"Documentation/RPEResult/#property-rperesultpos_dev_median","title":"property RPEResult.pos_dev_median","text":""},{"location":"Documentation/RPEResult/#property-rperesultpos_dev_min","title":"property RPEResult.pos_dev_min","text":""},{"location":"Documentation/RPEResult/#property-rperesultpos_drift_unit","title":"property RPEResult.pos_drift_unit","text":""},{"location":"Documentation/RPEResult/#property-rperesultpos_rpe","title":"property RPEResult.pos_rpe","text":""},{"location":"Documentation/RPEResult/#property-rperesultpos_std","title":"property RPEResult.pos_std","text":""},{"location":"Documentation/RPEResult/#property-rperesultproperty_dict","title":"property RPEResult.property_dict","text":"<p>Returns a dictionary containing the properties of the deviation set relevant for time based comparisons. This is the case when pose-pairs are defined by a time difference. </p>"},{"location":"Documentation/RPEResult/#property-rperesultrot_dev_max","title":"property RPEResult.rot_dev_max","text":""},{"location":"Documentation/RPEResult/#property-rperesultrot_dev_mean","title":"property RPEResult.rot_dev_mean","text":""},{"location":"Documentation/RPEResult/#property-rperesultrot_dev_median","title":"property RPEResult.rot_dev_median","text":""},{"location":"Documentation/RPEResult/#property-rperesultrot_dev_min","title":"property RPEResult.rot_dev_min","text":""},{"location":"Documentation/RPEResult/#property-rperesultrot_drift_unit","title":"property RPEResult.rot_drift_unit","text":""},{"location":"Documentation/RPEResult/#property-rperesultrot_rpe","title":"property RPEResult.rot_rpe","text":"<p>Returns the average rotation drift in radians per 100 meters. </p>"},{"location":"Documentation/RPEResult/#property-rperesultrot_std","title":"property RPEResult.rot_std","text":""},{"location":"Documentation/RPEResult/#property-rperesultstep","title":"property RPEResult.step","text":""},{"location":"Documentation/RPEResult/#method-rperesultcompute_metric","title":"method <code>RPEResult.compute_metric</code>","text":"<pre><code>compute_metric(\n    key: str,\n    func: Callable[[Any], float],\n    factor: float = 1.0\n) \u2192 List[float]\n</code></pre>"},{"location":"Documentation/RPEResult/#classmethod-rperesultfrom_file","title":"classmethod <code>RPEResult.from_file</code>","text":"<pre><code>from_file(filename: str)\n</code></pre> <p>Reads a set of relative trajectory deviations from a file. </p>"},{"location":"Documentation/RPEResult/#method-rperesultget_all","title":"method <code>RPEResult.get_all</code>","text":"<pre><code>get_all(key: str) \u2192 List[float]\n</code></pre>"},{"location":"Documentation/RPEResult/#method-rperesultto_dataframe","title":"method <code>RPEResult.to_dataframe</code>","text":"<pre><code>to_dataframe() \u2192 DataFrame\n</code></pre>"},{"location":"Documentation/RPEResult/#method-rperesultto_file","title":"method <code>RPEResult.to_file</code>","text":"<pre><code>to_file(filename: str, mode: str = 'a') \u2192 None\n</code></pre>"},{"location":"Documentation/Report/","title":"Report","text":""},{"location":"Documentation/Report/#module-trajectopyreport","title":"module <code>trajectopy.report</code>","text":"<p>Trajectopy - Trajectory Evaluation in Python </p> <p>Gereon Tombrink, 2025 tombrink@igg.uni-bonn.de </p>"},{"location":"Documentation/Report/#global-variables","title":"Global Variables","text":"<ul> <li>TEMPLATES_PATH</li> </ul>"},{"location":"Documentation/Report/#function-create_alignment_report","title":"function <code>create_alignment_report</code>","text":"<pre><code>create_alignment_report(\n    alignment_parameters: trajectopy.core.alignment.parameters.AlignmentParameters,\n    name: str = 'Alignment',\n    report_settings: trajectopy.settings.ReportSettings = ReportSettings(single_plot_height=750, two_subplots_height=750, three_subplots_height=860, scatter_max_std=4.0, ate_unit_is_mm=False, directed_ate=False, histogram_opacity=0.7, histogram_bargap=0.1, histogram_barmode='overlay', histogram_yaxis_title='Count', plot_mode='lines+markers', scatter_mode='markers', scatter_colorscale='RdYlBu_r', scatter_axis_order='xy', scatter_marker_size=5, scatter_show_individual_dofs=False, scatter_smooth=False, scatter_smooth_window=5, scatter_plot_on_map=False, scatter_mapbox_style='open-street-map', scatter_mapbox_zoom=15, scatter_mapbox_token='', pos_x_name='x', pos_y_name='y', pos_z_name='z', pos_x_unit='m', pos_y_unit='m', pos_z_unit='m', directed_pos_dev_x_name='along', directed_pos_dev_y_name='cross-h', directed_pos_dev_z_name='cross-v', rot_x_name='roll', rot_y_name='pitch', rot_z_name='yaw', rot_unit='\u00b0', single_plot_export=ExportSettings(format='png', height=540, width=800, scale=1), two_subplots_export=ExportSettings(format='png', height=540, width=800, scale=1), three_subplots_export=ExportSettings(format='png', height=750, width=800, scale=1))\n) \u2192 str\n</code></pre> <p>Render trajectory alignment heatmaps. </p> <p>Heatmaps are covariance matrix and correlation matrix. </p> <p>Args:</p> <ul> <li><code>alignment_parameters</code> (AlignmentParameters):  Estimated alignment parameters. </li> <li><code>name</code> (str, optional):  Name of the report. Defaults to \"Alignment\". </li> <li><code>report_settings</code> (ReportSettings, optional):  Report settings. Defaults to ReportSettings() </li> </ul> <p>Returns:  HTML string of the rendered report including the heatmap plots. </p>"},{"location":"Documentation/Report/#function-create_trajectory_report","title":"function <code>create_trajectory_report</code>","text":"<pre><code>create_trajectory_report(\n    trajectories: List[trajectopy.trajectory.Trajectory],\n    report_settings: trajectopy.settings.ReportSettings = ReportSettings(single_plot_height=750, two_subplots_height=750, three_subplots_height=860, scatter_max_std=4.0, ate_unit_is_mm=False, directed_ate=False, histogram_opacity=0.7, histogram_bargap=0.1, histogram_barmode='overlay', histogram_yaxis_title='Count', plot_mode='lines+markers', scatter_mode='markers', scatter_colorscale='RdYlBu_r', scatter_axis_order='xy', scatter_marker_size=5, scatter_show_individual_dofs=False, scatter_smooth=False, scatter_smooth_window=5, scatter_plot_on_map=False, scatter_mapbox_style='open-street-map', scatter_mapbox_zoom=15, scatter_mapbox_token='', pos_x_name='x', pos_y_name='y', pos_z_name='z', pos_x_unit='m', pos_y_unit='m', pos_z_unit='m', directed_pos_dev_x_name='along', directed_pos_dev_y_name='cross-h', directed_pos_dev_z_name='cross-v', rot_x_name='roll', rot_y_name='pitch', rot_z_name='yaw', rot_unit='\u00b0', single_plot_export=ExportSettings(format='png', height=540, width=800, scale=1), two_subplots_export=ExportSettings(format='png', height=540, width=800, scale=1), three_subplots_export=ExportSettings(format='png', height=750, width=800, scale=1))\n) \u2192 str\n</code></pre> <p>Render a HTML report containing trajectory plots. </p> <p>Args:</p> <ul> <li><code>trajectories</code>:  List of trajectories to render. </li> <li><code>report_settings</code>:  Report settings. </li> </ul> <p>Returns:  HTML string of the rendered report including the trajectory plots. </p>"},{"location":"Documentation/Report/#function-create_deviation_report","title":"function <code>create_deviation_report</code>","text":"<pre><code>create_deviation_report(\n    ate_result: Union[trajectopy.core.evaluation.ate_result.ATEResult, List[trajectopy.core.evaluation.ate_result.ATEResult]],\n    rpe_result: Optional[trajectopy.core.evaluation.rpe_result.RPEResult, List[trajectopy.core.evaluation.rpe_result.RPEResult]],\n    report_settings: trajectopy.settings.ReportSettings = ReportSettings(single_plot_height=750, two_subplots_height=750, three_subplots_height=860, scatter_max_std=4.0, ate_unit_is_mm=False, directed_ate=False, histogram_opacity=0.7, histogram_bargap=0.1, histogram_barmode='overlay', histogram_yaxis_title='Count', plot_mode='lines+markers', scatter_mode='markers', scatter_colorscale='RdYlBu_r', scatter_axis_order='xy', scatter_marker_size=5, scatter_show_individual_dofs=False, scatter_smooth=False, scatter_smooth_window=5, scatter_plot_on_map=False, scatter_mapbox_style='open-street-map', scatter_mapbox_zoom=15, scatter_mapbox_token='', pos_x_name='x', pos_y_name='y', pos_z_name='z', pos_x_unit='m', pos_y_unit='m', pos_z_unit='m', directed_pos_dev_x_name='along', directed_pos_dev_y_name='cross-h', directed_pos_dev_z_name='cross-v', rot_x_name='roll', rot_y_name='pitch', rot_z_name='yaw', rot_unit='\u00b0', single_plot_export=ExportSettings(format='png', height=540, width=800, scale=1), two_subplots_export=ExportSettings(format='png', height=540, width=800, scale=1), three_subplots_export=ExportSettings(format='png', height=750, width=800, scale=1))\n)\n</code></pre> <p>Create a HTML deviation report containing the absolute trajectory error and relative pose error results. </p> <p>Args:</p> <ul> <li><code>ate_result</code> (Union[ATEResult, list[ATEResult]]):  The absolute trajectory error results (one or multiple) </li> <li><code>rpe_result</code> (Union[RPEResult, list[RPEResult]]):  The relative pose error results (one or multiple) </li> <li><code>report_settings</code> (ReportSettings):  The report settings, defaults to ReportSettings() </li> </ul> <p>Returns:</p> <ul> <li><code>str</code>:  The deviation report </li> </ul>"},{"location":"Documentation/Report/#function-write_report","title":"function <code>write_report</code>","text":"<pre><code>write_report(output_file: str, report_text: str) \u2192 None\n</code></pre> <p>Writes a report to the given output file. </p> <p>Args:</p> <ul> <li><code>output_file</code> (str):  The output file path </li> <li><code>report_text</code> (str):  The report text </li> </ul>"},{"location":"Documentation/Report/#function-show_report","title":"function <code>show_report</code>","text":"<pre><code>show_report(report_text: str, filepath: str = '') \u2192 None\n</code></pre> <p>This function writes a report to a file and opens it in the default web browser. </p> <p>Args:</p> <ul> <li><code>report_text</code> (str):  The report text </li> <li><code>filepath</code> (str, optional):  The file path to save the report. If not given, a random file name will be generated. </li> </ul>"},{"location":"Documentation/Sorting/","title":"Sorting","text":""},{"location":"Documentation/Sorting/#module-trajectopysorting","title":"module <code>trajectopy.sorting</code>","text":"<p>Trajectopy - Trajectory Evaluation in Python </p> <p>Gereon Tombrink, 2025 tombrink@igg.uni-bonn.de </p>"},{"location":"Documentation/Sorting/#function-sort_spatially","title":"function <code>sort_spatially</code>","text":"<pre><code>sort_spatially(\n    xyz_unsorted: numpy.ndarray,\n    settings: trajectopy.settings.SortingSettings = SortingSettings(discard_missing=True, voxel_size=0.05, movement_threshold=0.005, k_nearest=4)\n) \u2192 Tuple[List[int], numpy.ndarray]\n</code></pre> <p>Reconstructs the spatial sorting of the given points </p> <p>Spatially sorts the positions by constructing the minimum-spanning-tree of the positions. Finally, by performing up to 3 breadth-first-searches within the mst, the spatial sorting can be reconstructed </p> <p>This functionality is only useful if the positions describe a closed loop without intersections. </p> <p>This method can also take care of inserting missing points and assures that the direction of travel is kept during sorting. </p> <p>Args:</p> <ul> <li><code>xyz_unsorted</code> (np.ndarray):  unsorted positions </li> <li><code>settings</code> (SortingSettings, optional):  sorting settings. Defaults to SortingSettings(). </li> </ul> <p>Returns:</p> <ul> <li><code>list</code>:  Sort index </li> <li><code>np.ndarray</code>:  Arc lengths along the path </li> </ul>"},{"location":"Documentation/Sorting/#function-detect_direction","title":"function <code>detect_direction</code>","text":"<pre><code>detect_direction(xyz: numpy.ndarray) \u2192 int\n</code></pre> <p>Detects the direction of travel using polar coordinates </p> <p>This only works if the points describe a somewhat circular trajectory which circulates around the origin of the coordinate frame. </p> <p>Args:</p> <ul> <li><code>xyz</code> (np.ndarray):  input positions </li> </ul> <p>Returns:</p> <ul> <li><code>int</code>:  -1 / 1 indicating direction of travel </li> </ul>"},{"location":"Documentation/Sorting/#function-complete_lap_dist","title":"function <code>complete_lap_dist</code>","text":"<pre><code>complete_lap_dist(xyz, dist_th: float = 0.5) \u2192 bool\n</code></pre> <p>Function to determine if lap is complete A lap is considered as complete, if the distance between the starting point and the end point is below a specified distance </p>"},{"location":"Documentation/Sorting/#class-sorting","title":"class <code>Sorting</code>","text":""},{"location":"Documentation/Trajectory/","title":"Trajectory","text":""},{"location":"Documentation/Trajectory/#class-trajectory","title":"class <code>Trajectory</code>","text":"<p>Class representing a trajectory, i.e. position and orientation of a plattform over time </p> <ul> <li>Position-Computations are always done in a local frame </li> <li>Time stamps are always in UTC time </li> <li>Rotations are always defined in a East-North-Up frame </li> </ul> <p>Attributes:</p> <ul> <li><code>pos</code> (PointSet):  Position of the trajectory </li> <li><code>rot</code> (RotationSet):  Orientation of the trajectory </li> <li><code>tstamps</code> (np.ndarray):  Time stamps of the trajectory </li> <li><code>name</code> (str):  Name of the trajectory </li> <li><code>arc_lengths</code> (np.ndarray):  Arc lengths of the trajectory </li> <li><code>speed_3d</code> (np.ndarray):  3D speed of the trajectory </li> <li><code>sorting</code> (Sorting):  Sorting of the trajectory </li> </ul> <p>Methods: </p> <ul> <li><code>__init__</code>:  Initialize trajectory </li> <li><code>__str__</code>:  Returns string describing trajectory </li> <li><code>__repr__</code>:  Returns string representation of trajectory </li> <li><code>__len__</code>:  Return number of poses </li> <li><code>__eq__</code>:  Check if two trajectories are equal </li> <li><code>init_arc_lengths</code>:  Initialize arc lengths </li> <li><code>copy</code>:  Deep copy of itself </li> <li><code>from_file</code>:  Create trajectory from file </li> <li><code>sort_switching_index</code>:  Returns the index that switches the sorting of the trajectory </li> <li><code>sorting_index</code>:  Returns the index that sorts the trajectory </li> <li><code>function_of</code>:  Returns the function of the trajectory </li> <li><code>function_of_unit</code>:  Returns the unit of the function of the trajectory </li> <li><code>function_of_label</code>:  Returns the label of the function of the trajectory </li> <li><code>xyz</code>:  Returns the xyz coordinates of the trajectory </li> <li><code>quat</code>:  Returns the quaternion of the trajectory </li> <li><code>rpy</code>:  Returns the roll, pitch, yaw of the trajectory </li> <li><code>to_dataframe</code>:  Returns a pandas dataframe containing tstamps, xyz, quat and speed_3d of the trajectory </li> <li><code>to_file</code>:  Writes trajectory to ascii file </li> <li><code>from_numpy</code>:  Initialize trajectory using numpy arrays </li> <li><code>se3</code>:  Returns SE3 pose list </li> <li><code>se3.setter</code>:  Sets position and rotation from se3 list </li> <li><code>data_rate</code>:  Returns data rate </li> <li><code>total_length</code>:  Return the total trajectory arc_length </li> <li><code>speed_3d</code>:  Returns computed speeds or custom speeds </li> <li><code>speed_3d.setter</code>:  Sets custom speeds </li> <li><code>speed</code>:  Returns trajectory speeds calculated using consecutive point distances </li> <li><code>crop</code>:  Crops trajectory to timespan defined by t_start and t_end </li> <li><code>interpolate</code>:  Interpolates a trajectory to specified timestamps </li> <li><code>_interpolate_rotations</code>:  Function for rotation interpolation of a trajectory </li> <li><code>_interpolate_positions</code>:  Function for position interpolation of a trajectory </li> <li><code>match_timestamps</code>:  Truncates trajectory to only those poses where the timestamps exactly match \"tstamps\" </li> <li><code>intersect</code>:  Intersects trajectory with a given timestamp vector </li> <li><code>apply_index</code>:  Applies index to the trajectory </li> <li><code>apply_transformation</code>:  Applies transformation to trajectory </li> </ul>"},{"location":"Documentation/Trajectory/#method-trajectory__init__","title":"method <code>Trajectory.__init__</code>","text":"<pre><code>__init__(\n    pos: trajectopy.pointset.PointSet,\n    rot: Optional[trajectopy.rotationset.RotationSet] = None,\n    tstamps: Optional[numpy.ndarray] = None,\n    name: str = '',\n    arc_lengths: Optional[numpy.ndarray] = None,\n    speed_3d: Optional[numpy.ndarray] = None,\n    sorting: trajectopy.sorting.Sorting = &lt;Sorting.TIME: 'time'&gt;\n) \u2192 None\n</code></pre>"},{"location":"Documentation/Trajectory/#property-trajectorydata_rate","title":"property Trajectory.data_rate","text":"<p>Returns data rate </p>"},{"location":"Documentation/Trajectory/#property-trajectorydatetimes","title":"property Trajectory.datetimes","text":"<p>Returns the datetime of the trajectory </p>"},{"location":"Documentation/Trajectory/#property-trajectoryfunction_of","title":"property Trajectory.function_of","text":"<p>Returns the function of the trajectory </p>"},{"location":"Documentation/Trajectory/#property-trajectoryfunction_of_label","title":"property Trajectory.function_of_label","text":"<p>Returns the label of the function of the trajectory </p>"},{"location":"Documentation/Trajectory/#property-trajectoryfunction_of_unit","title":"property Trajectory.function_of_unit","text":"<p>Returns the unit of the function of the trajectory </p>"},{"location":"Documentation/Trajectory/#property-trajectoryhas_orientation","title":"property Trajectory.has_orientation","text":"<p>Returns True if orientation is available </p>"},{"location":"Documentation/Trajectory/#property-trajectoryis_unix_time","title":"property Trajectory.is_unix_time","text":"<p>Returns True if time is in unix format </p>"},{"location":"Documentation/Trajectory/#property-trajectoryquat","title":"property Trajectory.quat","text":"<p>Returns the quaternion of the trajectory </p> <p>In contrast to the rot.as_quat() attribute, this method reflects the current sorting of the trajectory. </p>"},{"location":"Documentation/Trajectory/#property-trajectoryrpy","title":"property Trajectory.rpy","text":"<p>Returns the roll, pitch, yaw of the trajectory </p> <p>In contrast to the rot.as_euler(seq=\"xyz\") attribute, this method reflects the current sorting of the trajectory. </p>"},{"location":"Documentation/Trajectory/#property-trajectoryse3","title":"property Trajectory.se3","text":"<p>Returns SE3 pose list </p>"},{"location":"Documentation/Trajectory/#property-trajectorysort_switching_index","title":"property Trajectory.sort_switching_index","text":"<p>Returns the index that switches the sorting of the trajectory </p>"},{"location":"Documentation/Trajectory/#property-trajectorysorting_index","title":"property Trajectory.sorting_index","text":"<p>Returns the index that sorts the trajectory </p>"},{"location":"Documentation/Trajectory/#property-trajectoryspeed","title":"property Trajectory.speed","text":"<p>Returns trajectory speeds calculated using consecutive point distances </p>"},{"location":"Documentation/Trajectory/#property-trajectoryspeed_3d","title":"property Trajectory.speed_3d","text":"<p>Returns computed speeds or custom speeds </p>"},{"location":"Documentation/Trajectory/#property-trajectorytotal_length","title":"property Trajectory.total_length","text":"<p>Return the total trajectory arc_length. </p>"},{"location":"Documentation/Trajectory/#property-trajectoryxyz","title":"property Trajectory.xyz","text":"<p>Returns the xyz coordinates of the trajectory </p> <p>In contrast to the pos.xyz attribute, this method reflects the current sorting of the trajectory. </p>"},{"location":"Documentation/Trajectory/#method-trajectoryadopt_first_orientation","title":"method <code>Trajectory.adopt_first_orientation</code>","text":"<pre><code>adopt_first_orientation(\n    trajectory: 'Trajectory',\n    inplace: bool = True\n) \u2192 Trajectory\n</code></pre> <p>Transform trajectory so that the first orientation is identical in both </p> <p>Args:</p> <ul> <li><code>trajectory</code> (Trajectory):  Target Trajectory </li> <li><code>inplace</code> (bool, optional):  Perform in-place. Defaults to True. </li> </ul> <p>Returns:</p> <ul> <li><code>Trajectory</code>:  Transformed trajectory </li> </ul>"},{"location":"Documentation/Trajectory/#method-trajectoryadopt_first_pose","title":"method <code>Trajectory.adopt_first_pose</code>","text":"<pre><code>adopt_first_pose(trajectory: 'Trajectory', inplace: bool = True) \u2192 Trajectory\n</code></pre> <p>Transform trajectory so that the first pose is identical in both </p> <p>Args:</p> <ul> <li><code>trajectory</code> (Trajectory):  Target Trajectory </li> <li><code>inplace</code> (bool, optional):  Perform in-place. Defaults to True. </li> </ul> <p>Returns:</p> <ul> <li><code>Trajectory</code>:  Transformed trajectory </li> </ul>"},{"location":"Documentation/Trajectory/#method-trajectoryadopt_first_position","title":"method <code>Trajectory.adopt_first_position</code>","text":"<pre><code>adopt_first_position(\n    trajectory: 'Trajectory',\n    inplace: bool = True\n) \u2192 Trajectory\n</code></pre> <p>Transform trajectory so that the first position is identical in both </p> <p>Args:</p> <ul> <li><code>trajectory</code> (Trajectory):  Target Trajectory </li> <li><code>inplace</code> (bool, optional):  Perform in-place. Defaults to True. </li> </ul> <p>Returns:</p> <ul> <li><code>Trajectory</code>:  Transformed trajectory </li> </ul>"},{"location":"Documentation/Trajectory/#method-trajectoryapply_alignment","title":"method <code>Trajectory.apply_alignment</code>","text":"<pre><code>apply_alignment(\n    alignment_result: trajectopy.core.alignment.result.AlignmentResult,\n    inplace: bool = True\n) \u2192 Trajectory\n</code></pre> <p>Transforms trajectory using alignment parameters. </p> <p>After computing the alignment parameters needed to align two trajectories, they can be applied to arbitrary trajectories. </p> <p>Args:   alignment_result (AlignmentResult)   - <code>inplace</code> (bool, optional):  Perform in-place. Defaults to True. </p> <p>Returns:</p> <ul> <li><code>Trajectory</code>:  Aligned trajectory </li> </ul>"},{"location":"Documentation/Trajectory/#method-trajectoryapply_index","title":"method <code>Trajectory.apply_index</code>","text":"<pre><code>apply_index(\n    index: Union[list, numpy.ndarray],\n    inplace: bool = True\n) \u2192 Trajectory\n</code></pre> <p>Applies index to the trajectory </p> <p>This will be done either in-place or using a new instance of a trajectory. The index can be used to filter and / or sort the components of the trajectory. </p> <p>Those components are:  - timestamps (tstamps)  - positions (xyz)  - rotations (rot)  - arc lengths (arc_lengths)  - sorting index (_sort_index) </p> <p>Args:</p> <ul> <li><code>index</code> (Union[list, np.ndarray]):  index that should be applied </li> <li><code>inplace</code> (bool, optional):  Perform in-place. Defaults to True. </li> </ul> <p>Returns:</p> <ul> <li><code>Trajectory</code>:  Trajectory with index applied. </li> </ul>"},{"location":"Documentation/Trajectory/#method-trajectoryapply_transformation","title":"method <code>Trajectory.apply_transformation</code>","text":"<pre><code>apply_transformation(\n    transformation: numpy.ndarray,\n    inplace: bool = True\n) \u2192 Trajectory\n</code></pre> <p>Applies transformation to trajectory </p> <p>Args:</p> <ul> <li><code>transformation</code> (np.ndarray):  4x4 Transformation matrix </li> <li><code>inplace</code> (bool, optional):  Perform in-place. Defaults to True. </li> </ul> <p>Returns:</p> <ul> <li><code>Trajectory</code>:  Transformed trajectory </li> </ul>"},{"location":"Documentation/Trajectory/#method-trajectoryapproximate","title":"method <code>Trajectory.approximate</code>","text":"<pre><code>approximate(\n    approximation_settings: trajectopy.settings.ApproximationSettings = ApproximationSettings(position_interval_size=0.15, position_min_observations=25, rotation_window_size=0.15),\n    inplace: bool = True\n) \u2192 Trajectory\n</code></pre> <p>Approximates the trajectory using piecewise cubic polynomial. </p> <p>Args:</p> <ul> <li><code>approximation_settings</code> (ApproximationSettings):  Approximation settings. </li> </ul> <p>Returns:</p> <ul> <li><code>Trajectory</code>:  Approximated trajectory. </li> </ul>"},{"location":"Documentation/Trajectory/#method-trajectorycopy","title":"method <code>Trajectory.copy</code>","text":"<pre><code>copy() \u2192 Trajectory\n</code></pre> <p>Deep copy of itself </p>"},{"location":"Documentation/Trajectory/#method-trajectorycrop","title":"method <code>Trajectory.crop</code>","text":"<pre><code>crop(\n    t_start: float,\n    t_end: float,\n    inverse: bool = False,\n    inplace: bool = True\n) \u2192 Trajectory\n</code></pre> <p>Crops trajectory to timespan defined by t_start and t_end </p> <p>Args:</p> <ul> <li><code>t_start</code> (float):  Start timestamp of desired time span </li> <li><code>t_end</code> (float):  End timestamp of desired time span </li> <li><code>inverse</code> (bool, optional):  If true, 'crop' turns  into 'cut', i.e. everthing  outside of t_start and t_end  will be removed.  Defaults to False. </li> <li><code>inplace</code> (bool, optional):  Perform crop in-place.  Defaults to True. </li> </ul> <p>Returns:</p> <ul> <li><code>Trajectory</code>:  Cropped trajectory </li> </ul>"},{"location":"Documentation/Trajectory/#method-trajectorydivide_into_laps","title":"method <code>Trajectory.divide_into_laps</code>","text":"<pre><code>divide_into_laps(\n    sorting_settings: trajectopy.settings.SortingSettings = SortingSettings(discard_missing=True, voxel_size=0.05, movement_threshold=0.005, k_nearest=4),\n    return_lap_indices: bool = False\n) \u2192 Union[List[ForwardRef('Trajectory')], Tuple[List[ForwardRef('Trajectory')], numpy.ndarray]]\n</code></pre> <p>Divides the trajectory into laps. </p> <p>Args:</p> <ul> <li><code>sorting_settings</code> (SortingSettings):  Sorting settings. </li> </ul> <p>Returns:</p> <ul> <li><code>List[Trajectory]</code>:  List of trajectories, each representing a lap. </li> </ul>"},{"location":"Documentation/Trajectory/#classmethod-trajectoryfrom_file","title":"classmethod <code>Trajectory.from_file</code>","text":"<pre><code>from_file(filename: str, io_stream: bool = False) \u2192 Trajectory\n</code></pre> <p>Create trajectory from file </p> <p>The file must be a csv file containing columns for at least the timestamp, x, y and z coordinates of the trajectory. Those fields must be named \"t\", \"px\", \"py\" and \"pz\" in the header using the #fields tag. However, by default a trajectory with \"t,px,py,pz,qx,qy,qz,qw\" fields is assumed. Additional fields include the arc length, specified by \"l\", and the speed, specified by \"vx\", \"vy\" and \"vz\". The delimiter can be specified using the #delimiter tag. The default delimiter is a comma. </p> <p>Args:</p> <ul> <li><code>filename</code> (str):  path to file </li> <li><code>io_stream</code> (bool, optional):  If true, the file is read from a stream. </li> </ul> <p>Returns:</p> <ul> <li><code>Trajectory</code>:  trajectory object </li> </ul>"},{"location":"Documentation/Trajectory/#classmethod-trajectoryfrom_numpy","title":"classmethod <code>Trajectory.from_numpy</code>","text":"<pre><code>from_numpy(\n    xyz: numpy.ndarray,\n    quat: numpy.ndarray,\n    tstamps: numpy.ndarray,\n    epsg: int = 0\n) \u2192 Trajectory\n</code></pre> <p>Initialize trajectory using numpy arrays </p>"},{"location":"Documentation/Trajectory/#method-trajectoryinit_arc_lengths","title":"method <code>Trajectory.init_arc_lengths</code>","text":"<pre><code>init_arc_lengths()\n</code></pre>"},{"location":"Documentation/Trajectory/#method-trajectoryinterpolate","title":"method <code>Trajectory.interpolate</code>","text":"<pre><code>interpolate(\n    tstamps: Union[list, numpy.ndarray],\n    inplace: bool = True\n) \u2192 Trajectory\n</code></pre> <p>Interpolates a trajectory to specified timestamps </p> <p>This method removes timestamps from tstamps if they lie outside of the timestamp range of the trajectory (self). Since providing values for those timestamps would require an extrapolation and not an interpolation, this behaviour is consistent with the definition of this method. </p> <p>Args:</p> <ul> <li><code>tstamps</code> (list):  Interpolation timestamps </li> <li><code>inplace</code> (bool, optional):  Perform in-place interpolation.  Defaults to True. </li> </ul> <p>Returns:</p> <ul> <li><code>Trajectory</code>:  Interpolated trajectory </li> </ul>"},{"location":"Documentation/Trajectory/#method-trajectoryintersect","title":"method <code>Trajectory.intersect</code>","text":"<pre><code>intersect(\n    tstamps: numpy.ndarray,\n    max_gap_size: float = 10.0,\n    inplace: bool = True\n) \u2192 Trajectory\n</code></pre> <p>Intersects trajectory with a given timestamp vector </p> <p>After intersection, the trajectory covers the same timespan as 'tstamps'. Further, gaps larger than 'max_gap_size' are removed. If two consecutive timespans in tstamps have a difference of more than 'max_gap_size' seconds, they are considered as the limits of a gap. All timestamps of the trajectory that lie within this gap will be removed. </p> <p>Args:</p> <ul> <li><code>tstamps</code> (np.ndarray):  Intersection timespans </li> <li><code>max_gap_size</code> (float, optional):  Maximum allowed gap between timespans.  If Defaults to 10.0. </li> <li><code>inplace</code> (bool, optional):  Perform intersection in-place.  Defaults to True. </li> </ul> <p>Raises:</p> <ul> <li><code>ValueError</code>:  If timespans do not overlap. </li> </ul> <p>Returns:</p> <ul> <li><code>Trajectory</code>:  Intersected trajectory </li> </ul>"},{"location":"Documentation/Trajectory/#method-trajectorymatch_timestamps","title":"method <code>Trajectory.match_timestamps</code>","text":"<pre><code>match_timestamps(tstamps: numpy.ndarray, inplace: bool = True) \u2192 Trajectory\n</code></pre> <p>Truncates trajectory to only those poses where the timestamps exactly match \"tstamps\" </p> <p>Args:</p> <ul> <li><code>tstamps</code> (np.ndarray):  Input timestamps </li> <li><code>inplace</code> (bool, optional):  Perform matching in-place. Defaults to True. </li> </ul> <p>Returns:</p> <ul> <li><code>Trajectory</code>:  Trajectory with matched timestamps </li> </ul>"},{"location":"Documentation/Trajectory/#method-trajectorysort_spatially","title":"method <code>Trajectory.sort_spatially</code>","text":"<pre><code>sort_spatially(\n    sorting_settings: trajectopy.settings.SortingSettings = SortingSettings(discard_missing=True, voxel_size=0.05, movement_threshold=0.005, k_nearest=4),\n    inplace: bool = True\n) \u2192 Trajectory\n</code></pre> <p>Sorts the trajectory spatially. </p> <p>Args:</p> <ul> <li><code>sorting_settings</code> (SortingSettings):  Sorting settings. </li> <li><code>inplace</code> (bool, optional):  Whether to sort the trajectory in-place. Defaults to True. </li> </ul> <p>Returns:</p> <ul> <li><code>Trajectory</code>:  Sorted trajectory. </li> </ul>"},{"location":"Documentation/Trajectory/#method-trajectoryto_dataframe","title":"method <code>Trajectory.to_dataframe</code>","text":"<pre><code>to_dataframe(sort_by: str = '') \u2192 DataFrame\n</code></pre> <p>Returns a pandas dataframe containing tstamps, xyz, quat and speed_3d of the trajectory. </p> <p>The dataframe is sorted by the current sorting attribute (time or arc_length). </p> <p>Args:</p> <ul> <li><code>sort_by</code> (str, optional):  Column to sort by. This  overrides the current sort_by  attribute. </li> </ul> <p>Returns:</p> <ul> <li><code>pd.DataFrame</code>:  Trajectory as dataframe </li> </ul>"},{"location":"Documentation/Trajectory/#method-trajectoryto_file","title":"method <code>Trajectory.to_file</code>","text":"<pre><code>to_file(filename: str, mode: str = 'w') \u2192 None\n</code></pre> <p>Writes trajectory to ascii file </p> <p>Args:</p> <ul> <li><code>filename</code> (str):  Output filename </li> </ul>"},{"location":"Documentation/Trajectory/#method-trajectoryto_kml","title":"method <code>Trajectory.to_kml</code>","text":"<pre><code>to_kml(filename: str, precision: float = 1e-06) \u2192 str\n</code></pre> <p>Create a KML file from a trajectory. </p> <p>Args:</p> <ul> <li><code>trajectory</code> (Trajectory):  Trajectory to be exported. </li> <li><code>filename</code> (str):  Filename of the KML file. </li> <li><code>precision</code> (float, optional):  Precision of the exported positions in degree. Defaults to 1e-6. </li> </ul>"},{"location":"Documentation/Trajectory/#method-trajectoryto_string","title":"method <code>Trajectory.to_string</code>","text":"<pre><code>to_string() \u2192 str\n</code></pre> <p>Writes trajectory to a string instead of a file. </p>"}]}