{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"Trajectopy - Trajectory Evaluation in Python Trajectopy is a Python package with an optional graphical user interface for empirical trajectory evaluation."},{"location":"#key-features","title":"Key Features","text":"<p>Trajectopy offers a range of features, including:</p> <ul> <li>Interactive GUI: A user-friendly interface that enables seamless interaction with your trajectory data, making it easy to visualize, align, and compare trajectories.</li> <li>Alignment: An advanced trajectory alignment algorithm that can be tailored to the specific application and supports a similarity transformation, a leverarm and a time shift estimation.</li> <li>Comparison: Absolute and relative trajectory comparison metrics (ATE and RPE) that can be computed using various pose-matching methods.</li> <li>Data Import/Export: Support for importing and exporting data, ensuring compatibility with your existing workflows.</li> <li>Customizable Visualization: Powered by Plotly or Matplotlib, trajectopy offers a range of interactive plots that can be customized to your needs. (Demo)</li> </ul>"},{"location":"#installation-with-gui","title":"Installation (with GUI)","text":"<p>It is recommended to install trajectopy with the GUI using the following command:</p> <pre><code>pip install \"trajectopy[gui]\"\n</code></pre>"},{"location":"#installation-without-gui","title":"Installation (without GUI)","text":"<p>To install trajectopy without the GUI, use the following command:</p> <pre><code>pip install trajectopy\n</code></pre> <p>Now you can use trajectopy as a Python package in your scripts.</p>"},{"location":"#python-package-quick-start","title":"Python Package Quick Start","text":"<p>Here is a minimal example to load two trajectories, align them, and calculate the Absolute Trajectory Error (ATE).</p> <pre><code>import trajectopy as tpy\n\n# 1. Load trajectories\ntraj_ref = tpy.Trajectory.from_file(\"./example_data/KITTI_gt.traj\")\ntraj_est = tpy.Trajectory.from_file(\"./example_data/KITTI_ORB.traj\")\n\n# 2. Evaluate (ATE already includes alignment)\nate_result = tpy.ate(other=traj_ref, trajectory=traj_est)\n\n# 3. Print results\nprint(f\"Position ATE: {ate_result.pos_ate:.3f} m\")\n</code></pre> <p>For more detailed usage, see the User Guide.</p>"},{"location":"#gui-application","title":"GUI Application","text":"<p>Trajectopy also includes a graphical user interface. To launch it, run:</p> <pre><code>trajectopy\n</code></pre>"},{"location":"#command-line-options-gui-version-only","title":"Command Line Options (GUI version only)","text":"<pre><code>trajectopy --help\n</code></pre> <p><pre><code>usage: trajectopy [-h] [--version] [--single-thread] [--report-settings REPORT_SETTINGS] [--mpl-settings MPL_SETTINGS] [--report-path REPORT_PATH] [--mapbox-token MAPBOX_TOKEN]\n\nTrajectopy - Trajectory Evaluation in Python\n\noptions:\n  -h, --help            show this help message and exit\n  --version, -v\n  --single-thread       Disable multithreading\n  --report-settings REPORT_SETTINGS\n                        Path to JSON report settings file that will override the default settings.\n  --mpl-settings MPL_SETTINGS\n                        Path to JSON matplotlib plot settings file that will override the default settings.\n  --report-path, -o REPORT_PATH\n                        Output directory for all reports of one session. If not specified, a temporary directory will be used.\n  --mapbox-token MAPBOX_TOKEN\n                        Mapbox token to use Mapbox map styles in trajectory plots.\n</code></pre> Trajectopy allows users to customize the report output path and settings. By default, reports are stored in a temporary directory that will be deleted when the program exits. If you want to keep the reports, you can specify a custom output path using the <code>--report-path</code> option. The report settings can be customized using a JSON file. The report settings file must include all available settings. You can find a sample file here. In addition, you can customize the Matplotlib plot settings using a JSON file with the <code>--mpl-settings</code> option. A sample file can be found here.</p> <p>Example: <pre><code>trajectopy --report-settings ./report_settings.json -o ./persistent_report_directory\n</code></pre></p>"},{"location":"#citation","title":"Citation","text":"<p>If you use Trajectopy for academic work, please cite our paper:</p> <pre><code>@article{Tombrink2024,\n  title = {Spatio-temporal trajectory alignment for trajectory evaluation},\n  author = {Gereon Tombrink and Ansgar Dreier and Lasse Klingbeil and Heiner Kuhlmann},\n  journal = {Journal of Applied Geodesy},\n  year = {2024},\n  doi = {10.1515/jag-2024-0040},\n  url = {https://doi.org/10.1515/jag-2024-0040},\n  codeurl = {https://github.com/gereon-t/trajectopy}\n}\n</code></pre>"},{"location":"#license","title":"License","text":"<p>Trajectopy is released under the GNU General Public License v3.0.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please see our GitHub repository for details.</p> <p>Developed at the Institute of Geodesy and Geoinformation, University of Bonn</p>"},{"location":"file_formats/","title":"File Formats","text":"<p>Comprehensive guide to trajectory file formats supported by Trajectopy.</p>"},{"location":"file_formats/#overview","title":"Overview","text":"<p>Trajectopy supports:</p> <ul> <li>ASCII/CSV files - Primary format (<code>.traj</code>, <code>.txt</code>, <code>.csv</code>)</li> <li>ROS bag files - ROS1 and ROS2 (<code>.bag</code>)</li> </ul>"},{"location":"file_formats/#ascii-file-format","title":"ASCII File Format","text":""},{"location":"file_formats/#default-structure","title":"Default Structure","text":"<pre><code>time, px, py, pz, qx, qy, qz, qw\n</code></pre> <p>Example: <pre><code>1000.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0\n1000.1,0.1,0.0,0.0,0.0,0.0,0.0,1.0\n1000.2,0.2,0.0,0.0,0.0,0.0,0.0,1.0\n</code></pre></p>"},{"location":"file_formats/#header-configuration","title":"Header Configuration","text":"<p>Headers start with <code>#</code> and configure how data is interpreted:</p> <pre><code>#name MyTrajectory\n#epsg 32632\n#fields t,px,py,pz,qx,qy,qz,qw\n#delimiter ,\n1000.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0\n</code></pre>"},{"location":"file_formats/#supported-header-fields","title":"Supported Header Fields","text":"Header Description Default Options <code>#name</code> Trajectory display name Filename Any string <code>#epsg</code> EPSG coordinate system code 0 Any valid EPSG code <code>#fields</code> Column definitions <code>t,px,py,pz,qx,qy,qz,qw</code> See field table <code>#delimiter</code> Column separator <code>,</code> Any character <code>#nframe</code> Navigation frame <code>enu</code> <code>enu</code>, <code>ned</code> <code>#rot_unit</code> Rotation unit <code>rad</code> <code>rad</code>, <code>deg</code> <code>#time_format</code> Time format <code>unix</code> <code>unix</code>, <code>datetime</code>, <code>gps_sow</code> <code>#time_offset</code> Time offset (seconds) <code>0.0</code> Any float <code>#datetime_format</code> Datetime string format <code>%Y-%m-%d %H:%M:%S.%f</code> strftime format <code>#datetime_timezone</code> Timezone <code>UTC</code> TZ name or <code>GPS</code> <code>#gps_week</code> GPS week (for gps_sow) <code>0</code> Integer <code>#sorting</code> Data sorting <code>time</code> <code>time</code>, <code>arc_length</code>"},{"location":"file_formats/#field-names","title":"Field Names","text":"Field Description Type Can repeat? <code>t</code> Time/timestamp str / float Yes <code>l</code> Arc length float No <code>px</code> Position X / Latitude float No <code>py</code> Position Y / Longitude float No <code>pz</code> Position Z / Altitude float No <code>qx</code> Quaternion X float No <code>qy</code> Quaternion Y float No <code>qz</code> Quaternion Z float No <code>qw</code> Quaternion W float No <code>ex</code> Euler angle X (roll) float No <code>ey</code> Euler angle Y (pitch) float No <code>ez</code> Euler angle Z (yaw) float No <code>vx</code> Velocity X float No <code>vy</code> Velocity Y float No <code>vz</code> Velocity Z float No"},{"location":"file_formats/#format-examples","title":"Format Examples","text":""},{"location":"file_formats/#position-only-trajectory","title":"Position-Only Trajectory","text":"<pre><code>#name PositionOnly\n#fields t,px,py,pz\n1000.0,0.0,0.0,0.0\n1000.1,0.1,0.0,0.0\n1000.2,0.2,0.0,0.0\n</code></pre>"},{"location":"file_formats/#euler-angles-degrees","title":"Euler Angles (Degrees)","text":"<pre><code>#name EulerTrajectory\n#fields t,px,py,pz,ex,ey,ez\n#rot_unit deg\n1000.0,0.0,0.0,0.0,0.0,0.0,0.0\n1000.1,0.1,0.0,0.0,0.0,0.0,5.0\n</code></pre>"},{"location":"file_formats/#space-separated","title":"Space-Separated","text":"<pre><code>#name SpaceSeparated\n#fields t,px,py,pz,qx,qy,qz,qw\n#delimiter  \n1000.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0\n1000.1 0.1 0.0 0.0 0.0 0.0 0.0 1.0\n</code></pre>"},{"location":"file_formats/#geographic-coordinates-latlon","title":"Geographic Coordinates (Lat/Lon)","text":"<pre><code>#name GPS\n#epsg 4326\n#fields t,px,py,pz\n1000.0,50.7374,7.0982,120.5\n1000.1,50.7375,7.0983,121.2\n</code></pre>"},{"location":"file_formats/#datetime-timestamps","title":"Datetime Timestamps","text":"<pre><code>#name DatetimeTrajectory\n#fields t,px,py,pz,qx,qy,qz,qw\n#time_format datetime\n#datetime_format %Y-%m-%d %H:%M:%S.%f\n#datetime_timezone UTC\n2024-01-01 12:00:00.000,0.0,0.0,0.0,0.0,0.0,0.0,1.0\n2024-01-01 12:00:00.100,0.1,0.0,0.0,0.0,0.0,0.0,1.0\n</code></pre>"},{"location":"file_formats/#gps-time-sow","title":"GPS Time (SOW)","text":"<pre><code>#name GPSTime\n#fields t,px,py,pz,qx,qy,qz,qw\n#time_format gps_sow\n#gps_week 2250\n345600.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0\n345600.1,0.1,0.0,0.0,0.0,0.0,0.0,1.0\n</code></pre>"},{"location":"file_formats/#creating-custom-trajectories","title":"Creating Custom Trajectories","text":""},{"location":"file_formats/#from-numpy-arrays","title":"From NumPy Arrays","text":"<pre><code>import trajectopy as tpy\nimport numpy as np\n\n# Create timestamps and positions\ntimestamps = np.arange(0, 10, 0.1)\npositions = np.column_stack(\n    [\n        timestamps,  # x increases with time\n        np.sin(timestamps),  # y is sinusoidal\n        np.zeros_like(timestamps),  # z is zero\n    ]\n)\n\n# Create rotations (identity quaternions)\nquaternions = np.tile([0, 0, 0, 1], (len(timestamps), 1))\n\n# Create trajectory\ntraj = tpy.Trajectory(\n    timestamps=timestamps,\n    xyz=positions,\n    quat=quaternions,\n    name=\"CustomTrajectory\",\n)\n\n# Save\ntraj.to_file(\"custom.traj\")\n</code></pre>"},{"location":"file_formats/#see-also","title":"See Also","text":"<ul> <li>User Guide - GUI file import</li> <li>API Reference - Trajectory class details</li> </ul>"},{"location":"settings/","title":"Settings","text":""},{"location":"settings/#processing-settings","title":"Processing Settings","text":"<p>The processing settings allow you to configure various processing steps that can be applied to trajectories before or during analysis. The available processing options are summarized in the table below:</p> Setting Description <code>alignment</code> Settings for trajectory alignment (Similarity transformation (helmert), time shift, lever arm, etc.) <code>matching</code> Settings for matching poses between two trajectories <code>relative_comparison</code> Settings for relative trajectory comparison (RPE) <code>approximation</code> Settings for trajectory approximation and smoothing <code>sorting</code> Settings for spatially sorting trajectories"},{"location":"settings/#alignment-settings","title":"Alignment Settings","text":""},{"location":"settings/#preprocessing-settings","title":"Preprocessing Settings","text":"<ul> <li><code>min_speed</code> (float): Only poses with a speed above this threshold are considered for alignment (meters/second).</li> <li><code>time_start</code> (float): Only poses with a timestamp above this threshold are considered for alignment. The timestamp is given in seconds and is relative to the first common timestamp of both matched trajectories.</li> <li><code>time_end</code> (float): Only poses with a timestamp below this threshold are considered for alignment. The timestamp is given in seconds and is relative to the first common timestamp of both matched trajectories.</li> </ul>"},{"location":"settings/#estimation-settings","title":"Estimation Settings","text":"<ul> <li><code>translation_x</code> (boolean): Enable or disable x-translation of the similarity transformation.</li> <li><code>translation_y</code> (boolean): Enable or disable y-translation of the similarity transformation.</li> <li><code>translation_z</code> (boolean): Enable or disable z-translation of the similarity transformation.</li> <li><code>rotation_x</code> (boolean): Enable or disable rotation around the X-axis of the similarity transformation.</li> <li><code>rotation_y</code> (boolean): Enable or disable rotation around the Y-axis of the similarity transformation.</li> <li><code>rotation_z</code> (boolean): Enable or disable rotation around the Z-axis of the similarity transformation.</li> <li><code>scale</code> (boolean): Enable or disable scaling of the similarity transformation.</li> <li><code>time_shift</code> (boolean): Enable or disable the estimation of time shift.</li> <li><code>leverarm_x</code> (boolean): Enable or disable estimation of lever arm in the X-axis.</li> <li><code>leverarm_y</code> (boolean): Enable or disable estimation of lever arm in the Y-axis.</li> <li><code>leverarm_z</code> (boolean): Enable or disable estimation of lever arm in the Z-axis.</li> <li><code>sensor_rotation</code> (boolean): Enable or disable computation of sensor rotation offsets. Independent of the least squares adjustment, constant offsets between the roll, pitch and yaw angles of both trajectories are computed.</li> </ul>"},{"location":"settings/#stochastics-settings","title":"Stochastics Settings","text":"<ul> <li><code>std_xy_from</code> (float): Standard deviation of XY source position components in meters.</li> <li><code>std_z_from</code> (float): Standard deviation of Z source position component in meters.</li> <li><code>std_xy_to</code> (float): Standard deviation of XY target position components in meters.</li> <li><code>std_z_to</code> (float): Standard deviation of Z target position component in meters.</li> <li><code>std_roll_pitch</code> (float): Standard deviation of roll and pitch in radians.</li> <li><code>std_yaw</code> (float): Standard deviation of yaw in radians.</li> <li><code>std_speed_to</code> (float): Standard deviation of platform speed in (meters per second).</li> <li><code>error_probability</code> (float): Probability of error used for stochastic testing.</li> <li><code>variance_estimation</code> (boolean): Enable or disable the estimation of the variance factor for a-posteriori variance computation.</li> </ul>"},{"location":"settings/#threshold-settings","title":"Threshold Settings","text":"<p>Usually, these settings can be left at their default values.</p> <ul> <li><code>metric_threshold</code> (float): Iteration threshold for the least squares adjustment regarding the metric parameters.</li> <li><code>time_threshold</code> (float): Iteration threshold in seconds for the least squares adjustment regarding the time shift parameter.</li> </ul>"},{"location":"settings/#matching-settings","title":"Matching Settings","text":"<ul> <li><code>method</code> (<code>MatchingMethod</code>): The method used for trajectory matching. Choices: <code>MatchingMethod.NEAREST_SPATIAL</code>, <code>MatchingMethod.NEAREST_TEMPORAL</code>, <code>MatchingMethod.INTERPOLATION</code>, <code>MatchingMethod.NEAREST_SPATIAL_INTERPOLATED</code>. The methods are described below.</li> <li><code>max_time_diff</code> (float): Maximum allowed time difference in seconds when matching two trajectories using their timestamps.</li> <li><code>max_distance</code> (float): Maximum allowed distance in meters between matched positions during spatial matching.</li> <li><code>max_gap_size</code> (float): Maximum allowed gap size in seconds within a trajectory during matching.</li> <li><code>k_nearest</code> (integer): The number of nearest neighbors to consider during spatial interpolation matching.</li> </ul>"},{"location":"settings/#matching-methods","title":"Matching Methods","text":""},{"location":"settings/#nearest-spatial","title":"Nearest Spatial","text":"<p>This method matches two trajectories by finding the nearest pose in the target trajectory for each pose in the source trajectory. The distance between two poses is computed using the Euclidean distance between their positions.</p>"},{"location":"settings/#nearest-temporal","title":"Nearest Temporal","text":"<p>This method matches two trajectories using their timestamps by finding the nearest timestamp in the target trajectory for each timestamp in the source trajectory.</p>"},{"location":"settings/#interpolation","title":"Interpolation","text":"<p>This method matches two trajectories by interpolating the timestamps of one trajectory to the timestamps of the other trajectory. The interpolation is linear for both positions and rotations (SLERP).</p>"},{"location":"settings/#nearest-spatial-interpolated","title":"Nearest Spatial Interpolated","text":"<p>This method matches both trajectories spatially by requesting the nearest k positions from the reference trajectory for each pose in the test trajectory. Then, an interpolation is performed using a 3d line fit of the k nearest positions. After this operation, both trajectories will have the length of the test trajectory. The matched rotations are computed by averaging the quaternions of the k nearest neighbors using the chordal L2 mean.</p>"},{"location":"settings/#relative-comparison-settings","title":"Relative Comparison Settings","text":"<ul> <li> <p><code>pair_min_distance</code> (float): Minimum pose pair distance to be considered during RPE (Relative Pose Error) computation.</p> </li> <li> <p><code>pair_max_distance</code> (float): Maximum pose pair distance to be considered during RPE computation.</p> </li> <li> <p><code>pair_distance_step</code> (float): Step in which the pose pair distance increases.</p> </li> <li> <p><code>pair_distance_unit</code> (<code>Unit</code>): Unit of the pose pair distance. Choices: <code>Unit.METER</code>, <code>Unit.SECOND</code>.</p> </li> <li> <p><code>use_all_pose_pairs</code> (boolean): If enabled, overlapping pose pairs will be used for relative metrics calculation.</p> </li> </ul>"},{"location":"settings/#rpe-background","title":"RPE Background","text":"<p>For this metric, relative pose-pair differences are compared. The distance between two poses can be specified by the user and can be either time- or distance-based. The comparison involves finding pose pairs separated by a specific distance or time interval, computing the relative translation and rotation between the reference and estimated pose pairs, and calculating the translational and rotational difference normalized by the distance or time that separated the poses.</p> <ol> <li>Find pose pair separated by e.g. 100 m in reference trajectory. This pair represents the start and end poses of a sequence of size \\(N\\).</li> <li>Find the corresponding pose pair in estimated trajectory</li> <li> <p>Compute relative translation and rotation between the reference pose pair</p> <p>\\(\\Delta_{P~ref} = P_{ref, 1}^{-1} \\cdot P_{ref, N}\\)</p> </li> <li> <p>Compute relative translation and rotation between the estimated pose pair</p> <p>\\(\\Delta_{P~est} = P_{est, 1}^{-1} \\cdot P_{est, N}\\)</p> </li> <li> <p>Compute transformation between 3) and 4)</p> </li> <li> <p>Compute translation and rotation error from 5)</p> </li> <li> <p>Divide 6) by the distance or the time that separated both poses (e.g. 100 m).</p> </li> </ol> <p>This metric does not require both trajectories to be aligned. Units are m/m: %, deg/m for distance based comparison and m/s, deg/s for time-based comparison. </p> <p>Example:</p> <ul> <li>Minimum pose distance: 100</li> <li>Maximum pose distance: 800</li> <li>Distance step: 100</li> <li>Distance unit: Meter</li> </ul> <p>Results in pose distances: [100 m, 200 m, 300 m, 400 m, 500 m, 600 m, 700 m, 800 m]</p> <p>Furthermore, the user can choose to either use consecutive pose pairs (non-overlapping) or all posible pairs (overlapping).</p>"},{"location":"settings/#approximation-settings","title":"Approximation Settings","text":"<p>Trajectopy currently supports piece-wise cubic approximation for position components and moving average for rotation components. Piece-wise cubic means that the trajectory is divided into intervals of a specified size, and within each interval, a cubic polynomial is fitted to the position data. The fitted polynomial is then used to approximate the position values within that interval.</p> <ul> <li><code>position_interval_size</code> (float): Size of the position intervals in meters for cubic approximation. Default value is 0.15 meters.</li> <li><code>position_min_observations</code> (int): Minimum number of observations required in each position interval for cubic approximation. Default value is 25.</li> <li><code>rotation_window_size</code> (float): Size of the rotation smoothing window in meters for rotation approximation (not cubic!). Default value is 0.15 meters.</li> </ul>"},{"location":"settings/#sorting-settings","title":"Sorting Settings","text":"<p>Sorting involves two steps:</p> <ol> <li>Smoothing the trajectory using Moving Least Squares (MLS). The k nearest neighbors of each point are used to fit a 3D line, and the point is projected onto this line. This step reduces noise and outliers in the trajectory.</li> <li>Shortest path approximation by constructing a minimum spanning tree (MST) based on the smoothed points.</li> </ol> <p>For sorting, the following settings can be adjusted:</p> <ul> <li><code>voxel_size</code> (float): Moving Least Squares (MLS) setting. Instead of querying the raw input points, a voxel grid is created and the centroids of the occupied voxels are used for nearest neighbor searches. This setting specifies the size of the voxel grid for downsampling. Default value is 0.05 meters.</li> <li><code>movement_threshold</code> (float): Moving Least Squares (MLS) setting. This threshold defines the maximum allowed movement of points between two iterations of the MLS algorithm. If all points move less than this threshold, the MLS algorithm terminates. Default value is 0.005 meters.</li> <li><code>k_nearest</code> (int): Number of nearest voxels to consider during Moving Least Squares (MLS) smoothing. Default value is 4.</li> </ul>"},{"location":"settings/#choosing-the-plotting-backend","title":"Choosing the Plotting Backend","text":"<p>You can choose between two plotting backends: <code>matplotlib</code> and <code>plotly</code>. By default the <code>matplotlib</code> backend is used for quick and simple plotting. If you want to create advanced interactive HTML reports, you can switch to the <code>plotly</code> backend by clicking \"Plotting\" in the menu bar and selecting the desired backend (GUI). </p>"},{"location":"settings/#report-settings","title":"Report Settings","text":""},{"location":"settings/#visualization-settings","title":"Visualization Settings","text":"<ul> <li><code>single_plot_height</code> (int): The height of a single plot. Default value is 450.</li> <li><code>two_subplots_height</code> (int): The height of two subplots. Default value is 540.</li> <li><code>three_subplots_height</code> (int): The height of three subplots. Default value is 750.</li> <li><code>scatter_max_std</code> (float): The upper colorbar limit is set to the mean plus this value times the standard deviation of the data. This is useful to prevent outliers from dominating the colorbar. Default value is 4.0.</li> <li><code>ate_unit_is_mm</code> (bool): Indicates whether the unit of Absolute Trajectory Error (ATE) is millimeters. Default value is False.</li> <li><code>ate_remove_above</code> (float): Cap ATE at this value, if set to 0.0, no cap is applied. Default value is 0.0.</li> <li><code>directed_ate</code> (bool): Indicates whether the ATE is split into along-, horizontal-cross- and vertical-cross-track direction. Default value is False.</li> <li><code>histogram_opacity</code> (float): The opacity of the histogram bars. Default value is 0.7.</li> <li><code>histogram_bargap</code> (float): The gap between histogram bars. Default value is 0.1.</li> <li><code>histogram_barmode</code> (str): The mode of displaying histogram bars. Default value is \"overlay\".</li> <li><code>histogram_yaxis_title</code> (str): The title of the y-axis in the histogram. Default value is \"Count\".</li> <li><code>plot_mode</code> (str): The mode of displaying plots. Default value is \"lines+markers\".</li> <li><code>scatter_mode</code> (str): The mode of displaying scatter plots. Default value is \"markers\".</li> <li><code>scatter_colorscale</code> (str): The colorscale for scatter plots. Default value is \"RdYlBu_r\".</li> <li><code>scatter_axis_order</code> (str): The order of the axes in scatter plots. Default value is \"xy\". If 3d plotting is desired, also specify \"z\".</li> <li><code>scatter_marker_size</code> (int): The size of markers in scatter plots. Default value is 5.</li> <li><code>scatter_show_individual_dofs</code> (bool): Indicates whether to show scatter plots for each degree of freedom. Default value is False.</li> <li><code>scatter_smooth</code> (bool): Indicates whether the data defining the color of a scatter plot should be smoothed. Default value is False.</li> <li><code>scatter_smooth_window</code> (int): The window size for smoothing the scatter plot. Default value is 5.</li> </ul>"},{"location":"settings/#ate-frame-definition-regarding-directed_ate","title":"ATE Frame Definition (regarding <code>directed_ate</code>)","text":"<p>The ATE can be split into along-, horizontal-cross- and vertical-cross-track directions by setting <code>directed_ate</code> to <code>True</code>. The along-track direction is defined as positive in the direction of travel. The horizontal cross-track direction is defined as positive to the right of the along-track direction. The vertical cross-track direction is defined as positive upwards. The following image illustrates the frame definition.</p> <p></p>"},{"location":"settings/#mapbox-settings","title":"Mapbox Settings","text":"<ul> <li><code>scatter_plot_on_map</code> (bool): Indicates whether the trajectory should be plotted onto a map. Default value is False.</li> <li><code>scatter_mapbox_style</code> (str): The style of the map. For some styles, a Mapbox token is required. Default value is \"open-street-map\".</li> <li><code>scatter_mapbox_zoom</code> (int): The zoom level of the map. Default value is 15.</li> <li><code>scatter_mapbox_token</code> (str): The Mapbox token. Default value is \"\".</li> </ul> <p>The mapbox token can be obtained from https://www.mapbox.com/ after creating a free account. The token can be set in multiple ways:</p> <ul> <li>As a command line argument <code>--mapbox_token</code>.</li> <li>As an environment variable <code>MAPBOX_TOKEN</code>.</li> <li>Directly in the settings file.</li> <li>In the GUI settings dialog.</li> <li>By placing a file named <code>.mapbox_token</code> in the current working directory.</li> </ul>"},{"location":"settings/#position-units-and-names","title":"Position Units and Names","text":"<ul> <li><code>pos_x_name</code> (string): Name for the X-axis position. Default: \"x\".</li> <li><code>pos_y_name</code> (string): Name for the Y-axis position. Default: \"y\".</li> <li><code>pos_z_name</code> (string): Name for the Z-axis position. Default: \"z\".</li> <li><code>pos_x_unit</code> (string): Unit for the X-axis position, Default: \"m\".</li> <li><code>pos_y_unit</code> (string): Unit for the Y-axis position, Default: \"m\".</li> <li><code>pos_z_unit</code> (string): Unit for the Z-axis position, Default: \"m\".</li> <li><code>directed_pos_dev_x_name</code> (string): Name for the directed position deviation in along-track direction. Default: \"along\".</li> <li><code>directed_pos_dev_y_name</code> (string): Name for the directed position deviation in horizontal cross-track direction. Default: \"cross-h\".</li> <li><code>directed_pos_dev_z_name</code> (string): Name for the directed position deviation in vertical cross-track direction. Default: \"cross-v\".</li> </ul>"},{"location":"settings/#rotation-units-and-names","title":"Rotation Units and Names","text":"<ul> <li><code>rot_x_name</code> (string): Name for the roll rotation. Default: \"roll\".</li> <li><code>rot_y_name</code> (string): Name for the pitch rotation. Default: \"pitch\".</li> <li><code>rot_z_name</code> (string): Name for the yaw rotation. Default: \"yaw\".</li> <li><code>rot_unit</code> (string): Unit symbol for rotation. Default: \"\u00b0\".</li> </ul>"},{"location":"settings/#export-settings","title":"Export Settings","text":"<ul> <li><code>single_plot_export</code> (ExportSettings): The export settings for single plots. Default value is an instance of ExportSettings with width=800 and height=450.</li> <li><code>two_subplots_export</code> (ExportSettings): The export settings for two subplots. Default value is an instance of ExportSettings with width=800 and height=540.</li> <li><code>three_subplots_export</code> (ExportSettings): The export settings for three subplots. Default value is an instance of ExportSettings with width=800 and height=750.</li> </ul>"},{"location":"settings/#export-settings_1","title":"Export Settings","text":"<ul> <li><code>format</code> (string): The export format. Choices: \"png\", \"svg\", \"jpeg\", \"webp\". Default: \"png\".</li> <li><code>height</code> (integer): The export height in pixels. Default: 500.</li> <li><code>width</code> (integer): The export width in pixels. Default: 800.</li> <li><code>scale</code> (integer): The export scale. Default: 6.</li> </ul>"},{"location":"settings/#plotting-trajectories-on-a-map","title":"Plotting Trajectories on a Map","text":"<p>To plot trajectories on a map, several requirements must be met:</p> <ul> <li>The trajectory must have valid EPSG information.</li> <li>The plotting backend must be set to <code>plotly</code>.</li> <li>The <code>scatter_plot_on_map</code> option must be enabled.</li> <li>For <code>scatter_mapbox_style</code> other than <code>open-street-map</code>, a Mapbox access token (<code>scatter_mapbox_token</code>) must be provided. The mapbox token can be obtained after free registration at Mapbox.</li> </ul>"},{"location":"settings/#matplotlib-plotting-settings-mplplotsettings","title":"Matplotlib Plotting Settings (MPLPlotSettings)","text":"<ul> <li><code>colorbar_show_zero_crossing</code> (bool): Indicates whether the colorbar should show zero. Default value is True.</li> <li><code>colorbar_steps</code> (int): The number of steps in the colorbar. Default value is 4.</li> <li><code>colorbar_max_std</code> (float): The upper colorbar limit is set to the mean plus this value times the standard deviation of the data. This is useful to prevent outliers from dominating the colorbar. Default value is 3.0.</li> <li><code>scatter_hide_axes</code> (bool): Indicates whether the axis should be hidden. Default value is False.</li> <li><code>scatter_3d</code> (bool): Indicates whether the scatter plot should be 3D. Default value is False.</li> <li><code>scatter_smooth</code> (bool): Indicates whether the data defining the color of a scatter plot should be smoothed. Default value is False.</li> <li><code>scatter_smooth_window</code> (int): The window size for smoothing the scatter plot. Default value is 5.</li> <li><code>ate_unit_is_mm</code> (bool): Indicates whether the unit of Absolute Trajectory Error (ATE) is millimeters. Default value is False.</li> <li><code>ate_remove_above</code> (float): Cap ATE at this value, if set to 0.0, no cap is applied. Default value is 0.0.</li> <li><code>hist_as_stairs</code> (bool): Indicates whether the histogram should be displayed as stairs. Default value is False.</li> <li><code>hist_percentile</code> (float): Only show data up to this percentile in the histogram. Useful for data with outliers. Default value is 100.0.</li> <li><code>directed_ate</code> (bool): Indicates whether the ATE is split into along-, horizontal-cross- and vertical-cross-track direction. Default value is False.</li> <li><code>dofs_tab</code> (bool): Indicates whether the degrees of freedom tab should be shown. Default value is True.</li> <li><code>velocity_tab</code> (bool): Indicates whether the velocity tab should be shown. Default value is True.</li> <li><code>height_tab</code> (bool): Indicates whether the height tab should be shown. Default value is True.</li> </ul>"},{"location":"settings/#custom-matplotlib-plotting","title":"Custom Matplotlib Plotting","text":"<p>You can customize the style of the plots by placing a <code>custom.mplstyle</code> file in the current working directory. The default style that Trajectopy uses is:</p> <pre><code>figure.figsize: 8, 6\nfigure.facecolor: white\n\nfont.size: 12\nfont.family: serif\nfont.serif: Times New Roman, DejaVu Serif\n\naxes.facecolor: white\naxes.edgecolor: black\naxes.linewidth: 0.8\naxes.labelsize: 14\naxes.titlesize: 14\naxes.grid: True\naxes.axisbelow: True\naxes.prop_cycle: cycler(\"color\", [\"#1E88E5\", \"#FFC107\", \"#004D40\", \"#D81B60\", \"#2bd2bb\", \"#a3bbf1\", \"#3c41fd\", \"#cc5510\", \"#3b0732\", \"#88122b\", \"#bccb70\", \"#dc9c54\"])\n\ngrid.color: gray\ngrid.alpha: 0.3\ngrid.linewidth: 0.5\naxes.grid.which: major\n\nxtick.labelsize: 12\nytick.labelsize: 12\nxtick.direction: in\nytick.direction: in\nxtick.major.size: 5\nytick.major.size: 5\n\nlines.linewidth: 1.5\nlines.linestyle: -\nlines.marker: .\nlines.markersize: 6\n\nlegend.frameon: True\nlegend.facecolor: white\nlegend.edgecolor: black\nlegend.loc: best\nlegend.framealpha: 1\n\nsavefig.dpi: 600\nsavefig.format: pdf\nsavefig.bbox: tight\n</code></pre>"},{"location":"user_guide/","title":"User Guide","text":"<p>This guide covers the core functionality of Trajectopy: loading data, alignment, evaluation, and visualization. All functionality is available both via the Python API and the GUI application. The examples below use the Python API.</p>"},{"location":"user_guide/#1-loading-data","title":"1. Loading Data","text":"<p>Trajectories are loaded using the <code>Trajectory</code> class. All ASCII text files are supported as long as they meet the requirements described in File Formats.</p> <pre><code>from trajectopy import Trajectory\n\n# Load from file\ntraj = Trajectory.from_file(\"path/to/trajectory.traj\")\n</code></pre>"},{"location":"user_guide/#2-alignment","title":"2. Alignment","text":"<p>To compare two trajectories (e.g., estimated vs. ground truth), they often need to be aligned first.</p> <pre><code>from trajectopy import Trajectory, ProcessingSettings, estimate_alignment, apply_alignment\n\ngt_traj = Trajectory.from_file(\"./example_data/KITTI_gt.traj\")\nest_traj = Trajectory.from_file(\"./example_data/KITTI_ORB.traj\")\n\n# default settings\nprocessing_settings = ProcessingSettings()\n\n# Estimate alignment\nalignment_result = estimate_alignment(\n    trajectory=est_traj,\n    other=gt_traj,\n    alignment_settings=processing_settings.alignment,\n    matching_settings=processing_settings.matching,\n)\n\n# Apply alignment\nest_traj_aligned = apply_alignment(est_traj, alignment_result)\n</code></pre> <p>The function <code>align</code> combines these two steps:</p> <pre><code>from trajectopy import Trajectory, align\n\ngt_traj = Trajectory.from_file(\"./example_data/KITTI_gt.traj\")\nest_traj = Trajectory.from_file(\"./example_data/KITTI_ORB.traj\")\n\nest_traj_aligned = align(trajectory=est_traj, other=gt_traj, inplace=False)\n</code></pre>"},{"location":"user_guide/#3-evaluation","title":"3. Evaluation","text":"<p>Trajectopy provides standard metrics for trajectory evaluation.</p>"},{"location":"user_guide/#absolute-trajectory-error-ate","title":"Absolute Trajectory Error (ATE)","text":"<p>ATE measures the global consistency of the trajectory by building differences between corresponding poses. Note that <code>ate()</code> already includes alignment by default. This can be disabled by setting the function parameter <code>align=False</code>.</p> <pre><code>from trajectopy import Trajectory, ate, ProcessingSettings\n\ngt_traj = Trajectory.from_file(\"./example_data/KITTI_gt.traj\")\nest_traj = Trajectory.from_file(\"./example_data/KITTI_ORB.traj\")\n\n# default settings\nprocessing_settings = ProcessingSettings()\n\nate_result = ate(other=gt_traj, trajectory=est_traj, processing_settings=processing_settings)\nprint(f\"Position ATE: {ate_result.pos_ate}\")\n</code></pre>"},{"location":"user_guide/#relative-pose-error-rpe","title":"Relative Pose Error (RPE)","text":"<p>RPE measures the pose drift over fixed time or distance intervals.</p> <pre><code>from trajectopy import Trajectory, rpe, ProcessingSettings\n\ngt_traj = Trajectory.from_file(\"./example_data/KITTI_gt.traj\")\nest_traj = Trajectory.from_file(\"./example_data/KITTI_ORB.traj\")\n\n# default settings\nprocessing_settings = ProcessingSettings()\n\nrpe_result = rpe(other=gt_traj, trajectory=est_traj, processing_settings=processing_settings)\nprint(f\"Position RPE: {rpe_result.pos_rpe}\")\n</code></pre>"},{"location":"user_guide/#4-visualization-reporting","title":"4. Visualization &amp; Reporting","text":""},{"location":"user_guide/#plotly-reports","title":"Plotly Reports","text":"<p>You can generate interactive HTML reports using Plotly.</p>"},{"location":"user_guide/#trajectory-visualization","title":"Trajectory Visualization","text":"<pre><code>from trajectopy import Trajectory, ReportSettings\nfrom trajectopy.visualization import plotly_reports\n\ngt_traj = Trajectory.from_file(\"./example_data/KITTI_gt.traj\")\nest_traj = Trajectory.from_file(\"./example_data/KITTI_ORB.traj\")\n\nreport_settings = ReportSettings(scatter_axis_order=\"xy\", ate_unit_is_mm=False)\ntraj_report = plotly_reports.create_trajectory_report(\n    trajectories=[gt_traj, est_traj], report_settings=report_settings\n)\nplotly_reports.show_report(traj_report, filepath=\"reports/report.html\")\n</code></pre>"},{"location":"user_guide/#evaluation-report","title":"Evaluation Report","text":"<pre><code>from trajectopy import ProcessingSettings, ReportSettings, Trajectory, ate, rpe\nfrom trajectopy.visualization import plotly_reports\n\ngt_traj = Trajectory.from_file(\"./example_data/KITTI_gt.traj\")\nest_traj = Trajectory.from_file(\"./example_data/KITTI_ORB.traj\")\n\n# default settings\nprocessing_settings = ProcessingSettings()\n\nate_result = ate(other=gt_traj, trajectory=est_traj, processing_settings=processing_settings)\nrpe_result = rpe(other=gt_traj, trajectory=est_traj, processing_settings=processing_settings)\n\nreport_settings = ReportSettings(ate_unit_is_mm=False, scatter_marker_size=8)\nreport = plotly_reports.create_deviation_report(\n    ate_result=ate_result, rpe_result=rpe_result, report_settings=report_settings\n)\nplotly_reports.show_report(report_text=report, filepath=\"reports/report.html\")\n</code></pre>"},{"location":"user_guide/#alignment-report","title":"Alignment Report","text":"<pre><code>from trajectopy import ProcessingSettings, Trajectory, estimate_alignment\nfrom trajectopy.visualization import plotly_reports\n\ngt_traj = Trajectory.from_file(\"./example_data/KITTI_gt.traj\")\nest_traj = Trajectory.from_file(\"./example_data/KITTI_ORB.traj\")\n\n# default settings\nprocessing_settings = ProcessingSettings()\n\nalignment_result = estimate_alignment(\n    trajectory=est_traj,\n    other=gt_traj,\n    alignment_settings=processing_settings.alignment,\n    matching_settings=processing_settings.matching,\n)\n\nreport = plotly_reports.create_alignment_report(\n    alignment_parameters=alignment_result.position_parameters,\n    name=alignment_result.name,\n)\nplotly_reports.show_report(report_text=report, filepath=\"reports/report.html\")\n</code></pre>"},{"location":"user_guide/#matplotlib-visualization","title":"Matplotlib Visualization","text":"<p>Additionally, you can visualize trajectories directly using Matplotlib.</p> <pre><code>import matplotlib.pyplot as plt\n\nfrom trajectopy import Trajectory, ate, estimate_alignment, rpe\nfrom trajectopy.visualization import mpl_plots\n\ngt = Trajectory.from_file(\"./example_data/KITTI_gt.traj\")\norb = Trajectory.from_file(\"./example_data/KITTI_ORB.traj\")\nsptam = Trajectory.from_file(\"./example_data/KITTI_SPTAM.traj\")\nmpl_plots.plot_trajectories([gt, orb])\n\nalignment_result = estimate_alignment(gt, orb)\nate_result_orb = ate(gt, orb)\nate_result_sptam = ate(gt, sptam)\nrpe_result = rpe(gt, orb)\n\n# All available plotting functions\nmpl_plots.plot_covariance_heatmap(alignment_result.position_parameters)\nmpl_plots.plot_correlation_heatmap(alignment_result.position_parameters)\n\nmpl_plots.plot_ate_3d([ate_result_orb, ate_result_sptam])\nmpl_plots.plot_compact_ate_hist(ate_result_orb)\nmpl_plots.plot_ate([ate_result_orb, ate_result_sptam])\nmpl_plots.plot_ate_bars([ate_result_orb, ate_result_sptam], mode=\"positions\")\nmpl_plots.plot_ate_bars([ate_result_orb, ate_result_sptam], mode=\"rotations\")\n\nmpl_plots.plot_ate_edf(ate_result_orb)\n\nmpl_plots.scatter_ate(ate_result_orb)\n\nmpl_plots.plot_rpe(rpe_result)\n\nplt.show()\n</code></pre>"},{"location":"user_guide/#5-gui-application","title":"5. GUI Application","text":"<p>For a graphical interface, simply run:</p> <pre><code>trajectopy\n</code></pre> <p>This opens the application where you can drag &amp; drop files, align them, and view results interactively.</p>"},{"location":"api/","title":"API Reference","text":"<p>Welcome to the Trajectopy API reference. This section provides detailed documentation for all public modules, classes, and functions.</p>"},{"location":"api/#core-modules","title":"Core Modules","text":"<ul> <li>Trajectory - Main trajectory class for representing and manipulating trajectory data</li> <li>Positions - Position data container</li> <li>Rotations - Rotation data container  </li> <li>Settings - Configuration classes for trajectory processing</li> </ul>"},{"location":"api/#processing-functions","title":"Processing Functions","text":"<ul> <li>Alignment - Trajectory alignment functions</li> <li>Evaluation - ATE and RPE evaluation metrics</li> <li>Interpolation - Temporal interpolation</li> <li>Matching - Pose matching between trajectories</li> <li>Merging - Merge and average multiple trajectories</li> <li>Sorting - Spatial sorting of trajectories</li> <li>Approximation - Trajectory approximation algorithms</li> <li>Parameters - Alignment parameters and stochastic models</li> </ul>"},{"location":"api/#results","title":"Results","text":"<ul> <li>ATEResult - Absolute Trajectory Error results</li> <li>RPEResult - Relative Pose Error results</li> <li>AlignmentResult - Alignment parameters and statistics</li> </ul>"},{"location":"api/#visualization","title":"Visualization","text":"<ul> <li>Matplotlib Plots - Static plotting with Matplotlib</li> <li>Plotly Plots - Interactive plotting with Plotly</li> <li>HTML Reports - Generate comprehensive HTML reports</li> </ul>"},{"location":"api/core/positions/","title":"Positions","text":""},{"location":"api/core/positions/#trajectopy.core.positions","title":"positions","text":""},{"location":"api/core/positions/#trajectopy.core.positions.Positions","title":"Positions","text":"<pre><code>Positions(\n    xyz: Union[ndarray, list],\n    epsg: int = 0,\n    local_transformer: Transformer = None,\n    init_local_transformer: bool = True,\n    epsg_local_cart: int = 4936,\n    epsg_local_geod: int = 4937,\n)\n</code></pre> <p>Class representing (georeferenced) positions.</p> <p>The Positions class can hold one or multiple 3d positions with a corresponding EPSG code for datum information. When creating a Positions instance, a transformation pipeline is created based on the passed points, which can transform the points into a local system tangent to the ellipsoid (grs80). Such a local datum is represented within this class with an EPSG code of 0 and is mainly suitable for local calculations within the Positions.</p> <p>All transformations, including the local transformation, are carried out using pyproj, a python toolbox for projections and transformations.</p> <p>Initialize Positions and create local transformer.</p> <p>If a Positions instance is initialized directly with an EPSG code of 0, such a local transformer cannot be constructed, and a transformation into other EPSG codes is therefore not possible. Use this setting if you don't have any information about the geodetic datum of the passed points. However, if the local transformer is already known, it can be provided during the initialization of the Positions object using the local_transformer variable.</p> <p>Parameters:</p> <ul> <li> <code>xyz</code>               (<code>ndarray | list</code>)           \u2013            <p>1- / 2- dimensional numpy array containing the coordinates of the input positions.</p> </li> <li> <code>epsg</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>EPSG code of the datum of the input positions. Defaults to 0.</p> </li> <li> <code>local_transformer</code>               (<code>Transformer</code>, default:                   <code>None</code> )           \u2013            <p>pyproj transformer that describes the transformation to a local coordinate system. Defaults to None.</p> </li> <li> <code>init_local_transformer</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Specifies if a local transformer should be initialized. Defaults to True.</p> </li> <li> <code>epsg_local_cart</code>               (<code>int</code>, default:                   <code>4936</code> )           \u2013            <p>EPSG code of the earth-centered datum that is used to construct the local transformation pipeline. In a first step, the coordinates are transformed to this coordinate frame. In this coordinate frame they are reduced by their mean position. Defaults to 4936.</p> </li> <li> <code>epsg_local_geod</code>               (<code>int</code>, default:                   <code>4937</code> )           \u2013            <p>In the final step of the local transformation pipeline, the positions reduced by their mean are rotated into a local system tangent to the ellipsoid. The ellipsoid is defined by this parameter using an EPSG code. Both EPSG codes, epsg_local_cart and epsg_local_geod should refer to the same datum (here ETRS89). Defaults to 4937.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>PointSetError</code>             \u2013            <p>Gets raised if input xyz is not a numpy array.</p> </li> </ul> Source code in <code>trajectopy\\core\\positions.py</code> <pre><code>def __init__(\n    self,\n    xyz: Union[np.ndarray, list],\n    epsg: int = 0,\n    local_transformer: Transformer = None,\n    init_local_transformer: bool = True,\n    epsg_local_cart: int = 4936,\n    epsg_local_geod: int = 4937,\n) -&gt; None:\n    \"\"\"Initialize Positions and create local transformer.\n\n    If a Positions instance is initialized directly with an EPSG code of 0, such a local transformer\n    cannot be constructed, and a transformation into other EPSG codes is therefore not possible.\n    Use this setting if you don't have any information about the geodetic datum of the passed points.\n    However, if the local transformer is already known, it can be provided during the\n    initialization of the Positions object using the local_transformer variable.\n\n    Args:\n        xyz (np.ndarray | list): 1- / 2- dimensional numpy array containing the coordinates\n            of the input positions.\n        epsg (int, optional): EPSG code of the datum of the input positions. Defaults to 0.\n        local_transformer (Transformer, optional): pyproj transformer that describes the\n            transformation to a local coordinate system. Defaults to None.\n        init_local_transformer (bool, optional): Specifies if a local transformer should be\n            initialized. Defaults to True.\n        epsg_local_cart (int, optional): EPSG code of the earth-centered datum that is used\n            to construct the local transformation pipeline. In a first step, the coordinates\n            are transformed to this coordinate frame. In this coordinate frame they are reduced\n            by their mean position. Defaults to 4936.\n        epsg_local_geod (int, optional): In the final step of the local transformation pipeline,\n            the positions reduced by their mean are rotated into a local system tangent to the\n            ellipsoid. The ellipsoid is defined by this parameter using an EPSG code. Both EPSG\n            codes, epsg_local_cart and epsg_local_geod should refer to the same datum (here ETRS89).\n            Defaults to 4937.\n\n    Raises:\n        PointSetError: Gets raised if input xyz is not a numpy array.\n    \"\"\"\n\n    if not isinstance(xyz, np.ndarray):\n        xyz = np.array(xyz)\n\n    if (len(xyz.shape) == 1 and len(xyz) != 3) or (len(xyz.shape) == 2 and xyz.shape[1] != 3):\n        raise PointSetError(\"Input must be nx3 or 3xNone array!\")\n\n    self.xyz = xyz\n    self.epsg = epsg\n    self.local_transformer = local_transformer\n    self.epsg_local_geod = epsg_local_geod\n    self.epsg_local_cart = epsg_local_cart\n    self.pipeline_str = \"\"\n\n    if self.epsg == 0:\n        return\n\n    # Create CRS and local transformer\n    if local_transformer or not init_local_transformer:\n        return\n\n    self.build_local_transformer()\n</code></pre>"},{"location":"api/core/positions/#trajectopy.core.positions.Positions.xyz","title":"xyz  <code>property</code> <code>writable</code>","text":"<pre><code>xyz: ndarray\n</code></pre> <p>Returns the points within the Positions object.</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: 2-dimensional numpy array.</p> </li> </ul>"},{"location":"api/core/positions/#trajectopy.core.positions.Positions.x","title":"x  <code>property</code> <code>writable</code>","text":"<pre><code>x: Union[int, float, ndarray]\n</code></pre> <p>Returns x coordinate(s).</p> <p>The x/y/z properties will either return a one-dimensional numpy array or a single float / int depending on whether there is more than one point in the Positions object.</p> <p>Returns:</p> <ul> <li> <code>Union[int, float, ndarray]</code>           \u2013            <p>Union[int, float, np.ndarray]: X coordinate(s).</p> </li> </ul>"},{"location":"api/core/positions/#trajectopy.core.positions.Positions.y","title":"y  <code>property</code> <code>writable</code>","text":"<pre><code>y: Union[int, float, ndarray]\n</code></pre> <p>Returns y coordinate(s).</p> <p>The x/y/z properties will either return a one-dimensional numpy array or a single float / int depending on whether there is more than one point in the Positions object.</p> <p>Returns:</p> <ul> <li> <code>Union[int, float, ndarray]</code>           \u2013            <p>Union[int, float, np.ndarray]: Y coordinate(s).</p> </li> </ul>"},{"location":"api/core/positions/#trajectopy.core.positions.Positions.z","title":"z  <code>property</code> <code>writable</code>","text":"<pre><code>z: Union[int, float, ndarray]\n</code></pre> <p>Returns z coordinate(s).</p> <p>The x/y/z properties will either return a one-dimensional numpy array or a single float / int depending on whether there is more than one point in the Positions object.</p> <p>Returns:</p> <ul> <li> <code>Union[int, float, ndarray]</code>           \u2013            <p>Union[int, float, np.ndarray]: Z coordinate(s).</p> </li> </ul>"},{"location":"api/core/positions/#trajectopy.core.positions.Positions.crs","title":"crs  <code>property</code>","text":"<pre><code>crs: CRS\n</code></pre> <p>Returns the Coordinate Reference System.</p> <p>Returns:</p> <ul> <li> <code>CRS</code> (              <code>CRS</code> )          \u2013            <p>pyproj CRS object that represents the current coordinate system.</p> </li> </ul>"},{"location":"api/core/positions/#trajectopy.core.positions.Positions.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Returns number of points</p> Source code in <code>trajectopy\\core\\positions.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Returns number of points\"\"\"\n    return len(self.xyz)\n</code></pre>"},{"location":"api/core/positions/#trajectopy.core.positions.Positions.copy","title":"copy","text":"<pre><code>copy() -&gt; Positions\n</code></pre> <p>Deep copy</p> Source code in <code>trajectopy\\core\\positions.py</code> <pre><code>def copy(self) -&gt; \"Positions\":\n    \"\"\"Deep copy\"\"\"\n    return copy.deepcopy(self)\n</code></pre>"},{"location":"api/core/positions/#trajectopy.core.positions.Positions.__get_column","title":"__get_column","text":"<pre><code>__get_column(idx: int) -&gt; Union[int, float, ndarray]\n</code></pre> <p>Internal method to extract a column from xyz</p> <p>This method will return one column specified by idx from the xyz array. It distinguishes between the number of points and returns either a single float or a 1-d numpy array.</p> <p>Parameters:</p> <ul> <li> <code>idx</code>               (<code>int</code>)           \u2013            <p>index of the desired column</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Union[int, float, ndarray]</code>           \u2013            <p>Union[int, float, np.ndarray]: Value / array of that column</p> </li> </ul> Source code in <code>trajectopy\\core\\positions.py</code> <pre><code>def __get_column(self, idx: int) -&gt; Union[int, float, np.ndarray]:\n    \"\"\"Internal method to extract a column from xyz\n\n    This method will return one column specified by idx from the\n    xyz array.\n    It distinguishes between the number of points and returns\n    either a single float or a 1-d numpy array.\n\n    Args:\n        idx (int): index of the desired column\n\n    Returns:\n        Union[int, float, np.ndarray]: Value / array of that column\n    \"\"\"\n    return self.xyz[:, idx] if len(self.xyz) &gt; 1 else self.xyz[0][idx]\n</code></pre>"},{"location":"api/core/positions/#trajectopy.core.positions.Positions.__set_column","title":"__set_column","text":"<pre><code>__set_column(\n    v: Union[int, float, ndarray], idx: int\n) -&gt; None\n</code></pre> <p>Internal method to change a column of xyz</p> <p>This method will set a column of xyz to v.</p> <p>Parameters:</p> <ul> <li> <code>v</code>               (<code>Union[int, float, ndarray]</code>)           \u2013            <p>Value(s) with which the                                column is to be filled.                                Either a single value or                                an array of exactly the                                same length as xyz.</p> </li> <li> <code>idx</code>               (<code>int</code>)           \u2013            <p>column index in xyz</p> </li> </ul> Source code in <code>trajectopy\\core\\positions.py</code> <pre><code>def __set_column(self, v: Union[int, float, np.ndarray], idx: int) -&gt; None:\n    \"\"\"Internal method to change a column of xyz\n\n    This method will set a column of xyz to v.\n\n    Args:\n        v (Union[int, float, np.ndarray]): Value(s) with which the\n                                           column is to be filled.\n                                           Either a single value or\n                                           an array of exactly the\n                                           same length as xyz.\n        idx (int): column index in xyz\n    \"\"\"\n    self.xyz[:, idx] = v\n</code></pre>"},{"location":"api/core/positions/#trajectopy.core.positions.Positions.to_epsg","title":"to_epsg","text":"<pre><code>to_epsg(\n    target_epsg: int, inplace: bool = True\n) -&gt; Positions\n</code></pre> <p>Performs a coordinate transformation using a target CRS.</p> <p>This method will construct the required pyproj transformer and applies it in order to transform the positions to the target EPSG code.</p> <p>Parameters:</p> <ul> <li> <code>target_epsg</code>               (<code>int</code>)           \u2013            <p>EPSG code of target CRS.</p> </li> <li> <code>inplace</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Perform transformation in place. Defaults to True.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>PointSetError</code>             \u2013            <p>Gets raised if it is not possible to recover from a local datum since local transformer is unknown.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Positions</code> (              <code>Positions</code> )          \u2013            <p>Transformed positions.</p> </li> </ul> Source code in <code>trajectopy\\core\\positions.py</code> <pre><code>def to_epsg(self, target_epsg: int, inplace: bool = True) -&gt; \"Positions\":\n    \"\"\"Performs a coordinate transformation using a target CRS.\n\n    This method will construct the required pyproj transformer and applies it in order to\n    transform the positions to the target EPSG code.\n\n    Args:\n        target_epsg (int): EPSG code of target CRS.\n        inplace (bool, optional): Perform transformation in place. Defaults to True.\n\n    Raises:\n        PointSetError: Gets raised if it is not possible to recover from a local datum\n            since local transformer is unknown.\n\n    Returns:\n        Positions: Transformed positions.\n    \"\"\"\n    pointset = self if inplace else self.copy()\n\n    # 0) already there\n    if pointset.epsg == target_epsg:\n        return pointset\n\n    # currently in unknown frame\n    if pointset.epsg == 0 and pointset.local_transformer is None:\n        raise PointSetError(\"Unable to recover from local frame since definition is unknown!\")\n\n    # 1) from non-local to local\n    if target_epsg == 0:\n        # geocentric cartesian (ITRF2014)\n        pointset.to_epsg(target_epsg=pointset.epsg_local_cart)\n\n        # apply local transformer\n        x, y, z = pointset.local_transformer.transform(xx=pointset.x, yy=pointset.y, zz=pointset.z)\n\n        pointset.xyz = np.c_[x, y, z]\n        pointset.epsg = target_epsg\n\n        return pointset\n\n    # 2) from local to non-local (intermediate step)\n    if pointset.epsg == 0:\n        # undo local transformation\n        x, y, z = pointset.local_transformer.transform(\n            xx=pointset.x,\n            yy=pointset.y,\n            zz=pointset.z,\n            direction=TransformDirection.INVERSE,\n        )\n        xyz = np.c_[x, y, z]\n        crs = CRS.from_epsg(pointset.epsg_local_cart)\n    else:\n        xyz = pointset.xyz\n        crs = pointset.crs\n\n    # 3) from non-local to non-local\n    transformer = Transformer.from_crs(crs, CRS.from_epsg(code=target_epsg))\n\n    x, y, z = transformer.transform(xx=xyz[:, 0], yy=xyz[:, 1], zz=xyz[:, 2])\n\n    pointset.xyz = np.c_[x, y, z]\n    pointset.epsg = target_epsg\n\n    return pointset\n</code></pre>"},{"location":"api/core/positions/#trajectopy.core.positions.Positions.to_local","title":"to_local","text":"<pre><code>to_local(inplace: bool = True) -&gt; Positions\n</code></pre> <p>Transform positions to a local frame tangential to the (grs80) ellipsoid.</p> <p>This is equivalent to a transformation to an EPSG of 0.</p> <p>Parameters:</p> <ul> <li> <code>inplace</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Perform transformation in place. Defaults to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Positions</code> (              <code>Positions</code> )          \u2013            <p>2-dimensional object containing xyz of the transformed points.</p> </li> </ul> Source code in <code>trajectopy\\core\\positions.py</code> <pre><code>def to_local(self, inplace: bool = True) -&gt; \"Positions\":\n    \"\"\"Transform positions to a local frame tangential to the (grs80) ellipsoid.\n\n    This is equivalent to a transformation to an EPSG of 0.\n\n    Args:\n        inplace (bool, optional): Perform transformation in place. Defaults to True.\n\n    Returns:\n        Positions: 2-dimensional object containing xyz of the transformed points.\n    \"\"\"\n    return self.to_epsg(target_epsg=0, inplace=inplace)\n</code></pre>"},{"location":"api/core/positions/#trajectopy.core.positions.Positions.mean","title":"mean","text":"<pre><code>mean(inplace: bool = False) -&gt; Positions\n</code></pre> <p>Computes the mean of all points within the Positions object.</p> <p>Parameters:</p> <ul> <li> <code>inplace</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true, the positions object gets replaced by a single mean position. Defaults to False.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Positions</code> (              <code>Positions</code> )          \u2013            <p>Contains the mean position.</p> </li> </ul> Source code in <code>trajectopy\\core\\positions.py</code> <pre><code>def mean(self, inplace: bool = False) -&gt; \"Positions\":\n    \"\"\"Computes the mean of all points within the Positions object.\n\n    Args:\n        inplace (bool, optional): If true, the positions object gets replaced by a single mean\n            position. Defaults to False.\n\n    Returns:\n        Positions: Contains the mean position.\n    \"\"\"\n    mean_xyz = np.mean(self.xyz, axis=0)\n\n    if inplace:\n        self.xyz = mean_xyz\n    return Positions(xyz=mean_xyz, epsg=self.epsg, local_transformer=self.local_transformer)\n</code></pre>"},{"location":"api/core/positions/#trajectopy.core.positions.Positions.round_to","title":"round_to","text":"<pre><code>round_to(prec: float) -&gt; Positions\n</code></pre> <p>Rounds all points to a given precision.</p> <p>Parameters:</p> <ul> <li> <code>prec</code>               (<code>float</code>)           \u2013            <p>Desired rounding precision.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Positions</code> (              <code>Positions</code> )          \u2013            <p>Contains the rounded positions.</p> </li> </ul> Source code in <code>trajectopy\\core\\positions.py</code> <pre><code>def round_to(self, prec: float) -&gt; \"Positions\":\n    \"\"\"Rounds all points to a given precision.\n\n    Args:\n        prec (float): Desired rounding precision.\n\n    Returns:\n        Positions: Contains the rounded positions.\n    \"\"\"\n    rounded = self.copy()\n    rounded.xyz = np.round(rounded.xyz / prec) * prec\n    return rounded\n</code></pre>"},{"location":"api/core/positions/#trajectopy.core.positions.Positions.__add__","title":"__add__","text":"<pre><code>__add__(other: Positions) -&gt; Positions\n</code></pre> <p>Plus operator.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>Positions</code>)           \u2013            <p>Positions to add.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Positions</code> (              <code>Positions</code> )          \u2013            <p>Sum of positions.</p> </li> </ul> Source code in <code>trajectopy\\core\\positions.py</code> <pre><code>def __add__(self, other: \"Positions\") -&gt; \"Positions\":\n    \"\"\"Plus operator.\n\n    Args:\n        other (Positions): Positions to add.\n\n    Returns:\n        Positions: Sum of positions.\n    \"\"\"\n    xyz_add = self.xyz + other.xyz\n    return Positions(xyz=xyz_add, epsg=self.epsg, local_transformer=self.local_transformer)\n</code></pre>"},{"location":"api/core/positions/#trajectopy.core.positions.Positions.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: Positions) -&gt; Positions\n</code></pre> <p>Minus operator.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>Positions</code>)           \u2013            <p>Positions to subtract.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Positions</code> (              <code>Positions</code> )          \u2013            <p>Difference of positions.</p> </li> </ul> Source code in <code>trajectopy\\core\\positions.py</code> <pre><code>def __sub__(self, other: \"Positions\") -&gt; \"Positions\":\n    \"\"\"Minus operator.\n\n    Args:\n        other (Positions): Positions to subtract.\n\n    Returns:\n        Positions: Difference of positions.\n    \"\"\"\n    xyz_sub = self.xyz - other.xyz\n    return Positions(xyz=xyz_sub, epsg=self.epsg, local_transformer=self.local_transformer)\n</code></pre>"},{"location":"api/core/positions/#trajectopy.core.positions.Positions.__key","title":"__key","text":"<pre><code>__key() -&gt; tuple\n</code></pre> <p>Key generation used for hash generation.</p> <p>Returns:</p> <ul> <li> <code>tuple</code> (              <code>tuple</code> )          \u2013            <p>Key tuple for hashing.</p> </li> </ul> Source code in <code>trajectopy\\core\\positions.py</code> <pre><code>def __key(self) -&gt; tuple:\n    \"\"\"Key generation used for hash generation.\n\n    Returns:\n        tuple: Key tuple for hashing.\n    \"\"\"\n    return (\n        self.epsg,\n        self.xyz[:, 0] @ self.xyz[:, 0],\n        self.xyz[:, 1] @ self.xyz[:, 1],\n        self.xyz[:, 2] @ self.xyz[:, 2],\n        self.pipeline_str,\n    )\n</code></pre>"},{"location":"api/core/positions/#trajectopy.core.positions.Positions.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Positions) -&gt; bool\n</code></pre> <p>Equality comparison.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>Positions</code>)           \u2013            <p>Object to compare with.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if equal, False otherwise.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NotImplementedError</code>             \u2013            <p>If comparing with incompatible type.</p> </li> </ul> Source code in <code>trajectopy\\core\\positions.py</code> <pre><code>def __eq__(self, other: \"Positions\") -&gt; bool:\n    \"\"\"Equality comparison.\n\n    Args:\n        other: Object to compare with.\n\n    Returns:\n        bool: True if equal, False otherwise.\n\n    Raises:\n        NotImplementedError: If comparing with incompatible type.\n    \"\"\"\n    if isinstance(other, Positions):\n        return self.__key() == other.__key()\n    raise NotImplementedError(f\"Cannot compare {type(self)} with {type(other)}!\")\n</code></pre>"},{"location":"api/core/rotations/","title":"Rotations","text":""},{"location":"api/core/rotations/#trajectopy.core.rotations","title":"rotations","text":""},{"location":"api/core/rotations/#trajectopy.core.rotations.Rotations","title":"Rotations","text":"<p>               Bases: <code>Rotation</code></p> <p>Class representing rotations.</p> <p>This class is essentially just a wrapper around the parent scipy.spatial.transform.Rotation class. It extends its functionality by introducing + / - operators as well as the ability to create a deepcopy and to output rotation angles. Furthermore, it ensures that the naming is consistent with the pointset class.</p>"},{"location":"api/core/rotations/#trajectopy.core.rotations.Rotations.rotangle","title":"rotangle  <code>property</code>","text":"<pre><code>rotangle: ndarray\n</code></pre> <p>Returns minimum rotation angle(s).</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: Minimum rotation angle(s) in radians.</p> </li> </ul>"},{"location":"api/core/settings/","title":"Settings","text":""},{"location":"api/core/settings/#trajectopy.core.settings","title":"settings","text":""},{"location":"api/core/settings/#trajectopy.core.settings.Settings","title":"Settings  <code>dataclass</code>","text":"<pre><code>Settings()\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Base class for all settings dataclasses.</p> <p>Provides serialization/deserialization functionality to and from dictionaries, JSON strings, and files.</p>"},{"location":"api/core/settings/#trajectopy.core.settings.Settings.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Converts settings to a dictionary.</p> <p>Returns:</p> <ul> <li> <code>dict</code> (              <code>dict</code> )          \u2013            <p>Dictionary representation of the settings</p> </li> </ul> Source code in <code>trajectopy\\core\\settings.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Converts settings to a dictionary.\n\n    Returns:\n        dict: Dictionary representation of the settings\n    \"\"\"\n    return {\n        key: (value.to_dict() if issubclass(type(value), Settings) else self.encoder(key, value))\n        for key, value in self.__dict__.items()\n    }\n</code></pre>"},{"location":"api/core/settings/#trajectopy.core.settings.Settings.encoder","title":"encoder  <code>staticmethod</code>","text":"<pre><code>encoder(name: str, value: Any) -&gt; Any\n</code></pre> <p>Encodes values for JSON serialization.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name of the attribute being encoded</p> </li> <li> <code>value</code>               (<code>Any</code>)           \u2013            <p>Value to encode</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>Encoded value suitable for JSON serialization</p> </li> </ul> Source code in <code>trajectopy\\core\\settings.py</code> <pre><code>@staticmethod\ndef encoder(name: str, value: Any) -&gt; Any:\n    \"\"\"Encodes values for JSON serialization.\n\n    Args:\n        name: Name of the attribute being encoded\n        value: Value to encode\n\n    Returns:\n        Any: Encoded value suitable for JSON serialization\n    \"\"\"\n    return value\n</code></pre>"},{"location":"api/core/settings/#trajectopy.core.settings.Settings.decoder","title":"decoder  <code>staticmethod</code>","text":"<pre><code>decoder(name: str, value: Any) -&gt; Any\n</code></pre> <p>Decodes values from JSON deserialization.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name of the attribute being decoded</p> </li> <li> <code>value</code>               (<code>Any</code>)           \u2013            <p>Value to decode</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>Decoded value</p> </li> </ul> Source code in <code>trajectopy\\core\\settings.py</code> <pre><code>@staticmethod\ndef decoder(name: str, value: Any) -&gt; Any:\n    \"\"\"Decodes values from JSON deserialization.\n\n    Args:\n        name: Name of the attribute being decoded\n        value: Value to decode\n\n    Returns:\n        Any: Decoded value\n    \"\"\"\n    return value\n</code></pre>"},{"location":"api/core/settings/#trajectopy.core.settings.Settings.to_json","title":"to_json","text":"<pre><code>to_json() -&gt; str\n</code></pre> <p>Converts settings to a JSON string.</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>JSON string representation of the settings</p> </li> </ul> Source code in <code>trajectopy\\core\\settings.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Converts settings to a JSON string.\n\n    Returns:\n        str: JSON string representation of the settings\n    \"\"\"\n    return json.dumps(self.to_dict(), indent=4)\n</code></pre>"},{"location":"api/core/settings/#trajectopy.core.settings.Settings.to_file","title":"to_file","text":"<pre><code>to_file(path: str) -&gt; None\n</code></pre> <p>Writes settings to a JSON file.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>Path to the output file</p> </li> </ul> Source code in <code>trajectopy\\core\\settings.py</code> <pre><code>def to_file(self, path: str) -&gt; None:\n    \"\"\"Writes settings to a JSON file.\n\n    Args:\n        path: Path to the output file\n    \"\"\"\n    with open(path, \"w\", encoding=\"utf-8\") as f:\n        f.write(self.to_json())\n</code></pre>"},{"location":"api/core/settings/#trajectopy.core.settings.Settings.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(dct: dict) -&gt; Settings\n</code></pre> <p>Creates settings instance from a dictionary.</p> <p>Parameters:</p> <ul> <li> <code>dct</code>               (<code>dict</code>)           \u2013            <p>Dictionary containing settings data</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Settings</code> (              <code>Settings</code> )          \u2013            <p>New settings instance</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If required attribute is missing from dictionary</p> </li> </ul> Source code in <code>trajectopy\\core\\settings.py</code> <pre><code>@classmethod\ndef from_dict(cls, dct: dict) -&gt; \"Settings\":\n    \"\"\"Creates settings instance from a dictionary.\n\n    Args:\n        dct: Dictionary containing settings data\n\n    Returns:\n        Settings: New settings instance\n\n    Raises:\n        ValueError: If required attribute is missing from dictionary\n    \"\"\"\n    settings = cls()\n    for attribute_name, attribute_type in cls.__annotations__.items():\n        if attribute_name not in dct:\n            raise ValueError(f\"Attribute {attribute_name} not found in input data\")\n\n        attribute_data = dct[attribute_name]\n        if isinstance(attribute_data, dict) and issubclass(attribute_type, Settings):\n            setattr(settings, attribute_name, attribute_type.from_dict(attribute_data))\n        else:\n            setattr(settings, attribute_name, settings.decoder(attribute_name, attribute_data))\n\n    return settings\n</code></pre>"},{"location":"api/core/settings/#trajectopy.core.settings.Settings.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(path: str) -&gt; Settings\n</code></pre> <p>Loads settings from a JSON file.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>Path to the JSON file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Settings</code> (              <code>Settings</code> )          \u2013            <p>Settings instance loaded from file</p> </li> </ul> Source code in <code>trajectopy\\core\\settings.py</code> <pre><code>@classmethod\ndef from_file(cls, path: str) -&gt; \"Settings\":\n    \"\"\"Loads settings from a JSON file.\n\n    Args:\n        path: Path to the JSON file\n\n    Returns:\n        Settings: Settings instance loaded from file\n    \"\"\"\n    with open(path, \"r\", encoding=\"utf-8\") as f:\n        data = json.load(f)\n\n    return cls.from_dict(data)\n</code></pre>"},{"location":"api/core/settings/#trajectopy.core.settings.Settings.update_from_dict","title":"update_from_dict","text":"<pre><code>update_from_dict(dct: dict) -&gt; None\n</code></pre> <p>Updates settings from a dictionary.</p> <p>Parameters:</p> <ul> <li> <code>dct</code>               (<code>dict</code>)           \u2013            <p>Dictionary containing updated settings data</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If required attribute is missing from dictionary</p> </li> </ul> Source code in <code>trajectopy\\core\\settings.py</code> <pre><code>def update_from_dict(self, dct: dict) -&gt; None:\n    \"\"\"Updates settings from a dictionary.\n\n    Args:\n        dct: Dictionary containing updated settings data\n\n    Raises:\n        ValueError: If required attribute is missing from dictionary\n    \"\"\"\n    for attribute_name, attribute_type in self.__annotations__.items():\n        if attribute_name not in dct:\n            raise ValueError(f\"Attribute {attribute_name} not found in input data\")\n\n        attribute_data = dct[attribute_name]\n        if isinstance(attribute_data, dict) and issubclass(attribute_type, Settings):\n            getattr(self, attribute_name).update_from_dict(attribute_data)\n        else:\n            setattr(self, attribute_name, self.decoder(attribute_name, attribute_data))\n</code></pre>"},{"location":"api/core/settings/#trajectopy.core.settings.AlignmentPreprocessing","title":"AlignmentPreprocessing  <code>dataclass</code>","text":"<pre><code>AlignmentPreprocessing(\n    min_speed: float = 0.0,\n    time_start: float = 0.0,\n    time_end: float = 0.0,\n)\n</code></pre> <p>               Bases: <code>Settings</code></p> <p>Configuration for alignment preprocessing filters.</p> <p>Attributes:</p> <ul> <li> <code>min_speed</code>               (<code>float</code>)           \u2013            <p>Only poses with speed above this threshold are considered for alignment (meters/second). Defaults to 0.0.</p> </li> <li> <code>time_start</code>               (<code>float</code>)           \u2013            <p>Only poses with timestamp above this threshold are considered. Timestamp is in seconds relative to first common timestamp. Defaults to 0.0.</p> </li> <li> <code>time_end</code>               (<code>float</code>)           \u2013            <p>Only poses with timestamp below this threshold are considered. Timestamp is in seconds relative to first common timestamp. Defaults to 0.0.</p> </li> </ul>"},{"location":"api/core/settings/#trajectopy.core.settings.AlignmentEstimationSettings","title":"AlignmentEstimationSettings  <code>dataclass</code>","text":"<pre><code>AlignmentEstimationSettings(\n    translation_x: bool = True,\n    translation_y: bool = True,\n    translation_z: bool = True,\n    rotation_x: bool = True,\n    rotation_y: bool = True,\n    rotation_z: bool = True,\n    scale: bool = False,\n    time_shift: bool = False,\n    leverarm_x: bool = False,\n    leverarm_y: bool = False,\n    leverarm_z: bool = False,\n    sensor_rotation: bool = False,\n)\n</code></pre> <p>               Bases: <code>Settings</code></p> <p>Configuration for parameters to estimate during trajectory alignment.</p> <p>Attributes:</p> <ul> <li> <code>translation_x</code>               (<code>bool</code>)           \u2013            <p>Enable x-translation of similarity transformation</p> </li> <li> <code>translation_y</code>               (<code>bool</code>)           \u2013            <p>Enable y-translation of similarity transformation</p> </li> <li> <code>translation_z</code>               (<code>bool</code>)           \u2013            <p>Enable z-translation of similarity transformation</p> </li> <li> <code>rotation_x</code>               (<code>bool</code>)           \u2013            <p>Enable rotation around X-axis of similarity transformation</p> </li> <li> <code>rotation_y</code>               (<code>bool</code>)           \u2013            <p>Enable rotation around Y-axis of similarity transformation</p> </li> <li> <code>rotation_z</code>               (<code>bool</code>)           \u2013            <p>Enable rotation around Z-axis of similarity transformation</p> </li> <li> <code>scale</code>               (<code>bool</code>)           \u2013            <p>Enable scaling of similarity transformation</p> </li> <li> <code>time_shift</code>               (<code>bool</code>)           \u2013            <p>Enable estimation of time shift between trajectories</p> </li> <li> <code>leverarm_x</code>               (<code>bool</code>)           \u2013            <p>Enable estimation of lever arm in X-direction</p> </li> <li> <code>leverarm_y</code>               (<code>bool</code>)           \u2013            <p>Enable estimation of lever arm in Y-direction</p> </li> <li> <code>leverarm_z</code>               (<code>bool</code>)           \u2013            <p>Enable estimation of lever arm in Z-direction</p> </li> <li> <code>sensor_rotation</code>               (<code>bool</code>)           \u2013            <p>Enable computation of sensor rotation offsets (independent of least squares, computes constant offsets between roll, pitch, yaw)</p> </li> </ul>"},{"location":"api/core/settings/#trajectopy.core.settings.AlignmentEstimationSettings.all_disabled","title":"all_disabled  <code>property</code>","text":"<pre><code>all_disabled: bool\n</code></pre> <p>Checks if all alignment parameters are disabled.</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if all parameters (Helmert, time shift, leverarm, sensor rotation) are disabled</p> </li> </ul>"},{"location":"api/core/settings/#trajectopy.core.settings.AlignmentEstimationSettings.all_lq_disabled","title":"all_lq_disabled  <code>property</code>","text":"<pre><code>all_lq_disabled: bool\n</code></pre> <p>Checks if all least-squares parameters are disabled.</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if all parameters estimated with least-squares are disabled</p> </li> </ul>"},{"location":"api/core/settings/#trajectopy.core.settings.AlignmentEstimationSettings.helmert_enabled","title":"helmert_enabled  <code>property</code>","text":"<pre><code>helmert_enabled: bool\n</code></pre> <p>Checks if any Helmert transformation parameter is enabled.</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if any translation, rotation, or scale parameter is enabled</p> </li> </ul>"},{"location":"api/core/settings/#trajectopy.core.settings.AlignmentEstimationSettings.leverarm_enabled","title":"leverarm_enabled  <code>property</code>","text":"<pre><code>leverarm_enabled: bool\n</code></pre> <p>Checks if any leverarm parameter is enabled.</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if any leverarm component (x, y, z) is enabled</p> </li> </ul>"},{"location":"api/core/settings/#trajectopy.core.settings.AlignmentEstimationSettings.time_shift_enabled","title":"time_shift_enabled  <code>property</code>","text":"<pre><code>time_shift_enabled: bool\n</code></pre> <p>Checks if time shift estimation is enabled.</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if time shift is enabled</p> </li> </ul>"},{"location":"api/core/settings/#trajectopy.core.settings.AlignmentEstimationSettings.short_mode_str","title":"short_mode_str  <code>property</code>","text":"<pre><code>short_mode_str: str\n</code></pre> <p>Gets a short string describing enabled parameter groups.</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>Space-separated string of enabled parameter groups (e.g., \"Helmert Time-Shift Leverarm\")</p> </li> </ul>"},{"location":"api/core/settings/#trajectopy.core.settings.AlignmentEstimationSettings.time_shift_filter","title":"time_shift_filter  <code>property</code>","text":"<pre><code>time_shift_filter: List[bool]\n</code></pre> <p>Gets time shift parameter filter.</p> <p>Returns:</p> <ul> <li> <code>List[bool]</code>           \u2013            <p>List[bool]: List of 3 bools, all True if time shift enabled, else all False</p> </li> </ul>"},{"location":"api/core/settings/#trajectopy.core.settings.AlignmentEstimationSettings.helmert_filter","title":"helmert_filter  <code>property</code>","text":"<pre><code>helmert_filter: List[bool]\n</code></pre> <p>Gets Helmert parameter filter.</p> <p>Returns:</p> <ul> <li> <code>List[bool]</code>           \u2013            <p>List[bool]: List of 7 bools indicating which Helmert parameters are enabled</p> </li> </ul>"},{"location":"api/core/settings/#trajectopy.core.settings.AlignmentEstimationSettings.leverarm_filter","title":"leverarm_filter  <code>property</code>","text":"<pre><code>leverarm_filter: List[bool]\n</code></pre> <p>Gets leverarm parameter filter.</p> <p>Returns:</p> <ul> <li> <code>List[bool]</code>           \u2013            <p>List[bool]: List of 3 bools indicating which leverarm components are enabled</p> </li> </ul>"},{"location":"api/core/settings/#trajectopy.core.settings.AlignmentEstimationSettings.enabled_lq_parameter_filter","title":"enabled_lq_parameter_filter  <code>property</code>","text":"<pre><code>enabled_lq_parameter_filter: List[bool]\n</code></pre> <p>Gets filter for enabled least-squares parameters only.</p> <p>Returns:</p> <ul> <li> <code>List[bool]</code>           \u2013            <p>List[bool]: List of bools for only the enabled parameter groups</p> </li> </ul>"},{"location":"api/core/settings/#trajectopy.core.settings.AlignmentEstimationSettings.lq_parameter_filter","title":"lq_parameter_filter  <code>property</code>","text":"<pre><code>lq_parameter_filter: List[bool]\n</code></pre> <p>Gets complete least-squares parameter filter.</p> <p>Returns:</p> <ul> <li> <code>List[bool]</code>           \u2013            <p>List[bool]: List of 11 bools for all LQ parameters (7 Helmert + 1 time shift + 3 leverarm)</p> </li> </ul>"},{"location":"api/core/settings/#trajectopy.core.settings.AlignmentEstimationSettings.__bool__","title":"__bool__","text":"<pre><code>__bool__() -&gt; bool\n</code></pre> <p>Returns True if any least-squares parameter is enabled.</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if at least one least-squares parameter is enabled</p> </li> </ul> Source code in <code>trajectopy\\core\\settings.py</code> <pre><code>def __bool__(self) -&gt; bool:\n    \"\"\"Returns True if any least-squares parameter is enabled.\n\n    Returns:\n        bool: True if at least one least-squares parameter is enabled\n    \"\"\"\n    return not self.all_lq_disabled\n</code></pre>"},{"location":"api/core/settings/#trajectopy.core.settings.AlignmentEstimationSettings.from_components","title":"from_components  <code>classmethod</code>","text":"<pre><code>from_components(\n    similarity: bool = False,\n    time_shift: bool = False,\n    leverarm: bool = False,\n    sensor_rotation: bool = False,\n) -&gt; AlignmentEstimationSettings\n</code></pre> <p>Creates settings from high-level component flags.</p> <p>Parameters:</p> <ul> <li> <code>similarity</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Enable all similarity transformation parameters. Defaults to False.</p> </li> <li> <code>time_shift</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Enable time shift estimation. Defaults to False.</p> </li> <li> <code>leverarm</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Enable all leverarm parameters. Defaults to False.</p> </li> <li> <code>sensor_rotation</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Enable sensor rotation estimation. Defaults to False.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AlignmentEstimationSettings</code> (              <code>AlignmentEstimationSettings</code> )          \u2013            <p>New settings instance</p> </li> </ul> Source code in <code>trajectopy\\core\\settings.py</code> <pre><code>@classmethod\ndef from_components(\n    cls,\n    similarity: bool = False,\n    time_shift: bool = False,\n    leverarm: bool = False,\n    sensor_rotation: bool = False,\n) -&gt; \"AlignmentEstimationSettings\":\n    \"\"\"Creates settings from high-level component flags.\n\n    Args:\n        similarity: Enable all similarity transformation parameters. Defaults to False.\n        time_shift: Enable time shift estimation. Defaults to False.\n        leverarm: Enable all leverarm parameters. Defaults to False.\n        sensor_rotation: Enable sensor rotation estimation. Defaults to False.\n\n    Returns:\n        AlignmentEstimationSettings: New settings instance\n    \"\"\"\n    return cls(\n        translation_x=similarity,\n        translation_y=similarity,\n        translation_z=similarity,\n        rotation_x=similarity,\n        rotation_y=similarity,\n        rotation_z=similarity,\n        scale=similarity,\n        time_shift=time_shift,\n        leverarm_x=leverarm,\n        leverarm_y=leverarm,\n        leverarm_z=leverarm,\n        sensor_rotation=sensor_rotation,\n    )\n</code></pre>"},{"location":"api/core/settings/#trajectopy.core.settings.AlignmentEstimationSettings.all","title":"all  <code>classmethod</code>","text":"<pre><code>all(\n    sensor_rotation: bool = True,\n) -&gt; AlignmentEstimationSettings\n</code></pre> <p>Creates settings with all parameters enabled.</p> <p>Parameters:</p> <ul> <li> <code>sensor_rotation</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Enable sensor rotation. Defaults to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AlignmentEstimationSettings</code> (              <code>AlignmentEstimationSettings</code> )          \u2013            <p>Settings with all parameters enabled</p> </li> </ul> Source code in <code>trajectopy\\core\\settings.py</code> <pre><code>@classmethod\ndef all(cls, sensor_rotation: bool = True) -&gt; \"AlignmentEstimationSettings\":\n    \"\"\"Creates settings with all parameters enabled.\n\n    Args:\n        sensor_rotation: Enable sensor rotation. Defaults to True.\n\n    Returns:\n        AlignmentEstimationSettings: Settings with all parameters enabled\n    \"\"\"\n    return cls(\n        translation_x=True,\n        translation_y=True,\n        translation_z=True,\n        rotation_x=True,\n        rotation_y=True,\n        rotation_z=True,\n        scale=True,\n        time_shift=True,\n        leverarm_x=True,\n        leverarm_y=True,\n        leverarm_z=True,\n        sensor_rotation=sensor_rotation,\n    )\n</code></pre>"},{"location":"api/core/settings/#trajectopy.core.settings.AlignmentEstimationSettings.from_bool_list","title":"from_bool_list  <code>classmethod</code>","text":"<pre><code>from_bool_list(\n    bool_list: List[bool],\n) -&gt; AlignmentEstimationSettings\n</code></pre> <p>Creates settings from a list of boolean values.</p> <p>Parameters:</p> <ul> <li> <code>bool_list</code>               (<code>List[bool]</code>)           \u2013            <p>List of 14 booleans corresponding to parameter enable flags</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AlignmentEstimationSettings</code> (              <code>AlignmentEstimationSettings</code> )          \u2013            <p>New settings instance</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If bool_list length is not 14</p> </li> </ul> Source code in <code>trajectopy\\core\\settings.py</code> <pre><code>@classmethod\ndef from_bool_list(cls, bool_list: List[bool]) -&gt; \"AlignmentEstimationSettings\":\n    \"\"\"Creates settings from a list of boolean values.\n\n    Args:\n        bool_list: List of 14 booleans corresponding to parameter enable flags\n\n    Returns:\n        AlignmentEstimationSettings: New settings instance\n\n    Raises:\n        ValueError: If bool_list length is not 14\n    \"\"\"\n    if len(bool_list) != 14:\n        raise ValueError(\n            f\"Size mismatch: bool_list must have length 14 (Number of configurable parameters) (got {len(bool_list)})\"\n        )\n\n    return AlignmentEstimationSettings(\n        translation_x=bool_list[0],\n        translation_y=bool_list[1],\n        translation_z=bool_list[2],\n        rotation_x=bool_list[3],\n        rotation_y=bool_list[4],\n        rotation_z=bool_list[5],\n        scale=bool_list[6],\n        time_shift=bool_list[7],\n        leverarm_x=bool_list[8],\n        leverarm_y=bool_list[9],\n        leverarm_z=bool_list[10],\n        sensor_rotation=any(bool_list[11:]),\n    )\n</code></pre>"},{"location":"api/core/settings/#trajectopy.core.settings.AlignmentStochastics","title":"AlignmentStochastics  <code>dataclass</code>","text":"<pre><code>AlignmentStochastics(\n    std_xy_from: float = 1.0,\n    std_z_from: float = 1.0,\n    std_xy_to: float = 1.0,\n    std_z_to: float = 1.0,\n    std_roll_pitch: float = float(deg2rad(1.0)),\n    std_yaw: float = float(deg2rad(1.0)),\n    std_speed: float = 1.0,\n    error_probability: float = 0.05,\n    variance_estimation: bool = False,\n)\n</code></pre> <p>               Bases: <code>Settings</code></p> <p>Configuration for alignment stochastic model (observation uncertainties).</p> <p>Attributes:</p> <ul> <li> <code>std_xy_from</code>               (<code>float</code>)           \u2013            <p>Standard deviation of XY source position components in meters. Defaults to 1.0.</p> </li> <li> <code>std_z_from</code>               (<code>float</code>)           \u2013            <p>Standard deviation of Z source position component in meters. Defaults to 1.0.</p> </li> <li> <code>std_xy_to</code>               (<code>float</code>)           \u2013            <p>Standard deviation of XY target position components in meters. Defaults to 1.0.</p> </li> <li> <code>std_z_to</code>               (<code>float</code>)           \u2013            <p>Standard deviation of Z target position component in meters. Defaults to 1.0.</p> </li> <li> <code>std_roll_pitch</code>               (<code>float</code>)           \u2013            <p>Standard deviation of roll and pitch angles in radians. Defaults to ~0.017 rad (1\u00b0).</p> </li> <li> <code>std_yaw</code>               (<code>float</code>)           \u2013            <p>Standard deviation of yaw angle in radians. Defaults to ~0.017 rad (1\u00b0).</p> </li> <li> <code>std_speed</code>               (<code>float</code>)           \u2013            <p>Standard deviation of platform speed in meters per second. Defaults to 1.0.</p> </li> <li> <code>error_probability</code>               (<code>float</code>)           \u2013            <p>Probability of error for stochastic testing. Defaults to 0.05.</p> </li> <li> <code>variance_estimation</code>               (<code>bool</code>)           \u2013            <p>Enable a-posteriori variance factor estimation. Defaults to False.</p> </li> </ul>"},{"location":"api/core/settings/#trajectopy.core.settings.AlignmentStochastics.var_xy_from","title":"var_xy_from  <code>property</code>","text":"<pre><code>var_xy_from: float\n</code></pre> <p>Gets variance of XY source position components.</p> <p>Returns:</p> <ul> <li> <code>float</code> (              <code>float</code> )          \u2013            <p>Variance (squared standard deviation)</p> </li> </ul>"},{"location":"api/core/settings/#trajectopy.core.settings.AlignmentStochastics.var_z_from","title":"var_z_from  <code>property</code>","text":"<pre><code>var_z_from: float\n</code></pre> <p>Gets variance of Z source position component.</p> <p>Returns:</p> <ul> <li> <code>float</code> (              <code>float</code> )          \u2013            <p>Variance (squared standard deviation)</p> </li> </ul>"},{"location":"api/core/settings/#trajectopy.core.settings.AlignmentStochastics.var_xy_to","title":"var_xy_to  <code>property</code>","text":"<pre><code>var_xy_to: float\n</code></pre> <p>Gets variance of XY target position components.</p> <p>Returns:</p> <ul> <li> <code>float</code> (              <code>float</code> )          \u2013            <p>Variance (squared standard deviation)</p> </li> </ul>"},{"location":"api/core/settings/#trajectopy.core.settings.AlignmentStochastics.var_z_to","title":"var_z_to  <code>property</code>","text":"<pre><code>var_z_to: float\n</code></pre> <p>Gets variance of Z target position component.</p> <p>Returns:</p> <ul> <li> <code>float</code> (              <code>float</code> )          \u2013            <p>Variance (squared standard deviation)</p> </li> </ul>"},{"location":"api/core/settings/#trajectopy.core.settings.AlignmentStochastics.var_roll_pitch","title":"var_roll_pitch  <code>property</code>","text":"<pre><code>var_roll_pitch: float\n</code></pre> <p>Gets variance of roll and pitch angles.</p> <p>Returns:</p> <ul> <li> <code>float</code> (              <code>float</code> )          \u2013            <p>Variance (squared standard deviation)</p> </li> </ul>"},{"location":"api/core/settings/#trajectopy.core.settings.AlignmentStochastics.var_yaw","title":"var_yaw  <code>property</code>","text":"<pre><code>var_yaw: float\n</code></pre> <p>Gets variance of yaw angle.</p> <p>Returns:</p> <ul> <li> <code>float</code> (              <code>float</code> )          \u2013            <p>Variance (squared standard deviation)</p> </li> </ul>"},{"location":"api/core/settings/#trajectopy.core.settings.AlignmentStochastics.var_speed_to","title":"var_speed_to  <code>property</code>","text":"<pre><code>var_speed_to: float\n</code></pre> <p>Gets variance of platform speed.</p> <p>Returns:</p> <ul> <li> <code>float</code> (              <code>float</code> )          \u2013            <p>Variance (squared standard deviation)</p> </li> </ul>"},{"location":"api/core/settings/#trajectopy.core.settings.AlignmentSettings","title":"AlignmentSettings  <code>dataclass</code>","text":"<pre><code>AlignmentSettings(\n    preprocessing: AlignmentPreprocessing = AlignmentPreprocessing(),\n    estimation_settings: AlignmentEstimationSettings = AlignmentEstimationSettings(),\n    stochastics: AlignmentStochastics = AlignmentStochastics(),\n    metric_threshold: float = METRIC_THRESHOLD,\n    time_threshold: float = TIME_THRESHOLD,\n)\n</code></pre> <p>               Bases: <code>Settings</code></p> <p>Complete configuration for trajectory alignment.</p> <p>Combines preprocessing, estimation, and stochastic settings for trajectory alignment.</p> <p>Attributes:</p> <ul> <li> <code>preprocessing</code>               (<code>AlignmentPreprocessing</code>)           \u2013            <p>Preprocessing filter settings</p> </li> <li> <code>estimation_settings</code>               (<code>AlignmentEstimationSettings</code>)           \u2013            <p>Parameter estimation settings</p> </li> <li> <code>stochastics</code>               (<code>AlignmentStochastics</code>)           \u2013            <p>Stochastic model (observation uncertainty) settings</p> </li> <li> <code>metric_threshold</code>               (<code>float</code>)           \u2013            <p>Iteration threshold for metric parameters in least squares. Defaults to 1e-4.</p> </li> <li> <code>time_threshold</code>               (<code>float</code>)           \u2013            <p>Iteration threshold for time shift parameter in least squares (seconds). Defaults to 1e-4.</p> </li> </ul>"},{"location":"api/core/settings/#trajectopy.core.settings.AlignmentSettings.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Returns string representation of all settings.</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>Concatenated string of preprocessing, estimation, and stochastics settings</p> </li> </ul> Source code in <code>trajectopy\\core\\settings.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Returns string representation of all settings.\n\n    Returns:\n        str: Concatenated string of preprocessing, estimation, and stochastics settings\n    \"\"\"\n    return str(self.preprocessing) + str(self.estimation_settings) + str(self.stochastics)\n</code></pre>"},{"location":"api/core/settings/#trajectopy.core.settings.ApproximationSettings","title":"ApproximationSettings  <code>dataclass</code>","text":"<pre><code>ApproximationSettings(\n    position_interval_size: float = 0.15,\n    position_min_observations: int = 25,\n    rotation_window_size: float = 0.15,\n)\n</code></pre> <p>               Bases: <code>Settings</code></p> <p>Configuration for trajectory approximation and smoothing.</p> <p>Attributes:</p> <ul> <li> <code>position_interval_size</code>               (<code>float</code>)           \u2013            <p>Size of position intervals in meters for cubic approximation. Defaults to 0.15.</p> </li> <li> <code>position_min_observations</code>               (<code>int</code>)           \u2013            <p>Minimum number of observations required in each interval for cubic approximation. Defaults to 25.</p> </li> <li> <code>rotation_window_size</code>               (<code>float</code>)           \u2013            <p>Size of rotation smoothing window in meters (not cubic). Defaults to 0.15.</p> </li> </ul>"},{"location":"api/core/settings/#trajectopy.core.settings.PairDistanceUnit","title":"PairDistanceUnit","text":"<p>               Bases: <code>Enum</code></p> <p>Unit of measurement for pose pair distances in relative comparison.</p>"},{"location":"api/core/settings/#trajectopy.core.settings.PairDistanceUnit.from_str","title":"from_str  <code>classmethod</code>","text":"<pre><code>from_str(unit_str: str) -&gt; PairDistanceUnit\n</code></pre> <p>Converts a string to a PairDistanceUnit.</p> <p>Parameters:</p> <ul> <li> <code>unit_str</code>               (<code>str</code>)           \u2013            <p>String to convert (\"m\", \"meter\", \"s\", \"sec\", \"second\")</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PairDistanceUnit</code> (              <code>PairDistanceUnit</code> )          \u2013            <p>Converted unit</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If unit string is not recognized</p> </li> </ul> Source code in <code>trajectopy\\core\\settings.py</code> <pre><code>@classmethod\ndef from_str(cls, unit_str: str) -&gt; \"PairDistanceUnit\":\n    \"\"\"Converts a string to a PairDistanceUnit.\n\n    Args:\n        unit_str: String to convert (\"m\", \"meter\", \"s\", \"sec\", \"second\")\n\n    Returns:\n        PairDistanceUnit: Converted unit\n\n    Raises:\n        ValueError: If unit string is not recognized\n    \"\"\"\n    if unit_str.lower() in {\"m\", \"meter\"}:\n        return cls.METER\n    if unit_str.lower() in {\"s\", \"sec\", \"second\"}:\n        return cls.SECOND\n\n    raise ValueError(f\"Unknown unit string {unit_str}\")\n</code></pre>"},{"location":"api/core/settings/#trajectopy.core.settings.ComparisonMethod","title":"ComparisonMethod","text":"<p>               Bases: <code>Enum</code></p> <p>Method for trajectory comparison.</p>"},{"location":"api/core/settings/#trajectopy.core.settings.ComparisonMethod.from_string","title":"from_string  <code>classmethod</code>","text":"<pre><code>from_string(string: str) -&gt; ComparisonMethod\n</code></pre> <p>Converts string to ComparisonMethod.</p> <p>Parameters:</p> <ul> <li> <code>string</code>               (<code>str</code>)           \u2013            <p>String containing \"absolute\" or \"relative\"</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ComparisonMethod</code> (              <code>ComparisonMethod</code> )          \u2013            <p>Parsed comparison method</p> </li> </ul> Source code in <code>trajectopy\\core\\settings.py</code> <pre><code>@classmethod\ndef from_string(cls, string: str) -&gt; \"ComparisonMethod\":\n    \"\"\"Converts string to ComparisonMethod.\n\n    Args:\n        string: String containing \"absolute\" or \"relative\"\n\n    Returns:\n        ComparisonMethod: Parsed comparison method\n    \"\"\"\n    return comparison_method_from_string(string)\n</code></pre>"},{"location":"api/core/settings/#trajectopy.core.settings.RelativeComparisonSettings","title":"RelativeComparisonSettings  <code>dataclass</code>","text":"<pre><code>RelativeComparisonSettings(\n    pair_min_distance: float = 100.0,\n    pair_max_distance: float = 800.0,\n    pair_distance_step: float = 100.0,\n    pair_distance_unit: PairDistanceUnit = METER,\n    use_all_pose_pairs: bool = True,\n)\n</code></pre> <p>               Bases: <code>Settings</code></p> <p>Configuration for relative trajectory comparison (RPE - Relative Pose Error).</p> <p>Relative comparison involves finding pose pairs separated by specific distances or time intervals and computing relative translation/rotation differences.</p> <p>Attributes:</p> <ul> <li> <code>pair_min_distance</code>               (<code>float</code>)           \u2013            <p>Minimum pose pair distance to consider during RPE computation. Defaults to 100.0.</p> </li> <li> <code>pair_max_distance</code>               (<code>float</code>)           \u2013            <p>Maximum pose pair distance to consider during RPE computation. Defaults to 800.0.</p> </li> <li> <code>pair_distance_step</code>               (<code>float</code>)           \u2013            <p>Step size for increasing pose pair distance. Defaults to 100.0.</p> </li> <li> <code>pair_distance_unit</code>               (<code>PairDistanceUnit</code>)           \u2013            <p>Unit of pose pair distance (METER or SECOND). Defaults to METER.</p> </li> <li> <code>use_all_pose_pairs</code>               (<code>bool</code>)           \u2013            <p>If True, use overlapping pose pairs; if False, use only consecutive (non-overlapping) pairs. Defaults to True.</p> </li> </ul>"},{"location":"api/core/settings/#trajectopy.core.settings.RelativeComparisonSettings.encoder","title":"encoder  <code>staticmethod</code>","text":"<pre><code>encoder(name: str, value: Any) -&gt; Any\n</code></pre> <p>Encodes pair_distance_unit enum to string value.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Attribute name</p> </li> <li> <code>value</code>               (<code>Any</code>)           \u2013            <p>Value to encode</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>Encoded value</p> </li> </ul> Source code in <code>trajectopy\\core\\settings.py</code> <pre><code>@staticmethod\ndef encoder(name: str, value: Any) -&gt; Any:\n    \"\"\"Encodes pair_distance_unit enum to string value.\n\n    Args:\n        name: Attribute name\n        value: Value to encode\n\n    Returns:\n        Any: Encoded value\n    \"\"\"\n    return value.value if name == \"pair_distance_unit\" else value\n</code></pre>"},{"location":"api/core/settings/#trajectopy.core.settings.RelativeComparisonSettings.decoder","title":"decoder  <code>staticmethod</code>","text":"<pre><code>decoder(name: str, value: Any) -&gt; Any\n</code></pre> <p>Decodes pair_distance_unit string to enum.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Attribute name</p> </li> <li> <code>value</code>               (<code>Any</code>)           \u2013            <p>Value to decode</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>Decoded value</p> </li> </ul> Source code in <code>trajectopy\\core\\settings.py</code> <pre><code>@staticmethod\ndef decoder(name: str, value: Any) -&gt; Any:\n    \"\"\"Decodes pair_distance_unit string to enum.\n\n    Args:\n        name: Attribute name\n        value: Value to decode\n\n    Returns:\n        Any: Decoded value\n    \"\"\"\n    return PairDistanceUnit(value) if name == \"pair_distance_unit\" else value\n</code></pre>"},{"location":"api/core/settings/#trajectopy.core.settings.MatchingMethod","title":"MatchingMethod","text":"<p>               Bases: <code>Enum</code></p> <p>Method for matching poses between two trajectories.</p> <p>Attributes:</p> <ul> <li> <code>NEAREST_SPATIAL</code>           \u2013            <p>Match by nearest Euclidean distance</p> </li> <li> <code>NEAREST_TEMPORAL</code>           \u2013            <p>Match by nearest timestamp</p> </li> <li> <code>INTERPOLATION</code>           \u2013            <p>Match using linear interpolation (SLERP for rotations)</p> </li> <li> <code>NEAREST_SPATIAL_INTERPOLATED</code>           \u2013            <p>Match spatially using k-nearest and 3D line fit</p> </li> <li> <code>UNKNOWN</code>           \u2013            <p>Unknown matching method</p> </li> </ul>"},{"location":"api/core/settings/#trajectopy.core.settings.InterpolationMethod","title":"InterpolationMethod","text":"<p>               Bases: <code>Enum</code></p> <p>Method for interpolation.</p>"},{"location":"api/core/settings/#trajectopy.core.settings.MatchingSettings","title":"MatchingSettings  <code>dataclass</code>","text":"<pre><code>MatchingSettings(\n    method: MatchingMethod = INTERPOLATION,\n    max_time_diff: float = 0.01,\n    max_distance: float = 0.0,\n    max_gap_size: float = 10.0,\n    k_nearest: int = 2,\n)\n</code></pre> <p>               Bases: <code>Settings</code></p> <p>Configuration for trajectory matching.</p> <p>Attributes:</p> <ul> <li> <code>method</code>               (<code>MatchingMethod</code>)           \u2013            <p>Matching method to use. Defaults to INTERPOLATION.</p> </li> <li> <code>max_time_diff</code>               (<code>float</code>)           \u2013            <p>Maximum allowed time difference in seconds for temporal matching. Defaults to 0.01.</p> </li> <li> <code>max_distance</code>               (<code>float</code>)           \u2013            <p>Maximum allowed distance in meters for spatial matching. Defaults to 0.0.</p> </li> <li> <code>max_gap_size</code>               (<code>float</code>)           \u2013            <p>Maximum allowed gap size in seconds within trajectories. Defaults to 10.0.</p> </li> <li> <code>k_nearest</code>               (<code>int</code>)           \u2013            <p>Number of nearest neighbors for spatial interpolation matching. Defaults to 2.</p> </li> </ul>"},{"location":"api/core/settings/#trajectopy.core.settings.MatchingSettings.encoder","title":"encoder  <code>staticmethod</code>","text":"<pre><code>encoder(name: str, value: Any) -&gt; Any\n</code></pre> <p>Encodes method enum to string value.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Attribute name</p> </li> <li> <code>value</code>               (<code>Any</code>)           \u2013            <p>Value to encode</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>Encoded value</p> </li> </ul> Source code in <code>trajectopy\\core\\settings.py</code> <pre><code>@staticmethod\ndef encoder(name: str, value: Any) -&gt; Any:\n    \"\"\"Encodes method enum to string value.\n\n    Args:\n        name: Attribute name\n        value: Value to encode\n\n    Returns:\n        Any: Encoded value\n    \"\"\"\n    return value.value if name == \"method\" else value\n</code></pre>"},{"location":"api/core/settings/#trajectopy.core.settings.MatchingSettings.decoder","title":"decoder  <code>staticmethod</code>","text":"<pre><code>decoder(name: str, value: Any) -&gt; Any\n</code></pre> <p>Decodes method string to enum.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Attribute name</p> </li> <li> <code>value</code>               (<code>Any</code>)           \u2013            <p>Value to decode</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>Decoded value</p> </li> </ul> Source code in <code>trajectopy\\core\\settings.py</code> <pre><code>@staticmethod\ndef decoder(name: str, value: Any) -&gt; Any:\n    \"\"\"Decodes method string to enum.\n\n    Args:\n        name: Attribute name\n        value: Value to decode\n\n    Returns:\n        Any: Decoded value\n    \"\"\"\n    return MatchingMethod(value) if name == \"method\" else value\n</code></pre>"},{"location":"api/core/settings/#trajectopy.core.settings.MPLPlotSettings","title":"MPLPlotSettings  <code>dataclass</code>","text":"<pre><code>MPLPlotSettings(\n    colorbar_show_zero_crossing: bool = True,\n    colorbar_steps: int = 4,\n    colorbar_max_std: float = 3.0,\n    scatter_hide_axes: bool = False,\n    scatter_3d: bool = False,\n    scatter_smooth: bool = False,\n    scatter_smooth_window: int = 5,\n    ate_unit_is_mm: bool = False,\n    ate_remove_above: float = 0.0,\n    hist_as_stairs: bool = False,\n    hist_percentile: float = 1.0,\n    directed_ate: bool = False,\n    dofs_tab: bool = True,\n    velocity_tab: bool = True,\n    height_tab: bool = True,\n)\n</code></pre> <p>               Bases: <code>Settings</code></p> <p>Configuration for matplotlib plotting backend.</p> <p>Attributes:</p> <ul> <li> <code>colorbar_show_zero_crossing</code>               (<code>bool</code>)           \u2013            <p>Show zero in colorbar. Defaults to True.</p> </li> <li> <code>colorbar_steps</code>               (<code>int</code>)           \u2013            <p>Number of colorbar steps. Defaults to 4.</p> </li> <li> <code>colorbar_max_std</code>               (<code>float</code>)           \u2013            <p>Upper colorbar limit as mean + this * std. Defaults to 3.0.</p> </li> <li> <code>scatter_hide_axes</code>               (<code>bool</code>)           \u2013            <p>Hide axes in scatter plots. Defaults to False.</p> </li> <li> <code>scatter_3d</code>               (<code>bool</code>)           \u2013            <p>Use 3D scatter plots. Defaults to False.</p> </li> <li> <code>scatter_smooth</code>               (<code>bool</code>)           \u2013            <p>Smooth scatter plot color data. Defaults to False.</p> </li> <li> <code>scatter_smooth_window</code>               (<code>int</code>)           \u2013            <p>Window size for scatter smoothing. Defaults to 5.</p> </li> <li> <code>ate_unit_is_mm</code>               (<code>bool</code>)           \u2013            <p>Use millimeters for ATE units. Defaults to False.</p> </li> <li> <code>ate_remove_above</code>               (<code>float</code>)           \u2013            <p>Cap ATE values above this (0.0 = no cap). Defaults to 0.0.</p> </li> <li> <code>hist_as_stairs</code>               (<code>bool</code>)           \u2013            <p>Display histogram as stairs. Defaults to False.</p> </li> <li> <code>hist_percentile</code>               (<code>float</code>)           \u2013            <p>Show histogram data up to this percentile. Defaults to 1.0.</p> </li> <li> <code>directed_ate</code>               (<code>bool</code>)           \u2013            <p>Split ATE into along/cross-track directions. Defaults to False.</p> </li> <li> <code>dofs_tab</code>               (<code>bool</code>)           \u2013            <p>Show degrees of freedom tab. Defaults to True.</p> </li> <li> <code>velocity_tab</code>               (<code>bool</code>)           \u2013            <p>Show velocity tab. Defaults to True.</p> </li> <li> <code>height_tab</code>               (<code>bool</code>)           \u2013            <p>Show height tab. Defaults to True.</p> </li> </ul>"},{"location":"api/core/settings/#trajectopy.core.settings.MPLPlotSettings.unit_multiplier","title":"unit_multiplier  <code>property</code>","text":"<pre><code>unit_multiplier: float\n</code></pre> <p>Gets unit multiplier for converting meters to display unit.</p> <p>Returns:</p> <ul> <li> <code>float</code> (              <code>float</code> )          \u2013            <p>1000 if using millimeters, 1 otherwise</p> </li> </ul>"},{"location":"api/core/settings/#trajectopy.core.settings.MPLPlotSettings.unit_str","title":"unit_str  <code>property</code>","text":"<pre><code>unit_str: str\n</code></pre> <p>Gets unit string for display.</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>\"[mm]\" if using millimeters, \"[m]\" otherwise</p> </li> </ul>"},{"location":"api/core/settings/#trajectopy.core.settings.PlotBackend","title":"PlotBackend","text":"<p>               Bases: <code>Enum</code></p> <p>Plotting backend selection.</p>"},{"location":"api/core/settings/#trajectopy.core.settings.SortingSettings","title":"SortingSettings  <code>dataclass</code>","text":"<pre><code>SortingSettings(\n    voxel_size: float = 0.05,\n    movement_threshold: float = 0.005,\n    k_nearest: int = 4,\n)\n</code></pre> <p>               Bases: <code>Settings</code></p> <p>Configuration for trajectory sorting and downsampling using Moving Least Squares.</p> <p>Attributes:</p> <ul> <li> <code>voxel_size</code>               (<code>float</code>)           \u2013            <p>Size of voxel grid for downsampling (meters). Voxel centroids are used for nearest neighbor searches instead of raw points. Defaults to 0.05.</p> </li> <li> <code>movement_threshold</code>               (<code>float</code>)           \u2013            <p>Maximum allowed point movement between MLS iterations (meters). Algorithm terminates when all points move less than this. Defaults to 0.005.</p> </li> <li> <code>k_nearest</code>               (<code>int</code>)           \u2013            <p>Number of nearest voxels to consider during MLS smoothing. Defaults to 4.</p> </li> </ul>"},{"location":"api/core/settings/#trajectopy.core.settings.ProcessingSettings","title":"ProcessingSettings  <code>dataclass</code>","text":"<pre><code>ProcessingSettings(\n    alignment: AlignmentSettings = AlignmentSettings(),\n    matching: MatchingSettings = MatchingSettings(),\n    relative_comparison: RelativeComparisonSettings = RelativeComparisonSettings(),\n    approximation: ApproximationSettings = ApproximationSettings(),\n    sorting: SortingSettings = SortingSettings(),\n)\n</code></pre> <p>               Bases: <code>Settings</code></p> <p>Complete configuration for trajectory processing.</p> <p>Combines all processing-related settings including alignment, matching, relative comparison, approximation, and sorting.</p> <p>Attributes:</p> <ul> <li> <code>alignment</code>               (<code>AlignmentSettings</code>)           \u2013            <p>Alignment configuration</p> </li> <li> <code>matching</code>               (<code>MatchingSettings</code>)           \u2013            <p>Matching configuration</p> </li> <li> <code>relative_comparison</code>               (<code>RelativeComparisonSettings</code>)           \u2013            <p>Relative comparison (RPE) configuration</p> </li> <li> <code>approximation</code>               (<code>ApproximationSettings</code>)           \u2013            <p>Approximation and smoothing configuration</p> </li> <li> <code>sorting</code>               (<code>SortingSettings</code>)           \u2013            <p>Sorting and downsampling configuration</p> </li> </ul>"},{"location":"api/core/settings/#trajectopy.core.settings.ExportSettings","title":"ExportSettings  <code>dataclass</code>","text":"<pre><code>ExportSettings(\n    format: str = \"png\",\n    height: int = 500,\n    width: int = 800,\n    scale: int = 1,\n)\n</code></pre> <p>               Bases: <code>Settings</code></p> <p>Configuration for exporting plots to image files.</p> <p>Attributes:</p> <ul> <li> <code>format</code>               (<code>str</code>)           \u2013            <p>Export format (\"png\", \"svg\", \"jpeg\", \"webp\"). Defaults to \"png\".</p> </li> <li> <code>height</code>               (<code>int</code>)           \u2013            <p>Export height in pixels. Defaults to 500.</p> </li> <li> <code>width</code>               (<code>int</code>)           \u2013            <p>Export width in pixels. Defaults to 800.</p> </li> <li> <code>scale</code>               (<code>int</code>)           \u2013            <p>Export scale factor. Defaults to 1.</p> </li> </ul>"},{"location":"api/core/settings/#trajectopy.core.settings.ExportSettings.to_config","title":"to_config","text":"<pre><code>to_config() -&gt; dict\n</code></pre> <p>Converts export settings to plotly configuration dictionary.</p> <p>Returns:</p> <ul> <li> <code>dict</code> (              <code>dict</code> )          \u2013            <p>Plotly toImageButtonOptions configuration</p> </li> </ul> Source code in <code>trajectopy\\core\\settings.py</code> <pre><code>def to_config(self) -&gt; dict:\n    \"\"\"Converts export settings to plotly configuration dictionary.\n\n    Returns:\n        dict: Plotly toImageButtonOptions configuration\n    \"\"\"\n    return {\n        \"toImageButtonOptions\": {\n            \"format\": self.format,\n            \"height\": self.height,\n            \"width\": self.width,\n            \"scale\": self.scale,\n        }\n    }\n</code></pre>"},{"location":"api/core/settings/#trajectopy.core.settings.ReportSettings","title":"ReportSettings  <code>dataclass</code>","text":"<pre><code>ReportSettings(\n    single_plot_height: int = 750,\n    two_subplots_height: int = 750,\n    three_subplots_height: int = 860,\n    scatter_max_std: float = 4.0,\n    ate_unit_is_mm: bool = False,\n    ate_remove_above: float = 0.0,\n    directed_ate: bool = False,\n    histogram_opacity: float = 0.7,\n    histogram_bargap: float = 0.1,\n    histogram_barmode: str = \"overlay\",\n    histogram_yaxis_title: str = \"Count\",\n    plot_mode: str = \"lines+markers\",\n    scatter_mode: str = \"markers\",\n    scatter_colorscale: str = \"RdYlBu_r\",\n    scatter_axis_order: str = \"xy\",\n    scatter_marker_size: int = 5,\n    scatter_show_individual_dofs: bool = False,\n    scatter_smooth: bool = False,\n    scatter_smooth_window: int = 5,\n    scatter_plot_on_map: bool = False,\n    scatter_mapbox_style: str = \"open-street-map\",\n    scatter_mapbox_zoom: int = 15,\n    scatter_mapbox_token: str = \"\",\n    pos_x_name: str = \"x\",\n    pos_y_name: str = \"y\",\n    pos_z_name: str = \"z\",\n    pos_x_unit: str = \"m\",\n    pos_y_unit: str = \"m\",\n    pos_z_unit: str = \"m\",\n    directed_pos_dev_x_name: str = \"along\",\n    directed_pos_dev_y_name: str = \"cross-h\",\n    directed_pos_dev_z_name: str = \"cross-v\",\n    rot_x_name: str = \"roll\",\n    rot_y_name: str = \"pitch\",\n    rot_z_name: str = \"yaw\",\n    rot_unit: str = \"\u00b0\",\n    single_plot_export: ExportSettings = (\n        lambda: ExportSettings(width=800, height=540)\n    )(),\n    two_subplots_export: ExportSettings = (\n        lambda: ExportSettings(width=800, height=540)\n    )(),\n    three_subplots_export: ExportSettings = (\n        lambda: ExportSettings(width=800, height=750)\n    )(),\n)\n</code></pre> <p>               Bases: <code>Settings</code></p> <p>Configuration for interactive HTML report generation (plotly backend).</p> <p>Controls visualization, styling, and export settings for trajectory comparison reports. The along-track direction is positive in travel direction, horizontal cross-track is positive to the right, and vertical cross-track is positive upwards.</p> <p>Attributes:</p> <ul> <li> <code>single_plot_height</code>               (<code>int</code>)           \u2013            <p>Height of single plots in pixels. Defaults to 750.</p> </li> <li> <code>two_subplots_height</code>               (<code>int</code>)           \u2013            <p>Height of two-subplot figures in pixels. Defaults to 750.</p> </li> <li> <code>three_subplots_height</code>               (<code>int</code>)           \u2013            <p>Height of three-subplot figures in pixels. Defaults to 860.</p> </li> <li> <code>scatter_max_std</code>               (<code>float</code>)           \u2013            <p>Upper colorbar limit as mean + this * std (prevents outlier dominance). Defaults to 4.0.</p> </li> <li> <code>ate_unit_is_mm</code>               (<code>bool</code>)           \u2013            <p>Use millimeters for ATE instead of meters. Defaults to False.</p> </li> <li> <code>ate_remove_above</code>               (<code>float</code>)           \u2013            <p>Cap ATE values above this (0.0 = no cap). Defaults to 0.0.</p> </li> <li> <code>directed_ate</code>               (<code>bool</code>)           \u2013            <p>Split ATE into along-track, horizontal cross-track, and vertical cross-track directions. Defaults to False.</p> </li> <li> <code>histogram_opacity</code>               (<code>float</code>)           \u2013            <p>Opacity of histogram bars [0-1]. Defaults to 0.7.</p> </li> <li> <code>histogram_bargap</code>               (<code>float</code>)           \u2013            <p>Gap between histogram bars. Defaults to 0.1.</p> </li> <li> <code>histogram_barmode</code>               (<code>str</code>)           \u2013            <p>Display mode for histogram bars. Defaults to \"overlay\".</p> </li> <li> <code>histogram_yaxis_title</code>               (<code>str</code>)           \u2013            <p>Y-axis label for histograms. Defaults to \"Count\".</p> </li> <li> <code>plot_mode</code>               (<code>str</code>)           \u2013            <p>Display mode for line plots. Defaults to \"lines+markers\".</p> </li> <li> <code>scatter_mode</code>               (<code>str</code>)           \u2013            <p>Display mode for scatter plots. Defaults to \"markers\".</p> </li> <li> <code>scatter_colorscale</code>               (<code>str</code>)           \u2013            <p>Colorscale for scatter plots. Defaults to \"RdYlBu_r\".</p> </li> <li> <code>scatter_axis_order</code>               (<code>str</code>)           \u2013            <p>Axes to display in scatter plots (\"xy\" or \"xyz\"). Defaults to \"xy\".</p> </li> <li> <code>scatter_marker_size</code>               (<code>int</code>)           \u2013            <p>Size of scatter plot markers. Defaults to 5.</p> </li> <li> <code>scatter_show_individual_dofs</code>               (<code>bool</code>)           \u2013            <p>Show scatter plots for each degree of freedom. Defaults to False.</p> </li> <li> <code>scatter_smooth</code>               (<code>bool</code>)           \u2013            <p>Smooth scatter plot color data. Defaults to False.</p> </li> <li> <code>scatter_smooth_window</code>               (<code>int</code>)           \u2013            <p>Window size for scatter smoothing. Defaults to 5.</p> </li> <li> <code>scatter_plot_on_map</code>               (<code>bool</code>)           \u2013            <p>Plot trajectories on mapbox map (requires valid EPSG). Defaults to False.</p> </li> <li> <code>scatter_mapbox_style</code>               (<code>str</code>)           \u2013            <p>Mapbox style (some require token). Defaults to \"open-street-map\".</p> </li> <li> <code>scatter_mapbox_zoom</code>               (<code>int</code>)           \u2013            <p>Mapbox zoom level. Defaults to 15.</p> </li> <li> <code>scatter_mapbox_token</code>               (<code>str</code>)           \u2013            <p>Mapbox access token (optional). Defaults to \"\".</p> </li> <li> <code>pos_x_name</code>               (<code>str</code>)           \u2013            <p>Label for X position coordinate. Defaults to \"x\".</p> </li> <li> <code>pos_y_name</code>               (<code>str</code>)           \u2013            <p>Label for Y position coordinate. Defaults to \"y\".</p> </li> <li> <code>pos_z_name</code>               (<code>str</code>)           \u2013            <p>Label for Z position coordinate. Defaults to \"z\".</p> </li> <li> <code>pos_x_unit</code>               (<code>str</code>)           \u2013            <p>Unit symbol for X position. Defaults to \"m\".</p> </li> <li> <code>pos_y_unit</code>               (<code>str</code>)           \u2013            <p>Unit symbol for Y position. Defaults to \"m\".</p> </li> <li> <code>pos_z_unit</code>               (<code>str</code>)           \u2013            <p>Unit symbol for Z position. Defaults to \"m\".</p> </li> <li> <code>directed_pos_dev_x_name</code>               (<code>str</code>)           \u2013            <p>Label for along-track direction deviation. Defaults to \"along\".</p> </li> <li> <code>directed_pos_dev_y_name</code>               (<code>str</code>)           \u2013            <p>Label for horizontal cross-track deviation. Defaults to \"cross-h\".</p> </li> <li> <code>directed_pos_dev_z_name</code>               (<code>str</code>)           \u2013            <p>Label for vertical cross-track deviation. Defaults to \"cross-v\".</p> </li> <li> <code>rot_x_name</code>               (<code>str</code>)           \u2013            <p>Label for roll angle. Defaults to \"roll\".</p> </li> <li> <code>rot_y_name</code>               (<code>str</code>)           \u2013            <p>Label for pitch angle. Defaults to \"pitch\".</p> </li> <li> <code>rot_z_name</code>               (<code>str</code>)           \u2013            <p>Label for yaw angle. Defaults to \"yaw\".</p> </li> <li> <code>rot_unit</code>               (<code>str</code>)           \u2013            <p>Unit symbol for rotation angles. Defaults to \"\u00b0\".</p> </li> <li> <code>single_plot_export</code>               (<code>ExportSettings</code>)           \u2013            <p>Export settings for single plots.</p> </li> <li> <code>two_subplots_export</code>               (<code>ExportSettings</code>)           \u2013            <p>Export settings for two-subplot figures.</p> </li> <li> <code>three_subplots_export</code>               (<code>ExportSettings</code>)           \u2013            <p>Export settings for three-subplot figures.</p> </li> </ul>"},{"location":"api/core/settings/#trajectopy.core.settings.comparison_method_from_string","title":"comparison_method_from_string","text":"<pre><code>comparison_method_from_string(\n    string: str,\n) -&gt; ComparisonMethod\n</code></pre> <p>Converts string to ComparisonMethod.</p> <p>Parameters:</p> <ul> <li> <code>string</code>               (<code>str</code>)           \u2013            <p>String containing \"absolute\" or \"relative\"</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ComparisonMethod</code> (              <code>ComparisonMethod</code> )          \u2013            <p>ABSOLUTE, RELATIVE, or UNKNOWN</p> </li> </ul> Source code in <code>trajectopy\\core\\settings.py</code> <pre><code>def comparison_method_from_string(string: str) -&gt; ComparisonMethod:\n    \"\"\"Converts string to ComparisonMethod.\n\n    Args:\n        string: String containing \"absolute\" or \"relative\"\n\n    Returns:\n        ComparisonMethod: ABSOLUTE, RELATIVE, or UNKNOWN\n    \"\"\"\n    if \"absolute\" in string.lower():\n        return ComparisonMethod.ABSOLUTE\n\n    return ComparisonMethod.RELATIVE if \"relative\" in string.lower() else ComparisonMethod.UNKNOWN\n</code></pre>"},{"location":"api/core/trajectory/","title":"Trajectory","text":""},{"location":"api/core/trajectory/#trajectopy.core.trajectory","title":"trajectory","text":""},{"location":"api/core/trajectory/#trajectopy.core.trajectory.Trajectory","title":"Trajectory","text":"<pre><code>Trajectory(\n    positions: Positions,\n    rotations: Union[Rotations, None] = None,\n    timestamps: Union[ndarray, None] = None,\n    name: str = \"\",\n    path_lengths: Union[ndarray, None] = None,\n    velocity_xyz: Union[ndarray, None] = None,\n    sorting: Sorting = TIME,\n)\n</code></pre> <p>Class representing a trajectory containing synchronized position, orientation, and time data.</p> <p>Attributes:</p> <ul> <li> <code>positions</code>               (<code>Positions</code>)           \u2013            <p>Container for spatial coordinates and coordinate reference system (EPSG) data.</p> </li> <li> <code>rotations</code>               (<code>Rotations</code>)           \u2013            <p>Container for orientation data (quaternions), or None if not provided.</p> </li> <li> <code>timestamps</code>               (<code>ndarray</code>)           \u2013            <p>A 1D array of timestamps corresponding to each pose.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>An identifier string for the trajectory.</p> </li> <li> <code>path_lengths</code>               (<code>ndarray</code>)           \u2013            <p>A 1D array of cumulative path lengths starting from zero.</p> </li> <li> <code>sorting</code>               (<code>Sorting</code>)           \u2013            <p>The current sorting strategy (Sorting.TIME or Sorting.ARC_LENGTH).</p> </li> </ul> <p>Initialize a Trajectory object.</p> <p>Parameters:</p> <ul> <li> <code>positions</code>               (<code>Positions</code>)           \u2013            <p>Container for spatial coordinates and coordinate reference system (EPSG) data.</p> </li> <li> <code>rotations</code>               (<code>Rotations | None</code>, default:                   <code>None</code> )           \u2013            <p>Container for orientation data (quaternions). Defaults to None.</p> </li> <li> <code>timestamps</code>               (<code>ndarray | None</code>, default:                   <code>None</code> )           \u2013            <p>Array of timestamps. If None, a range index is used.</p> </li> <li> <code>name</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Name of the trajectory. Defaults to generic counter name.</p> </li> <li> <code>path_lengths</code>               (<code>Union[ndarray, None]</code>, default:                   <code>None</code> )           \u2013            <p>Pre-calculated path lengths. If None, they are computed from xyz.</p> </li> <li> <code>velocity_xyz</code>               (<code>Union[ndarray, None]</code>, default:                   <code>None</code> )           \u2013            <p>Pre-calculated 3D velocities. If None, they are computed via gradient.</p> </li> <li> <code>sorting</code>               (<code>Sorting</code>, default:                   <code>TIME</code> )           \u2013            <p>Definition of the sorting logic (TIME or ARC_LENGTH). Defaults to Sorting.TIME.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TrajectoryError</code>             \u2013            <p>If the number of positions and rotations do not match.</p> </li> </ul> Source code in <code>trajectopy\\core\\trajectory.py</code> <pre><code>def __init__(\n    self,\n    positions: Positions,\n    rotations: Union[Rotations, None] = None,\n    timestamps: Union[np.ndarray, None] = None,\n    name: str = \"\",\n    path_lengths: Union[np.ndarray, None] = None,\n    velocity_xyz: Union[np.ndarray, None] = None,\n    sorting: Sorting = Sorting.TIME,\n) -&gt; None:\n    \"\"\"\n    Initialize a Trajectory object.\n\n    Args:\n        positions (Positions): Container for spatial coordinates and coordinate reference system (EPSG) data.\n        rotations (Rotations | None, optional): Container for orientation data (quaternions). Defaults to None.\n        timestamps (np.ndarray | None, optional): Array of timestamps. If None, a range index is used.\n        name (str, optional): Name of the trajectory. Defaults to generic counter name.\n        path_lengths (Union[np.ndarray, None], optional): Pre-calculated path lengths. If None, they are computed from xyz.\n        velocity_xyz (Union[np.ndarray, None], optional): Pre-calculated 3D velocities. If None, they are computed via gradient.\n        sorting (Sorting, optional): Definition of the sorting logic (TIME or ARC_LENGTH). Defaults to Sorting.TIME.\n\n    Raises:\n        TrajectoryError: If the number of positions and rotations do not match.\n    \"\"\"\n    # check dimensions\n    if rotations is not None and len(positions) != len(rotations):\n        raise TrajectoryError(\n            f\"Number of positions ({len(positions)}) and rotations ({len(rotations)}) do not match!\"\n        )\n\n    self.sorting = sorting\n\n    # pose\n    self.positions = positions\n    self.rotations = rotations\n\n    if not isinstance(timestamps, np.ndarray):\n        timestamps = np.array(timestamps) if timestamps is not None else None\n\n    self.timestamps = np.arange(0, len(positions)) if timestamps is None else timestamps\n\n    if velocity_xyz is not None and len(velocity_xyz) == len(self.positions):\n        self._velocity_xyz = velocity_xyz\n    else:\n        self._velocity_xyz = gradient_3d(xyz=self.positions.xyz, tstamps=self.timestamps)\n        logger.info(\"Speeds were not provided or had wrong dimensions. Speeds were computed instead.\")\n\n    if path_lengths is not None and len(path_lengths) == len(self.positions):\n        self.path_lengths = path_lengths\n    else:\n        self.path_lengths = self.init_path_lengths()\n        logger.info(\"Path lengths were not provided or had wrong dimensions. Path lengths were computed instead.\")\n\n    self.name = name or f\"Trajectory {Trajectory._counter}\"\n\n    Trajectory._counter += 1\n</code></pre>"},{"location":"api/core/trajectory/#trajectopy.core.trajectory.Trajectory.has_orientation","title":"has_orientation  <code>property</code>","text":"<pre><code>has_orientation: bool\n</code></pre> <p>Returns True if valid rotation data is available.</p>"},{"location":"api/core/trajectory/#trajectopy.core.trajectory.Trajectory.is_unix_time","title":"is_unix_time  <code>property</code>","text":"<pre><code>is_unix_time: bool\n</code></pre> <p>Checks if the supplied trajectory has (likely) unix timestamps as seconds.</p>"},{"location":"api/core/trajectory/#trajectopy.core.trajectory.Trajectory.total_length","title":"total_length  <code>property</code>","text":"<pre><code>total_length: float\n</code></pre> <p>Returns the total cumulative path length of the trajectory in meters.</p>"},{"location":"api/core/trajectory/#trajectopy.core.trajectory.Trajectory.sort_switching_index","title":"sort_switching_index  <code>property</code>","text":"<pre><code>sort_switching_index: ndarray\n</code></pre> <p>Returns an array of indices that would switch the current sorting (e.g., unsort the data).</p>"},{"location":"api/core/trajectory/#trajectopy.core.trajectory.Trajectory.sorting_index","title":"sorting_index  <code>property</code>","text":"<pre><code>sorting_index: ndarray\n</code></pre> <p>Returns the indices used to sort the trajectory based on the current <code>sorting</code> attribute (Time or Path Length).</p>"},{"location":"api/core/trajectory/#trajectopy.core.trajectory.Trajectory.index","title":"index  <code>property</code>","text":"<pre><code>index: ndarray\n</code></pre> <p>Returns the independent variable currently parameterizing the trajectory. This is either the Timestamp vector or the Path Length vector, depending on <code>self.sorting</code>.</p>"},{"location":"api/core/trajectory/#trajectopy.core.trajectory.Trajectory.datetimes","title":"datetimes  <code>property</code>","text":"<pre><code>datetimes: ndarray\n</code></pre> <p>Returns the timestamps converted to Pandas datetime objects (unit='s').</p>"},{"location":"api/core/trajectory/#trajectopy.core.trajectory.Trajectory.index_unit","title":"index_unit  <code>property</code>","text":"<pre><code>index_unit: str\n</code></pre> <p>Returns the unit string of the current index ('s' for Time, 'm' for Path Length).</p>"},{"location":"api/core/trajectory/#trajectopy.core.trajectory.Trajectory.index_label","title":"index_label  <code>property</code>","text":"<pre><code>index_label: str\n</code></pre> <p>Returns the label string of the current index (e.g., 'time [s]').</p>"},{"location":"api/core/trajectory/#trajectopy.core.trajectory.Trajectory.data_rate","title":"data_rate  <code>property</code>","text":"<pre><code>data_rate: float\n</code></pre> <p>Calculates the average data rate (frequency in Hz) based on timestamp differences.</p>"},{"location":"api/core/trajectory/#trajectopy.core.trajectory.Trajectory.velocity_xyz","title":"velocity_xyz  <code>property</code> <code>writable</code>","text":"<pre><code>velocity_xyz: ndarray\n</code></pre> <p>Returns the 3D velocity vectors. If not set manually, they are computed via gradient of the positions over time.</p>"},{"location":"api/core/trajectory/#trajectopy.core.trajectory.Trajectory.absolute_velocity","title":"absolute_velocity  <code>property</code>","text":"<pre><code>absolute_velocity: ndarray\n</code></pre> <p>Returns the norm (magnitude) of the 3D velocity vectors.</p>"},{"location":"api/core/trajectory/#trajectopy.core.trajectory.Trajectory.xyz","title":"xyz  <code>property</code>","text":"<pre><code>xyz: ndarray\n</code></pre> <p>Returns the XYZ coordinates sorted according to the current <code>sorting</code> strategy. Note: This differs from <code>self.positions.xyz</code>, which retains the original order.</p>"},{"location":"api/core/trajectory/#trajectopy.core.trajectory.Trajectory.quat","title":"quat  <code>property</code>","text":"<pre><code>quat: ndarray\n</code></pre> <p>Returns the quaternions sorted according to the current <code>sorting</code> strategy. Returns zeros if no rotations are present.</p>"},{"location":"api/core/trajectory/#trajectopy.core.trajectory.Trajectory.rpy","title":"rpy  <code>property</code>","text":"<pre><code>rpy: ndarray\n</code></pre> <p>Returns the Roll-Pitch-Yaw angles sorted according to the current <code>sorting</code> strategy.</p>"},{"location":"api/core/trajectory/#trajectopy.core.trajectory.Trajectory.se3","title":"se3  <code>property</code> <code>writable</code>","text":"<pre><code>se3: List[ndarray]\n</code></pre> <p>Returns a list of SE3 poses (4x4 homogeneous transformation matrices).</p>"},{"location":"api/core/trajectory/#trajectopy.core.trajectory.Trajectory.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(\n    filename: str, io_stream: bool = False\n) -&gt; Trajectory\n</code></pre> <p>Create a trajectory instance from a file.</p> <p>The file is expected to be a CSV-like format. It handles extraction of timestamps, xyz positions, rotations, path lengths, and velocities via <code>ascii</code> trajectory reader.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>Path to the file or string content if io_stream is True.</p> </li> <li> <code>io_stream</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, <code>filename</code> is treated as the raw string content                         of the file/stream. Defaults to False.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Trajectory</code> (              <code>Trajectory</code> )          \u2013            <p>The loaded trajectory object.</p> </li> </ul> Source code in <code>trajectopy\\core\\trajectory.py</code> <pre><code>@classmethod\ndef from_file(cls, filename: str, io_stream: bool = False) -&gt; \"Trajectory\":\n    \"\"\"\n    Create a trajectory instance from a file.\n\n    The file is expected to be a CSV-like format. It handles extraction of\n    timestamps, xyz positions, rotations, path lengths, and velocities via `ascii` trajectory reader.\n\n    Args:\n        filename (str): Path to the file or string content if io_stream is True.\n        io_stream (bool, optional): If True, `filename` is treated as the raw string content\n                                    of the file/stream. Defaults to False.\n\n    Returns:\n        Trajectory: The loaded trajectory object.\n    \"\"\"\n    if io_stream:\n        header_data, trajectory_data = ascii.read_string(filename, dtype=object)\n    else:\n        header_data, trajectory_data = ascii.read_data(filename, dtype=object)\n\n    tstamps = ascii.extract_trajectory_timestamps(header_data=header_data, trajectory_data=trajectory_data)\n    positions = ascii.extract_trajectory_positions(header_data=header_data, trajectory_data=trajectory_data)\n    path_lengths = ascii.extract_trajectory_path_lengths(header_data=header_data, trajectory_data=trajectory_data)\n    velocity_xyz = ascii.extract_trajectory_velocity_xyz(header_data=header_data, trajectory_data=trajectory_data)\n    rotations = ascii.extract_trajectory_rotations(header_data=header_data, trajectory_data=trajectory_data)\n\n    return Trajectory(\n        timestamps=tstamps,\n        positions=positions,\n        rotations=rotations,\n        name=header_data.name,\n        path_lengths=path_lengths,\n        velocity_xyz=velocity_xyz,\n        sorting=Sorting.from_str(header_data.sorting),\n    )\n</code></pre>"},{"location":"api/core/trajectory/#trajectopy.core.trajectory.Trajectory.from_arrays","title":"from_arrays  <code>classmethod</code>","text":"<pre><code>from_arrays(\n    xyz: ndarray,\n    quat: ndarray | None = None,\n    rpy: ndarray | None = None,\n    epsg: int = 0,\n    **kwargs\n) -&gt; Trajectory\n</code></pre> <p>Factory: Handles creation from raw numpy arrays.</p> Source code in <code>trajectopy\\core\\trajectory.py</code> <pre><code>@classmethod\ndef from_arrays(\n    cls, xyz: np.ndarray, quat: np.ndarray | None = None, rpy: np.ndarray | None = None, epsg: int = 0, **kwargs\n) -&gt; \"Trajectory\":\n    \"\"\"Factory: Handles creation from raw numpy arrays.\"\"\"\n\n    pos_obj = Positions(xyz=xyz, epsg=epsg)\n\n    rot_obj = None\n    if quat is not None and rpy is not None:\n        raise TrajectoryError(\"Provide quat OR rpy, not both.\")\n\n    if quat is not None:\n        rot_obj = Rotations.from_quat(quat)\n    elif rpy is not None:\n        rot_obj = Rotations.from_euler(seq=\"xyz\", angles=rpy)\n\n    return cls(positions=pos_obj, rotations=rot_obj, **kwargs)\n</code></pre>"},{"location":"api/core/trajectory/#trajectopy.core.trajectory.Trajectory.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Returns a formatted string summary of the trajectory, including name, length, EPSG, and data rate.</p> Source code in <code>trajectopy\\core\\trajectory.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    Returns a formatted string summary of the trajectory, including name, length, EPSG, and data rate.\n    \"\"\"\n    width = 24\n    return (\n        f\"\\n _______________________________________________________\\n\"\n        f\"| ------------------ Trajectory Info ------------------ |\\n\"\n        f\"| Name:                         {self.name:&lt;{width}}|\\n\"\n        f\"| Number of poses:              {len(self):&lt;{width}}|\\n\"\n        f\"| Orientation available:        {'yes' if self.has_orientation else 'no':&lt;{width}}|\\n\"\n        f\"| EPSG:                         {self.positions.epsg:&lt;{width}}|\\n\"\n        f\"| Length [m]:                   {self.total_length:&lt;{width}.3f}|\\n\"\n        f\"| Data rate [Hz]:               {self.data_rate:&lt;{width}.3f}|\\n\"\n        f\"| Function of:                  {self.index_label:&lt;{width}}|\\n\"\n        f\"|_______________________________________________________|\\n\"\n    )\n</code></pre>"},{"location":"api/core/trajectory/#trajectopy.core.trajectory.Trajectory.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Returns the number of poses in the trajectory.</p> Source code in <code>trajectopy\\core\\trajectory.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Returns the number of poses in the trajectory.\"\"\"\n    return len(self.positions.xyz)\n</code></pre>"},{"location":"api/core/trajectory/#trajectopy.core.trajectory.Trajectory.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Trajectory) -&gt; bool\n</code></pre> <p>Checks equality between two trajectories using <code>np.allclose</code> for numerical arrays. Compares positions, rotations, timestamps, path lengths, velocities, and names.</p> Source code in <code>trajectopy\\core\\trajectory.py</code> <pre><code>def __eq__(self, other: \"Trajectory\") -&gt; bool:\n    \"\"\"\n    Checks equality between two trajectories using `np.allclose` for numerical arrays.\n    Compares positions, rotations, timestamps, path lengths, velocities, and names.\n    \"\"\"\n    if self.rotations is not None and other.rotations is not None:\n        rot_equal = np.allclose(self.rotations.as_quat(), other.rotations.as_quat())\n    elif self.rotations is None and other.rotations is None:\n        rot_equal = True\n    else:\n        rot_equal = False\n\n    return (\n        np.allclose(self.positions.xyz, other.positions.xyz)\n        and rot_equal\n        and np.allclose(self.timestamps, other.timestamps)\n        and np.allclose(self.path_lengths, other.path_lengths)\n        and np.allclose(self._velocity_xyz, other._velocity_xyz)\n        and self.name == other.name\n    )\n</code></pre>"},{"location":"api/core/trajectory/#trajectopy.core.trajectory.Trajectory.copy","title":"copy","text":"<pre><code>copy() -&gt; Trajectory\n</code></pre> <p>Returns a deep copy of the trajectory instance.</p> Source code in <code>trajectopy\\core\\trajectory.py</code> <pre><code>def copy(self) -&gt; \"Trajectory\":\n    \"\"\"Returns a deep copy of the trajectory instance.\"\"\"\n    return copy.deepcopy(self)\n</code></pre>"},{"location":"api/core/trajectory/#trajectopy.core.trajectory.Trajectory.init_path_lengths","title":"init_path_lengths","text":"<pre><code>init_path_lengths()\n</code></pre> <p>Computes cumulative path lengths based on Euclidean distances between consecutive local coordinates.</p> Source code in <code>trajectopy\\core\\trajectory.py</code> <pre><code>def init_path_lengths(self):\n    \"\"\"Computes cumulative path lengths based on Euclidean distances between consecutive local coordinates.\"\"\"\n    return lengths_from_xyz(self.positions.to_local(inplace=False).xyz)\n</code></pre>"},{"location":"api/core/trajectory/#trajectopy.core.trajectory.Trajectory.overlaps_with","title":"overlaps_with","text":"<pre><code>overlaps_with(other: Trajectory) -&gt; bool\n</code></pre> <p>Checks if the time span of this trajectory overlaps with another.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>Trajectory</code>)           \u2013            <p>The trajectory to compare against.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the time ranges overlap, False otherwise.</p> </li> </ul> Source code in <code>trajectopy\\core\\trajectory.py</code> <pre><code>def overlaps_with(self, other: \"Trajectory\") -&gt; bool:\n    \"\"\"\n    Checks if the time span of this trajectory overlaps with another.\n\n    Args:\n        other (Trajectory): The trajectory to compare against.\n\n    Returns:\n        bool: True if the time ranges overlap, False otherwise.\n    \"\"\"\n    start_test = self.timestamps[0]\n    end_test = self.timestamps[-1]\n    start_ref = other.timestamps[0]\n    end_ref = other.timestamps[-1]\n\n    return (start_test &lt;= end_ref and end_test &gt;= start_ref) or (start_ref &lt;= end_test and end_ref &gt;= start_test)\n</code></pre>"},{"location":"api/core/trajectory/#trajectopy.core.trajectory.Trajectory.crop","title":"crop","text":"<pre><code>crop(\n    t_start: float,\n    t_end: float,\n    inverse: bool = False,\n    inplace: bool = True,\n) -&gt; Trajectory\n</code></pre> <p>Crops (or cuts) the trajectory based on a time window.</p> <p>Parameters:</p> <ul> <li> <code>t_start</code>               (<code>float</code>)           \u2013            <p>Start timestamp of the window.</p> </li> <li> <code>t_end</code>               (<code>float</code>)           \u2013            <p>End timestamp of the window.</p> </li> <li> <code>inverse</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, removes data inside the window (cutting).                       If False, keeps data inside the window (cropping). Defaults to False.</p> </li> <li> <code>inplace</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, modifies self. If False, returns a new instance. Defaults to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Trajectory</code> (              <code>Trajectory</code> )          \u2013            <p>The modified or new trajectory instance.</p> </li> </ul> Source code in <code>trajectopy\\core\\trajectory.py</code> <pre><code>def crop(self, t_start: float, t_end: float, inverse: bool = False, inplace: bool = True) -&gt; \"Trajectory\":\n    \"\"\"\n    Crops (or cuts) the trajectory based on a time window.\n\n    Args:\n        t_start (float): Start timestamp of the window.\n        t_end (float): End timestamp of the window.\n        inverse (bool, optional): If True, removes data *inside* the window (cutting).\n                                  If False, keeps data *inside* the window (cropping). Defaults to False.\n        inplace (bool, optional): If True, modifies self. If False, returns a new instance. Defaults to True.\n\n    Returns:\n        Trajectory: The modified or new trajectory instance.\n    \"\"\"\n    # filter to t_start and t_end\n    if inverse:\n        filt = [not t_start &lt;= tstamps &lt;= t_end for tstamps in self.timestamps]\n    else:\n        filt = [t_start &lt;= tstamps &lt;= t_end for tstamps in self.timestamps]\n\n    return self.mask(mask=filt, inplace=inplace)\n</code></pre>"},{"location":"api/core/trajectory/#trajectopy.core.trajectory.Trajectory.intersect","title":"intersect","text":"<pre><code>intersect(\n    timestamps: ndarray,\n    max_gap_size: float = 10.0,\n    inplace: bool = True,\n) -&gt; Trajectory\n</code></pre> <p>Filters the trajectory to overlap with a reference timestamp vector.</p> <p>This method finds the common time span between self and the reference <code>timestamps</code>, crops self to that span, and then filters points that are either exact matches or exist within valid gaps defined by <code>max_gap_size</code>.</p> <p>Parameters:</p> <ul> <li> <code>timestamps</code>               (<code>ndarray</code>)           \u2013            <p>The reference timestamps to intersect with.</p> </li> <li> <code>max_gap_size</code>               (<code>float</code>, default:                   <code>10.0</code> )           \u2013            <p>The maximum allowed time gap (in seconds) between                             reference timestamps to include trajectory points. Defaults to 10.0.</p> </li> <li> <code>inplace</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, modifies self. Defaults to True.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the time spans do not overlap.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Trajectory</code> (              <code>Trajectory</code> )          \u2013            <p>The intersected trajectory.</p> </li> </ul> Source code in <code>trajectopy\\core\\trajectory.py</code> <pre><code>def intersect(self, timestamps: np.ndarray, max_gap_size: float = 10.0, inplace: bool = True) -&gt; \"Trajectory\":\n    \"\"\"\n    Filters the trajectory to overlap with a reference timestamp vector.\n\n    This method finds the common time span between self and the reference `timestamps`,\n    crops self to that span, and then filters points that are either exact matches\n    or exist within valid gaps defined by `max_gap_size`.\n\n    Args:\n        timestamps (np.ndarray): The reference timestamps to intersect with.\n        max_gap_size (float, optional): The maximum allowed time gap (in seconds) between\n                                        reference timestamps to include trajectory points. Defaults to 10.0.\n        inplace (bool, optional): If True, modifies self. Defaults to True.\n\n    Raises:\n        ValueError: If the time spans do not overlap.\n\n    Returns:\n        Trajectory: The intersected trajectory.\n    \"\"\"\n    traj_self = self if inplace else self.copy()\n    time_span = common_time_span(tstamps1=timestamps, tstamps2=traj_self.timestamps)\n\n    if time_span is None:\n        raise ValueError(\"intersect_both: Timespans do not overlap!\")\n\n    traj_self.crop(t_start=time_span[0], t_end=time_span[1])\n\n    tstamps_sorted = np.sort(timestamps)\n    lower_neighbor_list = np.searchsorted(tstamps_sorted, traj_self.timestamps, side=\"right\") - 1\n\n    filter_index = [\n        idx\n        for idx, (tstamp, lower_neighbor) in enumerate(zip(traj_self.timestamps, lower_neighbor_list))\n        if (\n            tstamps_sorted[lower_neighbor] == tstamp\n            or (tstamps_sorted[lower_neighbor + 1] - tstamps_sorted[lower_neighbor]) &lt;= max_gap_size\n        )\n    ]\n    traj_self.mask(np.array(filter_index, dtype=int))\n\n    return traj_self\n</code></pre>"},{"location":"api/core/trajectory/#trajectopy.core.trajectory.Trajectory.mask","title":"mask","text":"<pre><code>mask(\n    mask: Union[list, ndarray], inplace: bool = True\n) -&gt; Trajectory\n</code></pre> <p>Applies a boolean mask or index array to filter all trajectory components.</p> <p>Filtered components include: timestamps, positions, rotations, path lengths, and velocities.</p> <p>Parameters:</p> <ul> <li> <code>mask</code>               (<code>Union[list, ndarray]</code>)           \u2013            <p>Boolean array or list of indices to keep.</p> </li> <li> <code>inplace</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, modifies self. Defaults to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Trajectory</code> (              <code>Trajectory</code> )          \u2013            <p>The masked trajectory.</p> </li> </ul> Source code in <code>trajectopy\\core\\trajectory.py</code> <pre><code>def mask(self, mask: Union[list, np.ndarray], inplace: bool = True) -&gt; \"Trajectory\":\n    \"\"\"\n    Applies a boolean mask or index array to filter all trajectory components.\n\n    Filtered components include: timestamps, positions, rotations, path lengths, and velocities.\n\n    Args:\n        mask (Union[list, np.ndarray]): Boolean array or list of indices to keep.\n        inplace (bool, optional): If True, modifies self. Defaults to True.\n\n    Returns:\n        Trajectory: The masked trajectory.\n    \"\"\"\n    traj_self = self if inplace else self.copy()\n\n    traj_self.timestamps = traj_self.timestamps[mask]\n    traj_self.positions.xyz = traj_self.positions.xyz[mask, :]\n\n    if traj_self.rotations:\n        quat_filtered = traj_self.rotations.as_quat()[mask, :]\n        traj_self.rotations = Rotations.from_quat(quat_filtered) if len(quat_filtered) &gt; 0 else None\n\n    traj_self.path_lengths = traj_self.path_lengths[mask]\n\n    if traj_self.velocity_xyz is not None:\n        traj_self.velocity_xyz = traj_self.velocity_xyz[mask]\n\n    return traj_self\n</code></pre>"},{"location":"api/core/trajectory/#trajectopy.core.trajectory.Trajectory.transform","title":"transform","text":"<pre><code>transform(\n    transformation: ndarray, inplace: bool = True\n) -&gt; Trajectory\n</code></pre> <p>Applies a rigid body transformation to the trajectory poses.</p> <p>Parameters:</p> <ul> <li> <code>transformation</code>               (<code>ndarray</code>)           \u2013            <p>A 4x4 homogeneous transformation matrix.</p> </li> <li> <code>inplace</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, modifies self. Defaults to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Trajectory</code> (              <code>Trajectory</code> )          \u2013            <p>The transformed trajectory.</p> </li> </ul> Source code in <code>trajectopy\\core\\trajectory.py</code> <pre><code>def transform(self, transformation: np.ndarray, inplace: bool = True) -&gt; \"Trajectory\":\n    \"\"\"\n    Applies a rigid body transformation to the trajectory poses.\n\n    Args:\n        transformation (np.ndarray): A 4x4 homogeneous transformation matrix.\n        inplace (bool, optional): If True, modifies self. Defaults to True.\n\n    Returns:\n        Trajectory: The transformed trajectory.\n    \"\"\"\n    traj_self = self if inplace else self.copy()\n    traj_self.se3 = [np.dot(transformation, p) for p in traj_self.se3]\n    return traj_self\n</code></pre>"},{"location":"api/core/trajectory/#trajectopy.core.trajectory.Trajectory.to_dataframe","title":"to_dataframe","text":"<pre><code>to_dataframe(sort_by: str = '') -&gt; DataFrame\n</code></pre> <p>Exports the trajectory to a Pandas DataFrame.</p> <p>Columns usually include: time, path_length, pos_x, pos_y, pos_z, speed_x, speed_y, speed_z, and rotation columns (rot_x/y/z/w) if available.</p> <p>Parameters:</p> <ul> <li> <code>sort_by</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Column name to sort by. If empty, uses <code>self.sorting</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>pd.DataFrame: A dataframe containing the trajectory data.</p> </li> </ul> Source code in <code>trajectopy\\core\\trajectory.py</code> <pre><code>def to_dataframe(self, sort_by: str = \"\") -&gt; pd.DataFrame:\n    \"\"\"\n    Exports the trajectory to a Pandas DataFrame.\n\n    Columns usually include: time, path_length, pos_x, pos_y, pos_z, speed_x, speed_y, speed_z,\n    and rotation columns (rot_x/y/z/w) if available.\n\n    Args:\n        sort_by (str, optional): Column name to sort by. If empty, uses `self.sorting`.\n\n    Returns:\n        pd.DataFrame: A dataframe containing the trajectory data.\n    \"\"\"\n    sort_by = sort_by or self.sorting\n    if self.rotations:\n        dataframe = pd.DataFrame(\n            np.c_[\n                self.timestamps, self.path_lengths, self.positions.xyz, self.rotations.as_quat(), self.velocity_xyz\n            ],\n            columns=[\n                \"time\",\n                \"path_length\",\n                \"pos_x\",\n                \"pos_y\",\n                \"pos_z\",\n                \"rot_x\",\n                \"rot_y\",\n                \"rot_z\",\n                \"rot_w\",\n                \"speed_x\",\n                \"speed_y\",\n                \"speed_z\",\n            ],\n        )\n    else:\n        dataframe = pd.DataFrame(\n            np.c_[self.timestamps, self.path_lengths, self.positions.xyz, self.velocity_xyz],\n            columns=[\"time\", \"path_length\", \"pos_x\", \"pos_y\", \"pos_z\", \"speed_x\", \"speed_y\", \"speed_z\"],\n        )\n\n    return dataframe.sort_values(by=sort_by)\n</code></pre>"},{"location":"api/core/trajectory/#trajectopy.core.trajectory.Trajectory.to_string","title":"to_string","text":"<pre><code>to_string() -&gt; str\n</code></pre> <p>Serializes the trajectory to a CSV-formatted string with metadata headers.</p> <p>Headers included: #epsg, #name, #nframe, #sorting, #fields.</p> Source code in <code>trajectopy\\core\\trajectory.py</code> <pre><code>def to_string(self) -&gt; str:\n    \"\"\"\n    Serializes the trajectory to a CSV-formatted string with metadata headers.\n\n    Headers included: #epsg, #name, #nframe, #sorting, #fields.\n    \"\"\"\n\n    def write_header() -&gt; str:\n        fields = \"t,l,px,py,pz,vx,vy,vz\" if self.rotations is None else \"t,l,px,py,pz,qx,qy,qz,qw,vx,vy,vz\"\n        header = [\n            f\"#epsg {self.positions.epsg}\",\n            f\"#name {self.name}\",\n            \"#nframe enu\",\n            f\"#sorting {self.sorting.value}\",\n            f\"#fields {fields}\",\n        ]\n        return \"\\n\".join(header) + \"\\n\"\n\n    if self.rotations is None:\n        trajectory_data = np.c_[self.timestamps, self.path_lengths, self.positions.xyz, self.velocity_xyz]\n    else:\n        trajectory_data = np.c_[\n            self.timestamps,\n            self.path_lengths,\n            self.positions.xyz,\n            self.rotations.as_quat(),\n            self.velocity_xyz,\n        ]\n\n    output = io.StringIO()\n    output.write(write_header())\n    pd.DataFrame(trajectory_data).to_csv(output, header=False, index=False, float_format=\"%.9f\")\n\n    return output.getvalue()\n</code></pre>"},{"location":"api/core/trajectory/#trajectopy.core.trajectory.Trajectory.to_file","title":"to_file","text":"<pre><code>to_file(filename: str, mode: str = 'w') -&gt; None\n</code></pre> <p>Writes the trajectory to an ASCII file using the format defined in <code>to_string</code>.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>The output file path.</p> </li> <li> <code>mode</code>               (<code>str</code>, default:                   <code>'w'</code> )           \u2013            <p>File open mode. Defaults to \"w\".</p> </li> </ul> Source code in <code>trajectopy\\core\\trajectory.py</code> <pre><code>def to_file(self, filename: str, mode: str = \"w\") -&gt; None:\n    \"\"\"\n    Writes the trajectory to an ASCII file using the format defined in `to_string`.\n\n    Args:\n        filename (str): The output file path.\n        mode (str, optional): File open mode. Defaults to \"w\".\n    \"\"\"\n    with open(filename, mode=mode, newline=\"\\n\", encoding=\"utf-8\") as file:\n        file.write(self.to_string())\n</code></pre>"},{"location":"api/core/trajectory/#trajectopy.core.trajectory.Trajectory.to_kml","title":"to_kml","text":"<pre><code>to_kml(filename: str, precision: float = 1e-06) -&gt; str\n</code></pre> <p>Exports the trajectory to a Google Earth KML file.</p> <p>Requires the trajectory to have a valid EPSG code so it can be converted to WGS84 (EPSG:4326).</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>The output filename (e.g., \"track.kml\").</p> </li> <li> <code>precision</code>               (<code>float</code>, default:                   <code>1e-06</code> )           \u2013            <p>Coordinate precision in degrees for rounding/simplification. Defaults to 1e-6.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the trajectory does not have a known EPSG code.</p> </li> </ul> Source code in <code>trajectopy\\core\\trajectory.py</code> <pre><code>def to_kml(self, filename: str, precision: float = 1e-6) -&gt; str:\n    \"\"\"\n    Exports the trajectory to a Google Earth KML file.\n\n    Requires the trajectory to have a valid EPSG code so it can be converted to WGS84 (EPSG:4326).\n\n    Args:\n        filename (str): The output filename (e.g., \"track.kml\").\n        precision (float, optional): Coordinate precision in degrees for rounding/simplification. Defaults to 1e-6.\n\n    Raises:\n        ValueError: If the trajectory does not have a known EPSG code.\n    \"\"\"\n    traj = self.copy()\n    if traj.positions.local_transformer is None:\n        raise ValueError(\n            \"Trajectory must be defined in a well-known coordinate system (EPSG code) to be exported to KML. \"\n        )\n    traj.positions.to_epsg(4326)\n\n    traj.positions = traj.positions.round_to(precision)\n    _, indices = np.unique(traj.positions.xyz[:, 0:2], return_index=True, axis=0)\n    traj.mask(np.sort(indices))\n\n    kml_file = ET.Element(\"kml\", xmlns=\"http://earth.google.com/kml/2.1\")\n    document = ET.SubElement(kml_file, \"Document\")\n\n    placemark = ET.SubElement(document, \"Placemark\")\n    name = ET.SubElement(placemark, \"name\")\n    name.text = traj.name\n\n    style = ET.SubElement(placemark, \"Style\")\n    line_style = ET.SubElement(style, \"LineStyle\")\n    color = ET.SubElement(line_style, \"color\")\n    color.text = \"ff0000ff\"\n    width = ET.SubElement(line_style, \"width\")\n    width.text = \"2\"\n\n    line_string = ET.SubElement(placemark, \"LineString\")\n    coordinates = ET.SubElement(line_string, \"coordinates\")\n\n    coordinates.text = \"\\n\".join(f\"  {pos[1]:.9f},{pos[0]:.9f},{0.00:.3f}\" for pos in traj.positions.xyz)\n\n    tree = ET.ElementTree(kml_file)\n    ET.indent(tree, space=\"\", level=0)\n    tree.write(filename, encoding=\"utf-8\", xml_declaration=True)\n</code></pre>"},{"location":"api/processing/alignment/","title":"Alignment","text":""},{"location":"api/processing/alignment/#trajectopy.processing.alignment","title":"alignment","text":""},{"location":"api/processing/alignment/#trajectopy.processing.alignment.estimate_alignment","title":"estimate_alignment","text":"<pre><code>estimate_alignment(\n    trajectory: Trajectory,\n    other: Trajectory,\n    alignment_settings: AlignmentSettings = AlignmentSettings(),\n    matching_settings: MatchingSettings = MatchingSettings(),\n) -&gt; AlignmentResult\n</code></pre> <p>Estimates the alignment between two trajectories.</p> <p>Performs Helmert, Leverarm, and Time shift estimation depending on the configuration. This function only estimates the alignment parameters, it does not apply them to the trajectory.</p> <p>Parameters:</p> <ul> <li> <code>trajectory</code>               (<code>Trajectory</code>)           \u2013            <p>Trajectory to align.</p> </li> <li> <code>other</code>               (<code>Trajectory</code>)           \u2013            <p>Reference trajectory to align to.</p> </li> <li> <code>alignment_settings</code>               (<code>AlignmentSettings</code>, default:                   <code>AlignmentSettings()</code> )           \u2013            <p>Settings for the alignment process. Defaults to AlignmentSettings().</p> </li> <li> <code>matching_settings</code>               (<code>MatchingSettings</code>, default:                   <code>MatchingSettings()</code> )           \u2013            <p>Settings for the matching process. Defaults to MatchingSettings().</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AlignmentResult</code> (              <code>AlignmentResult</code> )          \u2013            <p>Result of the alignment process.</p> </li> </ul> Source code in <code>trajectopy\\processing\\alignment.py</code> <pre><code>def estimate_alignment(\n    trajectory: Trajectory,\n    other: Trajectory,\n    alignment_settings: settings.AlignmentSettings = settings.AlignmentSettings(),\n    matching_settings: settings.MatchingSettings = settings.MatchingSettings(),\n) -&gt; AlignmentResult:\n    \"\"\"Estimates the alignment between two trajectories.\n\n    Performs Helmert, Leverarm, and Time shift estimation depending on the configuration.\n    This function only estimates the alignment parameters, it does not apply them to the trajectory.\n\n    Args:\n        trajectory (Trajectory): Trajectory to align.\n        other (Trajectory): Reference trajectory to align to.\n        alignment_settings (AlignmentSettings, optional): Settings for the alignment process. Defaults to AlignmentSettings().\n        matching_settings (MatchingSettings, optional): Settings for the matching process. Defaults to MatchingSettings().\n\n    Returns:\n        AlignmentResult: Result of the alignment process.\n    \"\"\"\n    logger.info(\"Aligning trajectory positions ...\")\n\n    alignment_data = AlignmentData(\n        traj_from=trajectory,\n        traj_to=other,\n        alignment_settings=alignment_settings,\n        matching_settings=matching_settings,\n    )\n    ghm_alignment = AlignmentEstimator(alignment_data=alignment_data)\n    estimated_parameters = ghm_alignment.estimate_parameters()\n\n    if (\n        alignment_data.traj_from.rotations is not None\n        and alignment_data.traj_to.rotations is not None\n        and alignment_settings.estimation_settings.sensor_rotation\n    ):\n        pre_aligned_trajectory = alignment_data.traj_from.transform(estimated_parameters.sim3_matrix, inplace=False)\n        logger.info(\"Aligning rotations ...\")\n        sensor_rot_params = align_rotations(\n            rot_from=pre_aligned_trajectory.rotations, rot_to=alignment_data.traj_to.rotations\n        )\n        print(sensor_rot_params)\n    else:\n        sensor_rot_params = SensorRotationParameters(enabled=False)\n\n    return AlignmentResult(\n        name=f\"{alignment_data.traj_from.name} to {alignment_data.traj_to.name}\",\n        position_parameters=estimated_parameters,\n        rotation_parameters=sensor_rot_params,\n        estimation_of=ghm_alignment.settings.estimation_settings,\n        converged=ghm_alignment.has_results,\n    )\n</code></pre>"},{"location":"api/processing/alignment/#trajectopy.processing.alignment.apply_alignment","title":"apply_alignment","text":"<pre><code>apply_alignment(\n    trajectory: Trajectory,\n    alignment_result: AlignmentResult,\n    inplace: bool = True,\n) -&gt; Trajectory\n</code></pre> <p>Transforms trajectory using alignment parameters.</p> <p>After computing the alignment parameters needed to align two trajectories, they can be applied to arbitrary trajectories.</p> <p>Parameters:</p> <ul> <li> <code>trajectory</code>               (<code>Trajectory</code>)           \u2013            <p>Trajectory to apply alignment to.</p> </li> <li> <code>alignment_result</code>               (<code>AlignmentResult</code>)           \u2013            <p>Alignment result containing transformation parameters.</p> </li> <li> <code>inplace</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Perform in-place. Defaults to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Trajectory</code> (              <code>Trajectory</code> )          \u2013            <p>Aligned trajectory.</p> </li> </ul> Source code in <code>trajectopy\\processing\\alignment.py</code> <pre><code>def apply_alignment(trajectory: Trajectory, alignment_result: AlignmentResult, inplace: bool = True) -&gt; \"Trajectory\":\n    \"\"\"Transforms trajectory using alignment parameters.\n\n    After computing the alignment parameters needed to align two trajectories, they can be\n    applied to arbitrary trajectories.\n\n    Args:\n        trajectory (Trajectory): Trajectory to apply alignment to.\n        alignment_result (AlignmentResult): Alignment result containing transformation parameters.\n        inplace (bool, optional): Perform in-place. Defaults to True.\n\n    Returns:\n        Trajectory: Aligned trajectory.\n    \"\"\"\n\n    def _prepare_alignment_application(\n        trajectory: Trajectory, alignment_parameters: AlignmentParameters\n    ) -&gt; Tuple[float, ...]:\n        if trajectory.rotations is not None:\n            rpy = trajectory.rotations.as_euler(\"xyz\", degrees=False)\n            euler_x, euler_y, euler_z = rpy[:, 0], rpy[:, 1], rpy[:, 2]\n            lever_x, lever_y, lever_z = (\n                alignment_parameters.lever_x.value,\n                alignment_parameters.lever_y.value,\n                alignment_parameters.lever_z.value,\n            )\n        else:\n            logger.warning(\"Trajectory has no orientations. Cannot apply leverarm.\")\n            euler_x, euler_y, euler_z = 0, 0, 0\n            lever_x, lever_y, lever_z = 0, 0, 0\n\n        return euler_x, euler_y, euler_z, lever_x, lever_y, lever_z\n\n    trajectory = trajectory if inplace else trajectory.copy()\n    has_orientations = trajectory.has_orientation\n\n    # leverarm and time\n    (\n        euler_x,\n        euler_y,\n        euler_z,\n        lever_x,\n        lever_y,\n        lever_z,\n    ) = _prepare_alignment_application(trajectory, alignment_result.position_parameters)\n\n    speed_3d = trajectory.velocity_xyz\n    speed_x, speed_y, speed_z = speed_3d[:, 0], speed_3d[:, 1], speed_3d[:, 2]\n\n    trafo_x, trafo_y, trafo_z = leverarm_time_component(\n        euler_x=euler_x,\n        euler_y=euler_y,\n        euler_z=euler_z,\n        lever_x=lever_x,\n        lever_y=lever_y,\n        lever_z=lever_z,\n        time_shift=alignment_result.position_parameters.time_shift.value,\n        speed_x=speed_x,\n        speed_y=speed_y,\n        speed_z=speed_z,\n    )\n    trajectory.positions.xyz += np.c_[trafo_x, trafo_y, trafo_z]\n\n    # similiarity transformation\n    trajectory.transform(alignment_result.position_parameters.sim3_matrix)\n\n    logger.info(\"Applied alignment parameters to positions.\")\n\n    # sensor orientation\n    if trajectory.rotations is not None:\n        trajectory.rotations = alignment_result.rotation_parameters.rotation_set * trajectory.rotations\n        logger.info(\"Applied alignment parameters to orientations.\")\n\n    if not has_orientations:\n        trajectory.rotations = None\n\n    return trajectory\n</code></pre>"},{"location":"api/processing/alignment/#trajectopy.processing.alignment.adopt_first_pose","title":"adopt_first_pose","text":"<pre><code>adopt_first_pose(\n    trajectory: Trajectory,\n    other: Trajectory,\n    inplace: bool = True,\n) -&gt; Trajectory\n</code></pre> <p>Transform trajectory so that the first pose is identical in both.</p> <p>Parameters:</p> <ul> <li> <code>trajectory</code>               (<code>Trajectory</code>)           \u2013            <p>Trajectory to transform.</p> </li> <li> <code>other</code>               (<code>Trajectory</code>)           \u2013            <p>Reference trajectory.</p> </li> <li> <code>inplace</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Perform transformation in place. Defaults to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Trajectory</code> (              <code>Trajectory</code> )          \u2013            <p>Transformed trajectory.</p> </li> </ul> Source code in <code>trajectopy\\processing\\alignment.py</code> <pre><code>def adopt_first_pose(trajectory: Trajectory, other: Trajectory, inplace: bool = True) -&gt; Trajectory:\n    \"\"\"Transform trajectory so that the first pose is identical in both.\n\n    Args:\n        trajectory (Trajectory): Trajectory to transform.\n        other (Trajectory): Reference trajectory.\n        inplace (bool, optional): Perform transformation in place. Defaults to True.\n\n    Returns:\n        Trajectory: Transformed trajectory.\n    \"\"\"\n    trajectory = trajectory if inplace else trajectory.copy()\n    adopt_first_position(trajectory=trajectory, other=other)\n    adopt_first_orientation(trajectory=trajectory, other=other)\n    return trajectory\n</code></pre>"},{"location":"api/processing/alignment/#trajectopy.processing.alignment.adopt_first_position","title":"adopt_first_position","text":"<pre><code>adopt_first_position(\n    trajectory: Trajectory,\n    other: Trajectory,\n    inplace: bool = True,\n) -&gt; Trajectory\n</code></pre> <p>Transform trajectory so that the first position is identical in both.</p> <p>Parameters:</p> <ul> <li> <code>trajectory</code>               (<code>Trajectory</code>)           \u2013            <p>Trajectory to transform.</p> </li> <li> <code>other</code>               (<code>Trajectory</code>)           \u2013            <p>Reference trajectory.</p> </li> <li> <code>inplace</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Perform transformation in place. Defaults to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Trajectory</code> (              <code>Trajectory</code> )          \u2013            <p>Transformed trajectory.</p> </li> </ul> Source code in <code>trajectopy\\processing\\alignment.py</code> <pre><code>def adopt_first_position(trajectory: Trajectory, other: Trajectory, inplace: bool = True) -&gt; Trajectory:\n    \"\"\"Transform trajectory so that the first position is identical in both.\n\n    Args:\n        trajectory (Trajectory): Trajectory to transform.\n        other (Trajectory): Reference trajectory.\n        inplace (bool, optional): Perform transformation in place. Defaults to True.\n\n    Returns:\n        Trajectory: Transformed trajectory.\n    \"\"\"\n    trajectory = trajectory if inplace else trajectory.copy()\n    position_difference = other.positions.xyz[0, :] - trajectory.positions.xyz[0, :]\n    trajectory.positions.xyz += position_difference\n    return other\n</code></pre>"},{"location":"api/processing/alignment/#trajectopy.processing.alignment.adopt_first_orientation","title":"adopt_first_orientation","text":"<pre><code>adopt_first_orientation(\n    trajectory: Trajectory,\n    other: Trajectory,\n    inplace: bool = True,\n) -&gt; Trajectory\n</code></pre> <p>Transform trajectory so that the first orientation is identical in both.</p> <p>Parameters:</p> <ul> <li> <code>trajectory</code>               (<code>Trajectory</code>)           \u2013            <p>Trajectory to transform.</p> </li> <li> <code>other</code>               (<code>Trajectory</code>)           \u2013            <p>Reference trajectory.</p> </li> <li> <code>inplace</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Perform transformation in place. Defaults to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Trajectory</code> (              <code>Trajectory</code> )          \u2013            <p>Transformed trajectory.</p> </li> </ul> Source code in <code>trajectopy\\processing\\alignment.py</code> <pre><code>def adopt_first_orientation(trajectory: Trajectory, other: Trajectory, inplace: bool = True) -&gt; Trajectory:\n    \"\"\"Transform trajectory so that the first orientation is identical in both.\n\n    Args:\n        trajectory (Trajectory): Trajectory to transform.\n        other (Trajectory): Reference trajectory.\n        inplace (bool, optional): Perform transformation in place. Defaults to True.\n\n    Returns:\n        Trajectory: Transformed trajectory.\n    \"\"\"\n    trajectory = trajectory if inplace else trajectory.copy()\n    if trajectory.rotations is not None and other.rotations is not None:\n        rpy = trajectory.rotations.as_euler(seq=\"xyz\")\n        rotation_difference = other.rotations.as_euler(seq=\"xyz\")[0, :] - rpy[0, :]\n\n        trajectory.rotations = Rotations.from_euler(seq=\"xyz\", angles=rpy + rotation_difference)\n\n    return other\n</code></pre>"},{"location":"api/processing/alignment/#trajectopy.processing.alignment.align","title":"align","text":"<pre><code>align(\n    trajectory: Trajectory,\n    other: Trajectory,\n    alignment_settings: AlignmentSettings = AlignmentSettings(),\n    matching_settings: MatchingSettings = MatchingSettings(),\n    inplace: bool = True,\n) -&gt; Trajectory\n</code></pre> <p>Aligns the trajectory with another trajectory.</p> <p>Parameters:</p> <ul> <li> <code>trajectory</code>               (<code>Trajectory</code>)           \u2013            <p>Trajectory to align.</p> </li> <li> <code>other</code>               (<code>Trajectory</code>)           \u2013            <p>Reference trajectory.</p> </li> <li> <code>alignment_settings</code>               (<code>AlignmentSettings</code>, default:                   <code>AlignmentSettings()</code> )           \u2013            <p>Settings for the alignment process. Defaults to AlignmentSettings().</p> </li> <li> <code>matching_settings</code>               (<code>MatchingSettings</code>, default:                   <code>MatchingSettings()</code> )           \u2013            <p>Settings for the matching process. Defaults to MatchingSettings().</p> </li> <li> <code>inplace</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Perform in-place. Defaults to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Trajectory</code> (              <code>Trajectory</code> )          \u2013            <p>Aligned trajectory.</p> </li> </ul> Source code in <code>trajectopy\\processing\\alignment.py</code> <pre><code>def align(\n    trajectory: Trajectory,\n    other: Trajectory,\n    alignment_settings: settings.AlignmentSettings = settings.AlignmentSettings(),\n    matching_settings: settings.MatchingSettings = settings.MatchingSettings(),\n    inplace: bool = True,\n) -&gt; Trajectory:\n    \"\"\"Aligns the trajectory with another trajectory.\n\n    Args:\n        trajectory (Trajectory): Trajectory to align.\n        other (Trajectory): Reference trajectory.\n        alignment_settings (AlignmentSettings, optional): Settings for the alignment process.\n            Defaults to AlignmentSettings().\n        matching_settings (MatchingSettings, optional): Settings for the matching process.\n            Defaults to MatchingSettings().\n        inplace (bool, optional): Perform in-place. Defaults to True.\n\n    Returns:\n        Trajectory: Aligned trajectory.\n    \"\"\"\n    alignment = estimate_alignment(\n        trajectory=trajectory,\n        other=other,\n        alignment_settings=alignment_settings,\n        matching_settings=matching_settings,\n    )\n    return apply_alignment(trajectory=trajectory, alignment_result=alignment, inplace=inplace)\n</code></pre>"},{"location":"api/processing/approximation/","title":"Approximation","text":""},{"location":"api/processing/approximation/#trajectopy.processing.approximation","title":"approximation","text":""},{"location":"api/processing/approximation/#trajectopy.processing.approximation.approximate_cubic","title":"approximate_cubic","text":"<pre><code>approximate_cubic(\n    trajectory: Trajectory,\n    approximation_settings: ApproximationSettings = ApproximationSettings(),\n    inplace: bool = False,\n) -&gt; Trajectory\n</code></pre> <p>Approximate the trajectory using piecewise cubic polynomials based on the provided settings.</p> <p>Parameters:</p> <ul> <li> <code>trajectory</code>               (<code>Trajectory</code>)           \u2013            <p>The trajectory to approximate.</p> </li> <li> <code>approximation_settings</code>               (<code>ApproximationSettings</code>, default:                   <code>ApproximationSettings()</code> )           \u2013            <p>Settings for the approximation.</p> </li> <li> <code>inplace</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, modify the trajectory in place. Defaults to False.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Trajectory</code> (              <code>Trajectory</code> )          \u2013            <p>The approximated trajectory.</p> </li> </ul> Source code in <code>trajectopy\\processing\\approximation.py</code> <pre><code>def approximate_cubic(\n    trajectory: Trajectory,\n    approximation_settings: ApproximationSettings = ApproximationSettings(),\n    inplace: bool = False,\n) -&gt; Trajectory:\n    \"\"\"Approximate the trajectory using piecewise cubic polynomials based on the provided settings.\n\n    Args:\n        trajectory (Trajectory): The trajectory to approximate.\n        approximation_settings (ApproximationSettings): Settings for the approximation.\n        inplace (bool): If True, modify the trajectory in place. Defaults to False.\n\n    Returns:\n        Trajectory: The approximated trajectory.\n    \"\"\"\n    xyz_approx = _piecewise_cubic(\n        index=trajectory.index,\n        values=trajectory.xyz,\n        min_win_size=approximation_settings.position_interval_size,\n        min_obs=approximation_settings.position_min_observations,\n    )\n\n    traj_approx = trajectory if inplace else trajectory.copy()\n    traj_approx.positions.xyz = xyz_approx[trajectory.sort_switching_index, :]\n\n    if not traj_approx.has_orientation:\n        return traj_approx\n\n    quat_approx = _average_rotations_in_window(\n        index=trajectory.index,\n        quat=trajectory.quat,\n        win_size=approximation_settings.rotation_window_size,\n    )\n    traj_approx.rotations = Rotations.from_quat(quat_approx[trajectory.sort_switching_index, :])\n\n    return traj_approx\n</code></pre>"},{"location":"api/processing/evaluation/","title":"Evaluation","text":""},{"location":"api/processing/evaluation/#trajectopy.processing.evaluation","title":"evaluation","text":""},{"location":"api/processing/evaluation/#trajectopy.processing.evaluation.ate","title":"ate","text":"<pre><code>ate(\n    trajectory: Trajectory,\n    other: Trajectory,\n    processing_settings: ProcessingSettings = ProcessingSettings(),\n    return_alignment: bool = False,\n    align: bool = True,\n) -&gt; Union[ATEResult, Tuple[ATEResult, AlignmentResult]]\n</code></pre> <p>Computes the absolute trajectory error (ATE) between two trajectories.</p> <p>The ATE is computed by first matching the estimated trajectory to the ground truth trajectory. Then, the alignment between the two trajectories is estimated. The estimated trajectory is aligned to the ground truth trajectory using the estimated alignment. Finally, the ATE is computed by comparing the aligned estimated trajectory to the ground truth trajectory.</p> <p>Parameters:</p> <ul> <li> <code>trajectory</code>               (<code>Trajectory</code>)           \u2013            <p>Trajectory to be evaluated.</p> </li> <li> <code>other</code>               (<code>Trajectory</code>)           \u2013            <p>Ground truth trajectory.</p> </li> <li> <code>processing_settings</code>               (<code>ProcessingSettings</code>, default:                   <code>ProcessingSettings()</code> )           \u2013            <p>Processing settings.</p> </li> <li> <code>return_alignment</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to return the alignment result. Defaults to False.</p> </li> <li> <code>align</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to perform alignment. Defaults to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ATEResult</code> (              <code>Union[ATEResult, Tuple[ATEResult, AlignmentResult]]</code> )          \u2013            <p>Result of the ATE computation. If return_alignment is True, returns a tuple containing (ATEResult, AlignmentResult).</p> </li> </ul> Source code in <code>trajectopy\\processing\\evaluation.py</code> <pre><code>def ate(\n    trajectory: Trajectory,\n    other: Trajectory,\n    processing_settings: settings.ProcessingSettings = settings.ProcessingSettings(),\n    return_alignment: bool = False,\n    align: bool = True,\n) -&gt; Union[ATEResult, Tuple[ATEResult, AlignmentResult]]:\n    \"\"\"Computes the absolute trajectory error (ATE) between two trajectories.\n\n    The ATE is computed by first matching the estimated trajectory to the ground truth trajectory.\n    Then, the alignment between the two trajectories is estimated. The estimated trajectory is\n    aligned to the ground truth trajectory using the estimated alignment. Finally, the ATE is\n    computed by comparing the aligned estimated trajectory to the ground truth trajectory.\n\n    Args:\n        trajectory (Trajectory): Trajectory to be evaluated.\n        other (Trajectory): Ground truth trajectory.\n        processing_settings (ProcessingSettings, optional): Processing settings.\n        return_alignment (bool, optional): Whether to return the alignment result.\n            Defaults to False.\n        align (bool, optional): Whether to perform alignment. Defaults to True.\n\n    Returns:\n        ATEResult: Result of the ATE computation. If return_alignment is True, returns a tuple\n            containing (ATEResult, AlignmentResult).\n    \"\"\"\n    trajectory, other = match_trajectories(\n        trajectory=trajectory, other=other, matching_settings=processing_settings.matching, inplace=False\n    )\n\n    if align:\n        alignment = estimate_alignment(\n            trajectory=trajectory,\n            other=other,\n            alignment_settings=processing_settings.alignment,\n            matching_settings=processing_settings.matching,\n        )\n        trajectory_est_aligned = apply_alignment(trajectory, alignment_result=alignment, inplace=False)\n    else:\n        alignment = AlignmentResult()\n        trajectory_est_aligned = trajectory\n\n    return (\n        (\n            _compare_trajectories_absolute(other=other, trajectory=trajectory_est_aligned),\n            alignment,\n        )\n        if return_alignment\n        else _compare_trajectories_absolute(other=other, trajectory=trajectory_est_aligned)\n    )\n</code></pre>"},{"location":"api/processing/evaluation/#trajectopy.processing.evaluation.rpe","title":"rpe","text":"<pre><code>rpe(\n    trajectory: Trajectory,\n    other: Trajectory,\n    processing_settings: ProcessingSettings = ProcessingSettings(),\n) -&gt; RPEResult\n</code></pre> <p>Computes the relative pose error (RPE) between two trajectories.</p> <p>The RPE is computed by comparing the relative poses between the estimated and ground truth trajectories. The pose distances are either defined in meters or in seconds depending on the settings.</p> <p>Parameters:</p> <ul> <li> <code>trajectory</code>               (<code>Trajectory</code>)           \u2013            <p>Trajectory to be evaluated.</p> </li> <li> <code>other</code>               (<code>Trajectory</code>)           \u2013            <p>Ground truth trajectory.</p> </li> <li> <code>processing_settings</code>               (<code>ProcessingSettings</code>, default:                   <code>ProcessingSettings()</code> )           \u2013            <p>Processing settings.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RPEResult</code> (              <code>RPEResult</code> )          \u2013            <p>Result of the RPE computation.</p> </li> </ul> Source code in <code>trajectopy\\processing\\evaluation.py</code> <pre><code>def rpe(\n    trajectory: Trajectory,\n    other: Trajectory,\n    processing_settings: settings.ProcessingSettings = settings.ProcessingSettings(),\n) -&gt; RPEResult:\n    \"\"\"Computes the relative pose error (RPE) between two trajectories.\n\n    The RPE is computed by comparing the relative poses between the estimated and ground truth\n    trajectories. The pose distances are either defined in meters or in seconds depending on\n    the settings.\n\n    Args:\n        trajectory (Trajectory): Trajectory to be evaluated.\n        other (Trajectory): Ground truth trajectory.\n        processing_settings (ProcessingSettings, optional): Processing settings.\n\n    Returns:\n        RPEResult: Result of the RPE computation.\n    \"\"\"\n    trajectory, other = match_trajectories(\n        trajectory=trajectory, other=other, matching_settings=processing_settings.matching, inplace=False\n    )\n    return _compare_trajectories_relative(\n        trajectory=trajectory,\n        other=other,\n        relative_comparison_settings=processing_settings.relative_comparison,\n    )\n</code></pre>"},{"location":"api/processing/interpolation/","title":"Interpolation","text":""},{"location":"api/processing/interpolation/#trajectopy.processing.interpolation","title":"interpolation","text":""},{"location":"api/processing/interpolation/#trajectopy.processing.interpolation.interpolate","title":"interpolate","text":"<pre><code>interpolate(\n    trajectory: Trajectory,\n    timestamps: Union[list, ndarray],\n    method: InterpolationMethod = LINEAR,\n    inplace: bool = True,\n) -&gt; Trajectory\n</code></pre> <p>Interpolates a trajectory to specified timestamps using the given method.</p> <p>Parameters:</p> <ul> <li> <code>trajectory</code>               (<code>Trajectory</code>)           \u2013            <p>Trajectory to interpolate</p> </li> <li> <code>timestamps</code>               (<code>list | ndarray</code>)           \u2013            <p>Interpolation timestamps</p> </li> <li> <code>method</code>               (<code>InterpolationMethod</code>, default:                   <code>LINEAR</code> )           \u2013            <p>Interpolation method. Defaults to InterpolationMethod.LINEAR.</p> </li> <li> <code>inplace</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Perform in-place interpolation. Defaults to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Trajectory</code> (              <code>Trajectory</code> )          \u2013            <p>Interpolated trajectory</p> </li> </ul> Source code in <code>trajectopy\\processing\\interpolation.py</code> <pre><code>def interpolate(\n    trajectory: Trajectory,\n    timestamps: Union[list, np.ndarray],\n    method: InterpolationMethod = InterpolationMethod.LINEAR,\n    inplace: bool = True,\n) -&gt; \"Trajectory\":\n    \"\"\"Interpolates a trajectory to specified timestamps using the given method.\n\n    Args:\n        trajectory (Trajectory): Trajectory to interpolate\n        timestamps (list | np.ndarray): Interpolation timestamps\n        method (InterpolationMethod, optional): Interpolation method. Defaults to InterpolationMethod.LINEAR.\n        inplace (bool, optional): Perform in-place interpolation. Defaults to True.\n\n    Returns:\n        Trajectory: Interpolated trajectory\n    \"\"\"\n    if method == InterpolationMethod.LINEAR:\n        return _interpolate_linear(trajectory, timestamps, inplace)\n    else:\n        raise ValueError(f\"Interpolation method '{method}' is not supported.\")\n</code></pre>"},{"location":"api/processing/matching/","title":"Matching","text":""},{"location":"api/processing/matching/#trajectopy.processing.matching","title":"matching","text":""},{"location":"api/processing/matching/#trajectopy.processing.matching.match_non_overlapping_timestamps","title":"match_non_overlapping_timestamps","text":"<pre><code>match_non_overlapping_timestamps(\n    trajectory: Trajectory,\n    other: Trajectory,\n    max_distance: float = 0.0,\n) -&gt; float\n</code></pre> <p>Roughly matches two trajectories temporally.</p> <p>Parameters:</p> <ul> <li> <code>trajectory</code>               (<code>Trajectory</code>)           \u2013            <p>Trajectory to match.</p> </li> <li> <code>other</code>               (<code>Trajectory</code>)           \u2013            <p>Other trajectory to match against.</p> </li> <li> <code>max_distance</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Maximum distance for spatial matching. Defaults to 0.0.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code> (              <code>float</code> )          \u2013            <p>Mean time offset.</p> </li> </ul> Source code in <code>trajectopy\\processing\\matching.py</code> <pre><code>def match_non_overlapping_timestamps(trajectory: Trajectory, other: Trajectory, max_distance: float = 0.0) -&gt; float:\n    \"\"\"Roughly matches two trajectories temporally.\n\n    Args:\n        trajectory (Trajectory): Trajectory to match.\n        other (Trajectory): Other trajectory to match against.\n        max_distance (float, optional): Maximum distance for spatial matching. Defaults to 0.0.\n\n    Returns:\n        float: Mean time offset.\n    \"\"\"\n    other, trajectory = _match_trajectories_spatial(\n        trajectory=other.copy(), other=trajectory.copy(), max_distance=max_distance\n    )\n    mean_time_offset = np.median(trajectory.timestamps - other.timestamps)\n    logger.info(\"Median time offset: %.3f s\", mean_time_offset)\n    return mean_time_offset\n</code></pre>"},{"location":"api/processing/matching/#trajectopy.processing.matching.match_timestamps","title":"match_timestamps","text":"<pre><code>match_timestamps(\n    trajectory: Trajectory,\n    timestamps: ndarray,\n    inplace: bool = True,\n) -&gt; Trajectory\n</code></pre> <p>Truncates trajectory to only those poses where the timestamps exactly match \"timestamps\".</p> <p>Parameters:</p> <ul> <li> <code>trajectory</code>               (<code>Trajectory</code>)           \u2013            <p>Input trajectory.</p> </li> <li> <code>timestamps</code>               (<code>ndarray</code>)           \u2013            <p>Input timestamps.</p> </li> <li> <code>inplace</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Perform matching in-place. Defaults to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Trajectory</code> (              <code>Trajectory</code> )          \u2013            <p>Trajectory with matched timestamps.</p> </li> </ul> Source code in <code>trajectopy\\processing\\matching.py</code> <pre><code>def match_timestamps(trajectory: Trajectory, timestamps: np.ndarray, inplace: bool = True) -&gt; Trajectory:\n    \"\"\"Truncates trajectory to only those poses where the timestamps exactly match \"timestamps\".\n\n    Args:\n        trajectory (Trajectory): Input trajectory.\n        timestamps (np.ndarray): Input timestamps.\n        inplace (bool, optional): Perform matching in-place. Defaults to True.\n\n    Returns:\n        Trajectory: Trajectory with matched timestamps.\n    \"\"\"\n    traj_self = trajectory if inplace else trajectory.copy()\n    _, idx_self, _ = np.intersect1d(traj_self.timestamps, timestamps, return_indices=True)\n    traj_self.mask(idx_self)\n    return traj_self\n</code></pre>"},{"location":"api/processing/matching/#trajectopy.processing.matching.match_trajectories","title":"match_trajectories","text":"<pre><code>match_trajectories(\n    trajectory: Trajectory,\n    other: Trajectory,\n    matching_settings: MatchingSettings = MatchingSettings(),\n    inplace: bool = True,\n) -&gt; Tuple[Trajectory, Trajectory]\n</code></pre> <p>Matches two trajectories using the specified method.</p> <p>Supported methods:</p> <ul> <li>INTERPOLATION: Interpolates the test trajectory onto the reference trajectory using   its timestamps. The interpolation is linear for both positions and rotations (SLERP).</li> <li>NEAREST_TEMPORAL: Finds the nearest temporal match without interpolation by finding   the nearest timestamp in the target trajectory for each timestamp in the source trajectory.</li> <li>NEAREST_SPATIAL: Finds the nearest spatial match without interpolation by finding   the nearest pose in the target trajectory for each pose in the source trajectory using   Euclidean distance.</li> <li>NEAREST_SPATIAL_INTERPOLATED: Finds the nearest k spatial matches and spatially   interpolates using a 3d line. Both trajectories will have the length of the test trajectory.   This method does not support rotation matching.</li> </ul> <p>Parameters:</p> <ul> <li> <code>trajectory</code>               (<code>Trajectory</code>)           \u2013            <p>Trajectory to match.</p> </li> <li> <code>other</code>               (<code>Trajectory</code>)           \u2013            <p>Other trajectory to match against.</p> </li> <li> <code>matching_settings</code>               (<code>MatchingSettings</code>, default:                   <code>MatchingSettings()</code> )           \u2013            <p>Matching settings. Defaults to MatchingSettings().</p> </li> <li> <code>inplace</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to modify the input trajectories. Defaults to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tuple[Trajectory, Trajectory]</code>           \u2013            <p>Tuple[Trajectory, Trajectory]: Matched trajectories.</p> </li> </ul> Source code in <code>trajectopy\\processing\\matching.py</code> <pre><code>def match_trajectories(\n    trajectory: Trajectory,\n    other: Trajectory,\n    matching_settings: settings.MatchingSettings = settings.MatchingSettings(),\n    inplace: bool = True,\n) -&gt; Tuple[Trajectory, Trajectory]:\n    \"\"\"Matches two trajectories using the specified method.\n\n    Supported methods:\n\n    - **INTERPOLATION**: Interpolates the test trajectory onto the reference trajectory using\n      its timestamps. The interpolation is linear for both positions and rotations (SLERP).\n    - **NEAREST_TEMPORAL**: Finds the nearest temporal match without interpolation by finding\n      the nearest timestamp in the target trajectory for each timestamp in the source trajectory.\n    - **NEAREST_SPATIAL**: Finds the nearest spatial match without interpolation by finding\n      the nearest pose in the target trajectory for each pose in the source trajectory using\n      Euclidean distance.\n    - **NEAREST_SPATIAL_INTERPOLATED**: Finds the nearest k spatial matches and spatially\n      interpolates using a 3d line. Both trajectories will have the length of the test trajectory.\n      This method does not support rotation matching.\n\n    Args:\n        trajectory (Trajectory): Trajectory to match.\n        other (Trajectory): Other trajectory to match against.\n        matching_settings (MatchingSettings, optional): Matching settings. Defaults to\n            MatchingSettings().\n        inplace (bool, optional): Whether to modify the input trajectories. Defaults to True.\n\n    Returns:\n        Tuple[Trajectory, Trajectory]: Matched trajectories.\n    \"\"\"\n    trajectory = trajectory if inplace else trajectory.copy()\n    other = other if inplace else other.copy()\n\n    if not trajectory.overlaps_with(other) and matching_settings.method in [\n        settings.MatchingMethod.NEAREST_TEMPORAL,\n        settings.MatchingMethod.INTERPOLATION,\n    ]:\n        logger.warning(\"Trajectories do not overlap! Performing rough matching first.\")\n        timeshift = match_non_overlapping_timestamps(\n            trajectory=other, other=trajectory, max_distance=matching_settings.max_distance\n        )\n        logger.info(\"Rough matching time offset: %.3f s\", timeshift)\n        trajectory.timestamps += timeshift\n\n    logger.info(\"Matching trajectories using method %s\", matching_settings.method.name)\n\n    if matching_settings.method == settings.MatchingMethod.INTERPOLATION:\n        return _match_trajectories_interpolation(\n            trajectory=trajectory, other=other, max_gap_size=matching_settings.max_gap_size\n        )\n\n    if matching_settings.method == settings.MatchingMethod.NEAREST_TEMPORAL:\n        return _match_trajectories_temporal(\n            trajectory=trajectory, other=other, max_distance=matching_settings.max_time_diff\n        )\n\n    if matching_settings.method == settings.MatchingMethod.NEAREST_SPATIAL:\n        return _match_trajectories_spatial(\n            trajectory=trajectory, other=other, max_distance=matching_settings.max_distance\n        )\n\n    if matching_settings.method == settings.MatchingMethod.NEAREST_SPATIAL_INTERPOLATED:\n        return _match_trajectories_spatial_interpolation(\n            trajectory=trajectory,\n            other=other,\n            max_distance=matching_settings.max_distance,\n            k_nearest=matching_settings.k_nearest,\n        )\n\n    raise ValueError(f\"Matching method {matching_settings.method} not supported!\")\n</code></pre>"},{"location":"api/processing/merging/","title":"Merging","text":""},{"location":"api/processing/merging/#trajectopy.processing.merging","title":"merging","text":""},{"location":"api/processing/merging/#trajectopy.processing.merging.merge_trajectories","title":"merge_trajectories","text":"<pre><code>merge_trajectories(\n    trajectories: List[Trajectory],\n) -&gt; Trajectory\n</code></pre> <p>Merges a list of trajectories into one trajectory.</p> <p>This function ignores EPSG codes and merges the trajectories based on their timestamps. Therefore, all trajectories should be in the same coordinate system before merging.</p> <p>Parameters:</p> <ul> <li> <code>trajectories</code>               (<code>List[Trajectory]</code>)           \u2013            <p>List of trajectories to merge.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Trajectory</code> (              <code>Trajectory</code> )          \u2013            <p>Merged trajectory.</p> </li> </ul> Source code in <code>trajectopy\\processing\\merging.py</code> <pre><code>def merge_trajectories(trajectories: List[Trajectory]) -&gt; Trajectory:\n    \"\"\"Merges a list of trajectories into one trajectory.\n\n    This function ignores EPSG codes and merges the trajectories based on their timestamps.\n    Therefore, all trajectories should be in the same coordinate system before merging.\n\n    Args:\n        trajectories (List[Trajectory]): List of trajectories to merge.\n\n    Returns:\n        Trajectory: Merged trajectory.\n    \"\"\"\n    epsg_set = {t.positions.epsg for t in trajectories}\n\n    if len(epsg_set) &gt; 1:\n        logger.warning(\n            \"Merging trajectories with different EPSG codes. \"\n            \"This may lead to unexpected results. \"\n            \"Consider reprojecting the trajectories to the same EPSG code.\"\n        )\n\n    epsg = epsg_set.pop()\n\n    merged_xyz = np.concatenate([t.positions.xyz for t in trajectories], axis=0)\n    merged_quat = np.concatenate(\n        [t.rotations.as_quat() if t.has_orientation else Rotations.identity(len(t)).as_quat() for t in trajectories],\n        axis=0,\n    )\n    has_rot = [t.has_orientation for t in trajectories]\n    merged_timestamps = np.concatenate([t.timestamps for t in trajectories], axis=0)\n\n    merged = Trajectory(\n        name=\"Merged\",\n        timestamps=merged_timestamps,\n        positions=Positions(xyz=merged_xyz, epsg=epsg),\n        rotations=Rotations.from_quat(merged_quat) if any(has_rot) else None,\n    )\n\n    merged.mask(np.argsort(merged.timestamps), inplace=True)\n    return merged\n</code></pre>"},{"location":"api/processing/merging/#trajectopy.processing.merging.average_trajectories","title":"average_trajectories","text":"<pre><code>average_trajectories(\n    trajectories: List[Trajectory],\n) -&gt; Trajectory\n</code></pre> <p>Averages a list of trajectories into one trajectory.</p> <p>This function ignores EPSG codes and averages trajectories.</p> <p>Parameters:</p> <ul> <li> <code>trajectories</code>               (<code>List[Trajectory]</code>)           \u2013            <p>List of trajectories to average.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Trajectory</code> (              <code>Trajectory</code> )          \u2013            <p>Averaged trajectory.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If trajectories have different lengths.</p> </li> </ul> Source code in <code>trajectopy\\processing\\merging.py</code> <pre><code>def average_trajectories(trajectories: List[Trajectory]) -&gt; Trajectory:\n    \"\"\"Averages a list of trajectories into one trajectory.\n\n    This function ignores EPSG codes and averages trajectories.\n\n    Args:\n        trajectories (List[Trajectory]): List of trajectories to average.\n\n    Returns:\n        Trajectory: Averaged trajectory.\n\n    Raises:\n        ValueError: If trajectories have different lengths.\n    \"\"\"\n    lengths = {len(t) for t in trajectories}\n\n    if len(lengths) != 1:\n        raise ValueError(\n            \"Trajectories must have the same length to be averaged. Ensure this using trajectory matching.\"\n        )\n\n    xyz_stack = np.stack([t.positions.xyz for t in trajectories], axis=0)\n\n    rots = [t.rotations.as_quat() for t in trajectories if t.has_orientation]\n    mean_rots = []\n    for i in range(len(trajectories[0])):\n        rotations = []\n        rotations.extend(rot[i] for rot in rots)\n        if not rotations:\n            continue\n\n        mean_rots.append(Rotations.from_quat(np.array(rotations)).mean().as_quat())\n\n    avg_xyz = np.mean(xyz_stack, axis=0)\n\n    return Trajectory(\n        name=\"Averaged\",\n        timestamps=trajectories[0].timestamps,\n        positions=Positions(xyz=avg_xyz, epsg=trajectories[0].positions.epsg),\n        rotations=Rotations.from_quat(mean_rots) if mean_rots else None,\n    )\n</code></pre>"},{"location":"api/processing/parameters/","title":"Alignment Parameters","text":""},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters","title":"parameters","text":""},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.Parameter","title":"Parameter","text":"<pre><code>Parameter(\n    value: float,\n    variance: float = 0.0,\n    default: float = 0.0,\n    enabled: bool = True,\n    name: str = \"\",\n    unit: Unit = NONE,\n)\n</code></pre> <p>Class representing a stochastic parameter with variance.</p> <p>A parameter holds a stochastic value with some variance and can be enabled or disabled. When disabled, the parameter's value equals its default value. The default value should be chosen so the parameter has no effect on computations (e.g., scale=1, rotation/translation=0).</p> <p>Parameter disabling is used to exclude parameters from least-squares estimation during trajectory alignment.</p> <p>Attributes:</p> <ul> <li> <code>default</code>           \u2013            <p>Default value used when parameter is disabled</p> </li> <li> <code>enabled</code>           \u2013            <p>Whether the parameter is active</p> </li> <li> <code>name</code>           \u2013            <p>Parameter name for identification</p> </li> <li> <code>unit</code>           \u2013            <p>Unit of measurement for the parameter</p> </li> </ul> <p>Initializes a Parameter instance.</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>float</code>)           \u2013            <p>Initial parameter value</p> </li> <li> <code>variance</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Initial parameter variance. Defaults to 0.0.</p> </li> <li> <code>default</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Default value when disabled. Defaults to 0.0.</p> </li> <li> <code>enabled</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether parameter is enabled. Defaults to True.</p> </li> <li> <code>name</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Parameter name. Auto-generated if empty. Defaults to \"\".</p> </li> <li> <code>unit</code>               (<code>Unit</code>, default:                   <code>NONE</code> )           \u2013            <p>Unit of measurement. Defaults to Unit.NONE.</p> </li> </ul> Source code in <code>trajectopy\\processing\\lib\\alignment\\parameters.py</code> <pre><code>def __init__(\n    self,\n    value: float,\n    variance: float = 0.0,\n    default: float = 0.0,\n    enabled: bool = True,\n    name: str = \"\",\n    unit: Unit = Unit.NONE,\n) -&gt; None:\n    \"\"\"Initializes a Parameter instance.\n\n    Args:\n        value: Initial parameter value\n        variance: Initial parameter variance. Defaults to 0.0.\n        default: Default value when disabled. Defaults to 0.0.\n        enabled: Whether parameter is enabled. Defaults to True.\n        name: Parameter name. Auto-generated if empty. Defaults to \"\".\n        unit: Unit of measurement. Defaults to Unit.NONE.\n    \"\"\"\n    self._value = value\n    self._variance = variance\n    self.default = default\n    self.enabled = enabled\n    self.name = name or f\"Parameter {Parameter._cnt}\"\n    self.unit = unit\n\n    Parameter._cnt += 1\n</code></pre>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.Parameter.value","title":"value  <code>property</code> <code>writable</code>","text":"<pre><code>value: float\n</code></pre> <p>Gets the parameter value.</p> <p>Returns:</p> <ul> <li> <code>float</code> (              <code>float</code> )          \u2013            <p>Actual value if enabled, default value otherwise</p> </li> </ul>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.Parameter.variance","title":"variance  <code>property</code> <code>writable</code>","text":"<pre><code>variance: float\n</code></pre> <p>Gets the parameter variance.</p> <p>Returns:</p> <ul> <li> <code>float</code> (              <code>float</code> )          \u2013            <p>Actual variance if enabled, 0.0 otherwise</p> </li> </ul>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.Parameter.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Returns formatted string representation of the parameter.</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>Formatted string with parameter name, value, unit, and standard deviation</p> </li> </ul> Source code in <code>trajectopy\\processing\\lib\\alignment\\parameters.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Returns formatted string representation of the parameter.\n\n    Returns:\n        str: Formatted string with parameter name, value, unit, and standard deviation\n    \"\"\"\n    formatter_value = UNIT_FORMAT_RULES.get(self.unit, {\"normal\": (1, \"-\", 4)})[\"normal\"]\n    formatter_variance = UNIT_FORMAT_RULES.get(self.unit, {\"precise\": (1, \"-\", 2)}).get(\"precise\", formatter_value)\n    return f\"{self.name:&lt;16} = {self.value*formatter_value[0]:&lt;8.{formatter_value[2]}f}{formatter_value[1]:&lt;4}  s-dev.: {np.sqrt(self.variance)*formatter_variance[0]:&lt;8.{formatter_variance[2]}f}{formatter_variance[1]:&lt;4}\"\n</code></pre>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.Parameter.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: Parameter) -&gt; Parameter\n</code></pre> <p>Subtracts another parameter from this one.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>Parameter</code>)           \u2013            <p>Parameter to subtract</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Parameter</code> (              <code>Parameter</code> )          \u2013            <p>New parameter with subtracted value and combined variance</p> </li> </ul> Source code in <code>trajectopy\\processing\\lib\\alignment\\parameters.py</code> <pre><code>def __sub__(self, other: \"Parameter\") -&gt; \"Parameter\":\n    \"\"\"Subtracts another parameter from this one.\n\n    Args:\n        other: Parameter to subtract\n\n    Returns:\n        Parameter: New parameter with subtracted value and combined variance\n    \"\"\"\n    return Parameter(\n        value=self.value - other.value,\n        variance=np.sqrt(self.variance**2 + other.variance**2),\n    )\n</code></pre>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.Parameter.__add__","title":"__add__","text":"<pre><code>__add__(other: Parameter) -&gt; Parameter\n</code></pre> <p>Adds another parameter to this one.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>Parameter</code>)           \u2013            <p>Parameter to add</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Parameter</code> (              <code>Parameter</code> )          \u2013            <p>New parameter with added value and combined variance</p> </li> </ul> Source code in <code>trajectopy\\processing\\lib\\alignment\\parameters.py</code> <pre><code>def __add__(self, other: \"Parameter\") -&gt; \"Parameter\":\n    \"\"\"Adds another parameter to this one.\n\n    Args:\n        other: Parameter to add\n\n    Returns:\n        Parameter: New parameter with added value and combined variance\n    \"\"\"\n    return Parameter(\n        value=self.value + other.value,\n        variance=np.sqrt(self.variance**2 + other.variance**2),\n    )\n</code></pre>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.Parameter.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Parameter\n</code></pre> <p>Negates the parameter.</p> <p>Returns:</p> <ul> <li> <code>Parameter</code> (              <code>Parameter</code> )          \u2013            <p>New parameter with negated value and default</p> </li> </ul> Source code in <code>trajectopy\\processing\\lib\\alignment\\parameters.py</code> <pre><code>def __neg__(self) -&gt; \"Parameter\":\n    \"\"\"Negates the parameter.\n\n    Returns:\n        Parameter: New parameter with negated value and default\n    \"\"\"\n    return Parameter(\n        value=-self.value,\n        variance=self.variance,\n        default=-self.default,\n        enabled=self.enabled,\n        name=self.name,\n        unit=self.unit,\n    )\n</code></pre>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.Parameter.enable","title":"enable","text":"<pre><code>enable() -&gt; None\n</code></pre> <p>Enables the parameter for estimation.</p> Source code in <code>trajectopy\\processing\\lib\\alignment\\parameters.py</code> <pre><code>def enable(self) -&gt; None:\n    \"\"\"Enables the parameter for estimation.\"\"\"\n    self.enabled = True\n</code></pre>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.Parameter.disable","title":"disable","text":"<pre><code>disable() -&gt; None\n</code></pre> <p>Disables the parameter from estimation.</p> Source code in <code>trajectopy\\processing\\lib\\alignment\\parameters.py</code> <pre><code>def disable(self) -&gt; None:\n    \"\"\"Disables the parameter from estimation.\"\"\"\n    self.enabled = False\n</code></pre>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.ParameterSet","title":"ParameterSet  <code>dataclass</code>","text":"<pre><code>ParameterSet(\n    enabled: bool = True,\n    covariance_matrix: ndarray = (\n        lambda: zeros((0, 0), dtype=float)\n    )(),\n)\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Abstract base class for grouping related parameters.</p> <p>Groups related parameters (e.g., 3 parameters for 3D translation) and provides common functionality for managing parameter values, variances, and covariances.</p> <p>Attributes:</p> <ul> <li> <code>enabled</code>               (<code>bool</code>)           \u2013            <p>Whether the entire parameter set is enabled</p> </li> <li> <code>covariance_matrix</code>               (<code>ndarray</code>)           \u2013            <p>Covariance matrix for the parameter set</p> </li> </ul>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.ParameterSet.any_enabled","title":"any_enabled  <code>property</code>","text":"<pre><code>any_enabled: bool\n</code></pre> <p>Checks if any parameter in the set is enabled.</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if at least one parameter is enabled</p> </li> </ul>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.ParameterSet.num_enabled","title":"num_enabled  <code>property</code>","text":"<pre><code>num_enabled: int\n</code></pre> <p>Gets the number of enabled parameters in the set.</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>Count of enabled parameters</p> </li> </ul>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.ParameterSet.enabled_bool_list","title":"enabled_bool_list  <code>property</code> <code>writable</code>","text":"<pre><code>enabled_bool_list: List[bool]\n</code></pre> <p>Gets the enabled state of all parameters as a boolean list.</p> <p>Returns:</p> <ul> <li> <code>List[bool]</code>           \u2013            <p>List[bool]: List of booleans indicating which parameters are enabled</p> </li> </ul>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.ParameterSet.enabled_indices","title":"enabled_indices  <code>property</code>","text":"<pre><code>enabled_indices: List[int]\n</code></pre> <p>Gets indices of enabled parameters.</p> <p>Useful for extracting values or variances of only enabled parameters from the full parameter arrays.</p> <p>Returns:</p> <ul> <li> <code>List[int]</code>           \u2013            <p>List[int]: List of indices where parameters are enabled</p> </li> </ul>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.ParameterSet.__parameter_fields","title":"__parameter_fields  <code>property</code>","text":"<pre><code>__parameter_fields: List[Parameter]\n</code></pre> <p>Gets all Parameter instances from dataclass fields.</p> <p>Returns:</p> <ul> <li> <code>List[Parameter]</code>           \u2013            <p>List[Parameter]: List of all Parameter objects in the set</p> </li> </ul>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.ParameterSet.values","title":"values  <code>property</code> <code>writable</code>","text":"<pre><code>values: ndarray\n</code></pre> <p>Gets all parameter values as a numpy array.</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: Array of all parameter values</p> </li> </ul>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.ParameterSet.values_enabled","title":"values_enabled  <code>property</code> <code>writable</code>","text":"<pre><code>values_enabled: ndarray\n</code></pre> <p>Gets enabled parameter values as a numpy array.</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: Array of enabled parameter values</p> </li> </ul>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.ParameterSet.variances","title":"variances  <code>property</code> <code>writable</code>","text":"<pre><code>variances: ndarray\n</code></pre> <p>Gets all parameter variances as a numpy array.</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: Array of all parameter variances</p> </li> </ul>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.ParameterSet.variances_enabled","title":"variances_enabled  <code>property</code> <code>writable</code>","text":"<pre><code>variances_enabled: ndarray\n</code></pre> <p>Gets enabled parameter variances as a numpy array.</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: Array of enabled parameter variances</p> </li> </ul>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.ParameterSet.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Initializes covariance matrix after dataclass creation.</p> Source code in <code>trajectopy\\processing\\lib\\alignment\\parameters.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Initializes covariance matrix after dataclass creation.\"\"\"\n    if len(self.covariance_matrix) == len(self):\n        self.validate_covariance()\n        return\n\n    self.covariance_matrix = np.zeros((len(self), len(self)), dtype=float)\n</code></pre>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.ParameterSet.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Returns the number of parameters in the set.</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>Number of parameters</p> </li> </ul> Source code in <code>trajectopy\\processing\\lib\\alignment\\parameters.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Returns the number of parameters in the set.\n\n    Returns:\n        int: Number of parameters\n    \"\"\"\n    return len(self.values)\n</code></pre>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.ParameterSet.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Returns formatted string representation of the parameter set.</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>Boxed string with all parameter information</p> </li> </ul> Source code in <code>trajectopy\\processing\\lib\\alignment\\parameters.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Returns formatted string representation of the parameter set.\n\n    Returns:\n        str: Boxed string with all parameter information\n    \"\"\"\n    return list2box(\n        input_list=self.to_string_list(),\n        title=self.__class__.__name__,\n        upper_boundary=True,\n        lower_boundary=True,\n    )\n</code></pre>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.ParameterSet.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; iter\n</code></pre> <p>Returns iterator over parameter fields.</p> <p>Returns:</p> <ul> <li> <code>Iterator</code> (              <code>iter</code> )          \u2013            <p>Iterator over Parameter instances</p> </li> </ul> Source code in <code>trajectopy\\processing\\lib\\alignment\\parameters.py</code> <pre><code>def __iter__(self) -&gt; iter:\n    \"\"\"Returns iterator over parameter fields.\n\n    Returns:\n        Iterator: Iterator over Parameter instances\n    \"\"\"\n    return iter(self.__parameter_fields)\n</code></pre>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.ParameterSet.get_covariance_matrix","title":"get_covariance_matrix","text":"<pre><code>get_covariance_matrix(enabled_only: bool = True) -&gt; ndarray\n</code></pre> <p>Returns the covariance matrix of the parameter set</p> <p>Parameters:</p> <ul> <li> <code>enabled_only</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, only the covariance matrix of the enabled parameters is returned. Defaults to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: Covariance matrix</p> </li> </ul> Source code in <code>trajectopy\\processing\\lib\\alignment\\parameters.py</code> <pre><code>def get_covariance_matrix(self, enabled_only: bool = True) -&gt; np.ndarray:\n    \"\"\"Returns the covariance matrix of the parameter set\n\n    Args:\n        enabled_only (bool, optional): If True, only the covariance matrix of the enabled parameters is returned. Defaults to True.\n\n    Returns:\n        np.ndarray: Covariance matrix\n    \"\"\"\n    if enabled_only:\n        return self.covariance_matrix[np.ix_(self.enabled_indices, self.enabled_indices)]\n\n    return self.covariance_matrix\n</code></pre>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.ParameterSet.set_covariance_matrix","title":"set_covariance_matrix","text":"<pre><code>set_covariance_matrix(cov_matrix: ndarray) -&gt; None\n</code></pre> <p>Sets the covariance matrix of the parameter set</p> <p>Parameters:</p> <ul> <li> <code>cov_matrix</code>               (<code>ndarray</code>)           \u2013            <p>Covariance matrix</p> </li> </ul> Source code in <code>trajectopy\\processing\\lib\\alignment\\parameters.py</code> <pre><code>def set_covariance_matrix(self, cov_matrix: np.ndarray) -&gt; None:\n    \"\"\"Sets the covariance matrix of the parameter set\n\n    Args:\n        cov_matrix (np.ndarray): Covariance matrix\n    \"\"\"\n    self.covariance_matrix = cov_matrix\n    self.validate_covariance()\n</code></pre>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.ParameterSet.validate_covariance","title":"validate_covariance","text":"<pre><code>validate_covariance() -&gt; None\n</code></pre> <p>Validates and normalizes the covariance matrix dimensions.</p> <p>Checks that the covariance matrix is square and matches either all parameters or only enabled parameters. Updates parameter variances from diagonal elements.</p> <p>Raises:</p> <ul> <li> <code>AlignmentParametersError</code>             \u2013            <p>If covariance matrix dimensions are invalid</p> </li> </ul> Source code in <code>trajectopy\\processing\\lib\\alignment\\parameters.py</code> <pre><code>def validate_covariance(self) -&gt; None:\n    \"\"\"Validates and normalizes the covariance matrix dimensions.\n\n    Checks that the covariance matrix is square and matches either all parameters\n    or only enabled parameters. Updates parameter variances from diagonal elements.\n\n    Raises:\n        AlignmentParametersError: If covariance matrix dimensions are invalid\n    \"\"\"\n    if self.covariance_matrix.shape[0] != self.covariance_matrix.shape[1]:\n        raise AlignmentParametersError(\"Covariance matrix must be square.\")\n\n    if self.covariance_matrix.shape[0] == len(self):\n        self.variances = np.diag(self.covariance_matrix)\n        return\n\n    if self.covariance_matrix.shape[0] != self.num_enabled:\n        raise AlignmentParametersError(\n            \"Covariance matrix must either be valid for all parameters or for all enabled parameters!\"\n        )\n\n    covariance_matrix = np.zeros((len(self), len(self)), dtype=float)\n    # for sub_row_indiex, full_row_index in enumerate(self.enabled_indices):\n    #     for sub_col_index, full_col_index in enumerate(self.enabled_indices):\n    #         covariance_matrix[full_row_index, full_col_index] = self.covariance_matrix[\n    #             sub_row_indiex, sub_col_index\n    #         ]\n    covariance_matrix[np.ix_(self.enabled_indices, self.enabled_indices)] = self.covariance_matrix\n    self.covariance_matrix = covariance_matrix\n    self.variances_enabled = np.diag(self.get_covariance_matrix(enabled_only=True))\n</code></pre>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.ParameterSet.enable","title":"enable","text":"<pre><code>enable() -&gt; None\n</code></pre> <p>Enables all parameters in the set.</p> Source code in <code>trajectopy\\processing\\lib\\alignment\\parameters.py</code> <pre><code>def enable(self) -&gt; None:\n    \"\"\"Enables all parameters in the set.\"\"\"\n    for param in self.__parameter_fields:\n        param.enable()\n    self.enabled = True\n</code></pre>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.ParameterSet.disable","title":"disable","text":"<pre><code>disable() -&gt; None\n</code></pre> <p>Disables all parameters in the set.</p> Source code in <code>trajectopy\\processing\\lib\\alignment\\parameters.py</code> <pre><code>def disable(self) -&gt; None:\n    \"\"\"Disables all parameters in the set.\"\"\"\n    for param in self.__parameter_fields:\n        param.disable()\n    self.enabled = False\n</code></pre>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.ParameterSet.to_string_list","title":"to_string_list","text":"<pre><code>to_string_list(enabled_only: bool = True) -&gt; List[str]\n</code></pre> <p>Returns a list of all parameter strings of the class</p> <p>Parameters:</p> <ul> <li> <code>enabled_only</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, only enabled parameters are included. Defaults to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>List[str]: List of parameter strings</p> </li> </ul> Source code in <code>trajectopy\\processing\\lib\\alignment\\parameters.py</code> <pre><code>def to_string_list(self, enabled_only: bool = True) -&gt; List[str]:\n    \"\"\"Returns a list of all parameter strings of the class\n\n    Args:\n        enabled_only (bool, optional): If True, only enabled parameters are included. Defaults to True.\n\n    Returns:\n        List[str]: List of parameter strings\n    \"\"\"\n    return [str(param) for param in self.__parameter_fields if param.enabled or not enabled_only]\n</code></pre>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.ParameterSet.to_name_list","title":"to_name_list","text":"<pre><code>to_name_list(\n    enabled_only: bool = True, lower_case: bool = True\n) -&gt; List[str]\n</code></pre> <p>Returns a list of all parameter names of the class</p> <p>Parameters:</p> <ul> <li> <code>enabled_only</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, only enabled parameters are included. Defaults to True.</p> </li> <li> <code>lower_case</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, parameter names are returned in lower case. Defaults to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>List[str]: List of parameter names</p> </li> </ul> Source code in <code>trajectopy\\processing\\lib\\alignment\\parameters.py</code> <pre><code>def to_name_list(self, enabled_only: bool = True, lower_case: bool = True) -&gt; List[str]:\n    \"\"\"Returns a list of all parameter names of the class\n\n    Args:\n        enabled_only (bool, optional): If True, only enabled parameters are included. Defaults to True.\n        lower_case (bool, optional): If True, parameter names are returned in lower case. Defaults to True.\n\n    Returns:\n        List[str]: List of parameter names\n    \"\"\"\n    return [\n        param.name.lower() if lower_case else param.name\n        for param in self.__parameter_fields\n        if param.enabled or not enabled_only\n    ]\n</code></pre>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.ParameterSet.to_dict","title":"to_dict","text":"<pre><code>to_dict(\n    enabled_only: bool = True,\n) -&gt; Dict[str, List[float]]\n</code></pre> <p>Returns a dictionary of all parameters of the class</p> <p>Parameters:</p> <ul> <li> <code>enabled_only</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, only enabled parameters are included. Defaults to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, List[float]]</code>           \u2013            <p>Dict[str, List[float]]: Dictionary with parameter names as keys and [value, variance] as values</p> </li> </ul> Source code in <code>trajectopy\\processing\\lib\\alignment\\parameters.py</code> <pre><code>def to_dict(self, enabled_only: bool = True) -&gt; Dict[str, List[float]]:\n    \"\"\"Returns a dictionary of all parameters of the class\n\n    Args:\n        enabled_only (bool, optional): If True, only enabled parameters are included. Defaults to True.\n\n    Returns:\n        Dict[str, List[float]]: Dictionary with parameter names as keys and [value, variance] as values\n    \"\"\"\n    return {\n        param.name: [param.value, param.variance]\n        for param in self.__parameter_fields\n        if param.enabled or not enabled_only\n    }\n</code></pre>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.HelmertTransformation","title":"HelmertTransformation  <code>dataclass</code>","text":"<pre><code>HelmertTransformation(\n    enabled: bool = True,\n    covariance_matrix: ndarray = (\n        lambda: zeros((0, 0), dtype=float)\n    )(),\n    trans_x: Parameter = (\n        lambda: Parameter(value=0.0, default=0.0)\n    )(),\n    trans_y: Parameter = (\n        lambda: Parameter(value=0.0, default=0.0)\n    )(),\n    trans_z: Parameter = (\n        lambda: Parameter(value=0.0, default=0.0)\n    )(),\n    rot_x: Parameter = (\n        lambda: Parameter(value=0.0, default=0.0)\n    )(),\n    rot_y: Parameter = (\n        lambda: Parameter(value=0.0, default=0.0)\n    )(),\n    rot_z: Parameter = (\n        lambda: Parameter(value=0.0, default=0.0)\n    )(),\n    scale: Parameter = (\n        lambda: Parameter(value=1.0, default=1.0)\n    )(),\n)\n</code></pre> <p>               Bases: <code>ParameterSet</code></p> <p>Parameter set for a 7-parameter Helmert similarity transformation.</p> <p>Represents a 3D similarity transformation with translation, rotation, and scale.</p> <p>Attributes:</p> <ul> <li> <code>trans_x</code>               (<code>Parameter</code>)           \u2013            <p>Translation parameter in x-direction</p> </li> <li> <code>trans_y</code>               (<code>Parameter</code>)           \u2013            <p>Translation parameter in y-direction</p> </li> <li> <code>trans_z</code>               (<code>Parameter</code>)           \u2013            <p>Translation parameter in z-direction</p> </li> <li> <code>rot_x</code>               (<code>Parameter</code>)           \u2013            <p>Rotation parameter around x-axis</p> </li> <li> <code>rot_y</code>               (<code>Parameter</code>)           \u2013            <p>Rotation parameter around y-axis</p> </li> <li> <code>rot_z</code>               (<code>Parameter</code>)           \u2013            <p>Rotation parameter around z-axis</p> </li> <li> <code>scale</code>               (<code>Parameter</code>)           \u2013            <p>Scale parameter</p> </li> </ul>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.HelmertTransformation.translation","title":"translation  <code>property</code> <code>writable</code>","text":"<pre><code>translation: ndarray\n</code></pre> <p>Gets the 3D translation vector.</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: Translation vector [x, y, z]</p> </li> </ul>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.HelmertTransformation.rotation","title":"rotation  <code>property</code> <code>writable</code>","text":"<pre><code>rotation: ndarray\n</code></pre> <p>Gets the Euler rotation angles.</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: Rotation angles [rx, ry, rz] in radians (XYZ order)</p> </li> </ul>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.HelmertTransformation.rotation_set","title":"rotation_set  <code>property</code>","text":"<pre><code>rotation_set: Rotations\n</code></pre> <p>Gets the rotation as a Rotations object.</p> <p>Returns:</p> <ul> <li> <code>Rotations</code> (              <code>Rotations</code> )          \u2013            <p>Rotation object from Euler angles</p> </li> </ul>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.HelmertTransformation.rotation_matrix","title":"rotation_matrix  <code>property</code>","text":"<pre><code>rotation_matrix: ndarray\n</code></pre> <p>Gets the 3x3 rotation matrix.</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: Rotation matrix (3x3)</p> </li> </ul>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.HelmertTransformation.apply_to","title":"apply_to","text":"<pre><code>apply_to(xyz: ndarray) -&gt; ndarray\n</code></pre> <p>Applies the Helmert transformation to 3D points.</p> <p>Parameters:</p> <ul> <li> <code>xyz</code>               (<code>ndarray</code>)           \u2013            <p>Input points (Nx3 array)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: Transformed points (Nx3 array)</p> </li> </ul> Source code in <code>trajectopy\\processing\\lib\\alignment\\parameters.py</code> <pre><code>def apply_to(self, xyz: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Applies the Helmert transformation to 3D points.\n\n    Args:\n        xyz: Input points (Nx3 array)\n\n    Returns:\n        np.ndarray: Transformed points (Nx3 array)\n    \"\"\"\n    return self.translation + self.scale.value * (self.rotation_matrix @ xyz.T).T\n</code></pre>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.Leverarm","title":"Leverarm  <code>dataclass</code>","text":"<pre><code>Leverarm(\n    enabled: bool = True,\n    covariance_matrix: ndarray = (\n        lambda: zeros((0, 0), dtype=float)\n    )(),\n    x: Parameter = (\n        lambda: Parameter(\n            value=0.0,\n            default=0.0,\n            name=\"Leverarm x\",\n            enabled=False,\n            unit=METER,\n        )\n    )(),\n    y: Parameter = (\n        lambda: Parameter(\n            value=0.0,\n            default=0.0,\n            name=\"Leverarm y\",\n            enabled=False,\n            unit=METER,\n        )\n    )(),\n    z: Parameter = (\n        lambda: Parameter(\n            value=0.0,\n            default=0.0,\n            name=\"Leverarm z\",\n            enabled=False,\n            unit=METER,\n        )\n    )(),\n)\n</code></pre> <p>               Bases: <code>ParameterSet</code></p> <p>Parameter set for a leverarm offset between sensor and body frame.</p> <p>Represents the 3D offset between a sensor frame and the vehicle body frame.</p> <p>Attributes:</p> <ul> <li> <code>x</code>               (<code>Parameter</code>)           \u2013            <p>Leverarm parameter in x-direction</p> </li> <li> <code>y</code>               (<code>Parameter</code>)           \u2013            <p>Leverarm parameter in y-direction</p> </li> <li> <code>z</code>               (<code>Parameter</code>)           \u2013            <p>Leverarm parameter in z-direction</p> </li> </ul>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.Leverarm.apply_to","title":"apply_to","text":"<pre><code>apply_to(xyz: ndarray, quat_body: ndarray) -&gt; ndarray\n</code></pre> <p>Applies the leverarm to a set of positions using orientations</p> <p>Parameters:</p> <ul> <li> <code>xyz</code>               (<code>ndarray</code>)           \u2013            <p>Positions</p> </li> <li> <code>quat_body</code>               (<code>ndarray</code>)           \u2013            <p>Orientations</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: Leverarm applied positions</p> </li> </ul> Source code in <code>trajectopy\\processing\\lib\\alignment\\parameters.py</code> <pre><code>def apply_to(self, xyz: np.ndarray, quat_body: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Applies the leverarm to a set of positions using orientations\n\n    Args:\n        xyz (np.ndarray): Positions\n        quat_body (np.ndarray): Orientations\n\n    Returns:\n        np.ndarray: Leverarm applied positions\n    \"\"\"\n    if len(xyz) != len(quat_body):\n        raise ValueError(\"Dimension mismatch between positions and orientations.\")\n\n    xyz_red = np.zeros((xyz.shape))\n    rot_matrices = Rotations.from_quat(quat_body).as_matrix()\n\n    for i in range(len(xyz_red)):\n        d_rot = rot_matrices[i] @ self.values\n        xyz_red[i, :] = xyz[i, :] + d_rot\n\n    return xyz_red\n</code></pre>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.AlignmentParameters","title":"AlignmentParameters  <code>dataclass</code>","text":"<pre><code>AlignmentParameters(\n    enabled: bool = True,\n    covariance_matrix: ndarray = (\n        lambda: zeros((0, 0), dtype=float)\n    )(),\n    sim_trans_x: Parameter = (\n        lambda: Parameter(\n            value=0.0,\n            default=0.0,\n            name=\"Translation x\",\n            enabled=False,\n            unit=METER,\n        )\n    )(),\n    sim_trans_y: Parameter = (\n        lambda: Parameter(\n            value=0.0,\n            default=0.0,\n            name=\"Translation y\",\n            enabled=False,\n            unit=METER,\n        )\n    )(),\n    sim_trans_z: Parameter = (\n        lambda: Parameter(\n            value=0.0,\n            default=0.0,\n            name=\"Translation z\",\n            enabled=False,\n            unit=METER,\n        )\n    )(),\n    sim_rot_x: Parameter = (\n        lambda: Parameter(\n            value=0.0,\n            default=0.0,\n            name=\"Rotation x\",\n            enabled=False,\n            unit=RADIAN,\n        )\n    )(),\n    sim_rot_y: Parameter = (\n        lambda: Parameter(\n            value=0.0,\n            default=0.0,\n            name=\"Rotation y\",\n            enabled=False,\n            unit=RADIAN,\n        )\n    )(),\n    sim_rot_z: Parameter = (\n        lambda: Parameter(\n            value=0.0,\n            default=0.0,\n            name=\"Rotation z\",\n            enabled=False,\n            unit=RADIAN,\n        )\n    )(),\n    sim_scale: Parameter = (\n        lambda: Parameter(\n            value=1.0,\n            default=1.0,\n            name=\"Scale\",\n            enabled=False,\n            unit=SCALE,\n        )\n    )(),\n    time_shift: Parameter = (\n        lambda: Parameter(\n            value=0.0,\n            default=0.0,\n            name=\"Time Shift\",\n            enabled=False,\n            unit=SECOND,\n        )\n    )(),\n    lever_x: Parameter = (\n        lambda: Parameter(\n            value=0.0,\n            default=0.0,\n            name=\"Leverarm x\",\n            enabled=False,\n            unit=METER,\n        )\n    )(),\n    lever_y: Parameter = (\n        lambda: Parameter(\n            value=0.0,\n            default=0.0,\n            name=\"Leverarm y\",\n            enabled=False,\n            unit=METER,\n        )\n    )(),\n    lever_z: Parameter = (\n        lambda: Parameter(\n            value=0.0,\n            default=0.0,\n            name=\"Leverarm z\",\n            enabled=False,\n            unit=METER,\n        )\n    )(),\n)\n</code></pre> <p>               Bases: <code>ParameterSet</code></p> <p>Parameter set for spatio-temporal trajectory alignment.</p> <p>Contains all parameters for aligning two trajectories including similarity transformation (translation, rotation, scale), time shift, and leverarm.</p> <p>Attributes:</p> <ul> <li> <code>sim_trans_x</code>               (<code>Parameter</code>)           \u2013            <p>Similarity transformation translation in x</p> </li> <li> <code>sim_trans_y</code>               (<code>Parameter</code>)           \u2013            <p>Similarity transformation translation in y</p> </li> <li> <code>sim_trans_z</code>               (<code>Parameter</code>)           \u2013            <p>Similarity transformation translation in z</p> </li> <li> <code>sim_rot_x</code>               (<code>Parameter</code>)           \u2013            <p>Similarity transformation rotation around x</p> </li> <li> <code>sim_rot_y</code>               (<code>Parameter</code>)           \u2013            <p>Similarity transformation rotation around y</p> </li> <li> <code>sim_rot_z</code>               (<code>Parameter</code>)           \u2013            <p>Similarity transformation rotation around z</p> </li> <li> <code>sim_scale</code>               (<code>Parameter</code>)           \u2013            <p>Similarity transformation scale factor</p> </li> <li> <code>time_shift</code>               (<code>Parameter</code>)           \u2013            <p>Temporal offset between trajectories</p> </li> <li> <code>lever_x</code>               (<code>Parameter</code>)           \u2013            <p>Leverarm offset in x</p> </li> <li> <code>lever_y</code>               (<code>Parameter</code>)           \u2013            <p>Leverarm offset in y</p> </li> <li> <code>lever_z</code>               (<code>Parameter</code>)           \u2013            <p>Leverarm offset in z</p> </li> </ul>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.AlignmentParameters.sim3_matrix","title":"sim3_matrix  <code>property</code>","text":"<pre><code>sim3_matrix: ndarray\n</code></pre> <p>Gets the 4x4 similarity transformation matrix (Sim(3)).</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: 4x4 homogeneous transformation matrix</p> </li> </ul>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.AlignmentParameters.helmert","title":"helmert  <code>property</code>","text":"<pre><code>helmert: HelmertTransformation\n</code></pre> <p>Gets the Helmert similarity transformation parameters.</p> <p>Returns:</p> <ul> <li> <code>HelmertTransformation</code> (              <code>HelmertTransformation</code> )          \u2013            <p>Transformation parameters (translation, rotation, scale)</p> </li> </ul>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.AlignmentParameters.leverarm","title":"leverarm  <code>property</code>","text":"<pre><code>leverarm: Leverarm\n</code></pre> <p>Gets the leverarm offset parameters.</p> <p>Returns:</p> <ul> <li> <code>Leverarm</code> (              <code>Leverarm</code> )          \u2013            <p>Leverarm offset parameters (x, y, z)</p> </li> </ul>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.AlignmentParameters.__add__","title":"__add__","text":"<pre><code>__add__(other: AlignmentParameters) -&gt; AlignmentParameters\n</code></pre> <p>Adds parameter values from another alignment parameter set.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AlignmentParameters</code>)           \u2013            <p>AlignmentParameters to add</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AlignmentParameters</code> (              <code>AlignmentParameters</code> )          \u2013            <p>Sum of parameter values</p> </li> </ul> Source code in <code>trajectopy\\processing\\lib\\alignment\\parameters.py</code> <pre><code>def __add__(self, other: \"AlignmentParameters\") -&gt; \"AlignmentParameters\":\n    \"\"\"Adds parameter values from another alignment parameter set.\n\n    Args:\n        other: AlignmentParameters to add\n\n    Returns:\n        AlignmentParameters: Sum of parameter values\n    \"\"\"\n    return self.values + other.values\n</code></pre>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.AlignmentParameters.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: AlignmentParameters) -&gt; AlignmentParameters\n</code></pre> <p>Subtracts parameter values from another alignment parameter set.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>AlignmentParameters</code>)           \u2013            <p>AlignmentParameters to subtract</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AlignmentParameters</code> (              <code>AlignmentParameters</code> )          \u2013            <p>Difference of parameter values</p> </li> </ul> Source code in <code>trajectopy\\processing\\lib\\alignment\\parameters.py</code> <pre><code>def __sub__(self, other: \"AlignmentParameters\") -&gt; \"AlignmentParameters\":\n    \"\"\"Subtracts parameter values from another alignment parameter set.\n\n    Args:\n        other: AlignmentParameters to subtract\n\n    Returns:\n        AlignmentParameters: Difference of parameter values\n    \"\"\"\n    return self.values - other.values\n</code></pre>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.AlignmentParameters.params_labels","title":"params_labels","text":"<pre><code>params_labels(\n    enabled_only: bool = True, lower_case: bool = True\n) -&gt; List[str]\n</code></pre> <p>Gets parameter labels/names.</p> <p>Parameters:</p> <ul> <li> <code>enabled_only</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, only include enabled parameters. Defaults to True.</p> </li> <li> <code>lower_case</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, return lowercase labels. Defaults to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>List[str]: List of parameter labels</p> </li> </ul> Source code in <code>trajectopy\\processing\\lib\\alignment\\parameters.py</code> <pre><code>def params_labels(self, enabled_only: bool = True, lower_case: bool = True) -&gt; List[str]:\n    \"\"\"Gets parameter labels/names.\n\n    Args:\n        enabled_only: If True, only include enabled parameters. Defaults to True.\n        lower_case: If True, return lowercase labels. Defaults to True.\n\n    Returns:\n        List[str]: List of parameter labels\n    \"\"\"\n    return self.to_name_list(enabled_only=enabled_only, lower_case=lower_case)\n</code></pre>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.AlignmentParameters.from_settings","title":"from_settings  <code>classmethod</code>","text":"<pre><code>from_settings(\n    settings: AlignmentEstimationSettings,\n) -&gt; AlignmentParameters\n</code></pre> <p>Creates AlignmentParameters from estimation settings.</p> <p>Parameters:</p> <ul> <li> <code>settings</code>               (<code>AlignmentEstimationSettings</code>)           \u2013            <p>Settings specifying which parameters to enable</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AlignmentParameters</code> (              <code>AlignmentParameters</code> )          \u2013            <p>New instance with parameters enabled per settings</p> </li> </ul> Source code in <code>trajectopy\\processing\\lib\\alignment\\parameters.py</code> <pre><code>@classmethod\ndef from_settings(cls, settings: AlignmentEstimationSettings) -&gt; \"AlignmentParameters\":\n    \"\"\"Creates AlignmentParameters from estimation settings.\n\n    Args:\n        settings: Settings specifying which parameters to enable\n\n    Returns:\n        AlignmentParameters: New instance with parameters enabled per settings\n    \"\"\"\n    return cls(\n        sim_trans_x=Parameter(enabled=settings.translation_x, value=0.0, default=0.0),\n        sim_trans_y=Parameter(enabled=settings.translation_x, value=0.0, default=0.0),\n        sim_trans_z=Parameter(enabled=settings.translation_x, value=0.0, default=0.0),\n        sim_rot_x=Parameter(enabled=settings.rotation_x, value=0.0, default=0.0),\n        sim_rot_y=Parameter(enabled=settings.rotation_y, value=0.0, default=0.0),\n        sim_rot_z=Parameter(enabled=settings.rotation_z, value=0.0, default=0.0),\n        sim_scale=Parameter(enabled=settings.scale, value=1.0, default=1.0),\n        time_shift=Parameter(enabled=settings.time_shift, value=0.0, default=0.0),\n        lever_x=Parameter(enabled=settings.leverarm_x, value=0.0, default=0.0),\n        lever_y=Parameter(enabled=settings.leverarm_y, value=0.0, default=0.0),\n        lever_z=Parameter(enabled=settings.leverarm_z, value=0.0, default=0.0),\n    )\n</code></pre>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.AlignmentParameters.apply_settings","title":"apply_settings","text":"<pre><code>apply_settings(\n    settings: AlignmentEstimationSettings,\n) -&gt; None\n</code></pre> <p>Applies estimation settings by enabling or disabling parameters.</p> <p>Parameters:</p> <ul> <li> <code>settings</code>               (<code>AlignmentEstimationSettings</code>)           \u2013            <p>Settings specifying which parameters to enable</p> </li> </ul> Source code in <code>trajectopy\\processing\\lib\\alignment\\parameters.py</code> <pre><code>def apply_settings(self, settings: AlignmentEstimationSettings) -&gt; None:\n    \"\"\"Applies estimation settings by enabling or disabling parameters.\n\n    Args:\n        settings: Settings specifying which parameters to enable\n    \"\"\"\n    self.sim_trans_x.enabled = settings.translation_x and settings.helmert_enabled\n    self.sim_trans_y.enabled = settings.translation_y and settings.helmert_enabled\n    self.sim_trans_z.enabled = settings.translation_z and settings.helmert_enabled\n    self.sim_rot_x.enabled = settings.rotation_x and settings.helmert_enabled\n    self.sim_rot_y.enabled = settings.rotation_y and settings.helmert_enabled\n    self.sim_rot_z.enabled = settings.rotation_z and settings.helmert_enabled\n    self.sim_scale.enabled = settings.scale and settings.helmert_enabled\n\n    self.time_shift.enabled = settings.time_shift_enabled\n\n    self.lever_x.enabled = settings.leverarm_x and settings.leverarm_enabled\n    self.lever_y.enabled = settings.leverarm_y and settings.leverarm_enabled\n    self.lever_z.enabled = settings.leverarm_z and settings.leverarm_enabled\n</code></pre>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.AlignmentParameters.to_file","title":"to_file","text":"<pre><code>to_file(filename: str) -&gt; None\n</code></pre> <p>Writes the alignment parameters to a file</p> <p>All parameters are written to the file no matter if they are enabled or not. If they are not enabled, the default value is written. Enabled parameters are marked with a 1, disabled with a 0. The order of the parameters is:</p> <ul> <li>Translation x</li> <li>Translation y</li> <li>Translation z</li> <li>Rotation x</li> <li>Rotation y</li> <li>Rotation z</li> <li>Scale</li> <li>Time Shift</li> <li>Leverarm x</li> <li>Leverarm y</li> <li>Leverarm z</li> </ul> <p>Besides the parameters, the covariance matrix is written to the file. The covariance matrix is written row by row next to the parameters.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>Path to the file</p> </li> </ul> Source code in <code>trajectopy\\processing\\lib\\alignment\\parameters.py</code> <pre><code>def to_file(self, filename: str) -&gt; None:\n    \"\"\"Writes the alignment parameters to a file\n\n    All parameters are written to the file no matter if they are enabled or not.\n    If they are not enabled, the default value is written. Enabled parameters are\n    marked with a 1, disabled with a 0. The order of the parameters is:\n\n    - Translation x\n    - Translation y\n    - Translation z\n    - Rotation x\n    - Rotation y\n    - Rotation z\n    - Scale\n    - Time Shift\n    - Leverarm x\n    - Leverarm y\n    - Leverarm z\n\n    Besides the parameters, the covariance matrix is written to the file. The covariance\n    matrix is written row by row next to the parameters.\n\n    Args:\n        filename (str): Path to the file\n    \"\"\"\n    dataframe = pd.DataFrame(np.c_[self.values, self.covariance_matrix])\n    dataframe.to_csv(filename, index=False, header=False)\n</code></pre>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.AlignmentParameters.to_dataframe","title":"to_dataframe","text":"<pre><code>to_dataframe() -&gt; DataFrame\n</code></pre> <p>Converts alignment parameters to a pandas DataFrame.</p> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>pd.DataFrame: DataFrame with parameter values, enabled flags, and covariance matrix</p> </li> </ul> Source code in <code>trajectopy\\processing\\lib\\alignment\\parameters.py</code> <pre><code>def to_dataframe(self) -&gt; pd.DataFrame:\n    \"\"\"Converts alignment parameters to a pandas DataFrame.\n\n    Returns:\n        pd.DataFrame: DataFrame with parameter values, enabled flags, and covariance matrix\n    \"\"\"\n    variances = pd.DataFrame(self.covariance_matrix)\n    parameters = pd.DataFrame({0: self.values, 1: self.enabled_bool_list})\n    return pd.concat([parameters, variances], axis=1)\n</code></pre>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.AlignmentParameters.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(filename: str) -&gt; AlignmentParameters\n</code></pre> <p>Reads the alignment parameters from a file</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>Path to the file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AlignmentParameters</code> (              <code>AlignmentParameters</code> )          \u2013            <p>AlignmentParameters instance</p> </li> </ul> Source code in <code>trajectopy\\processing\\lib\\alignment\\parameters.py</code> <pre><code>@classmethod\ndef from_file(cls, filename: str) -&gt; \"AlignmentParameters\":\n    \"\"\"Reads the alignment parameters from a file\n\n    Args:\n        filename (str): Path to the file\n\n    Returns:\n        AlignmentParameters: AlignmentParameters instance\n    \"\"\"\n    alignment_data = pd.read_csv(filename, comment=\"#\", header=None)\n    params: AlignmentParameters = cls()\n    params.values = alignment_data.iloc[:11, 0].to_numpy()\n    params.enabled_bool_list = [str(item).lower() != \"false\" for item in alignment_data.iloc[:11, 1].to_list()]\n\n    if alignment_data.shape[1] &gt; 2:\n        params.set_covariance_matrix(alignment_data.iloc[:11, 2:].to_numpy())\n\n    return params\n</code></pre>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.AlignmentParameters.to_estimation_settings","title":"to_estimation_settings","text":"<pre><code>to_estimation_settings() -&gt; AlignmentEstimationSettings\n</code></pre> <p>Converts alignment parameters to estimation settings.</p> <p>Returns:</p> <ul> <li> <code>AlignmentEstimationSettings</code> (              <code>AlignmentEstimationSettings</code> )          \u2013            <p>Settings object with enabled flags from parameters</p> </li> </ul> Source code in <code>trajectopy\\processing\\lib\\alignment\\parameters.py</code> <pre><code>def to_estimation_settings(self) -&gt; AlignmentEstimationSettings:\n    \"\"\"Converts alignment parameters to estimation settings.\n\n    Returns:\n        AlignmentEstimationSettings: Settings object with enabled flags from parameters\n    \"\"\"\n    return AlignmentEstimationSettings(\n        translation_x=self.sim_trans_x.enabled,\n        translation_y=self.sim_trans_y.enabled,\n        translation_z=self.sim_trans_z.enabled,\n        rotation_x=self.sim_rot_x.enabled,\n        rotation_y=self.sim_rot_y.enabled,\n        rotation_z=self.sim_rot_z.enabled,\n        scale=self.sim_scale.enabled,\n        time_shift=self.time_shift.enabled,\n        leverarm_x=self.lever_x.enabled,\n        leverarm_y=self.lever_y.enabled,\n        leverarm_z=self.lever_z.enabled,\n    )\n</code></pre>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.SensorRotationParameters","title":"SensorRotationParameters  <code>dataclass</code>","text":"<pre><code>SensorRotationParameters(\n    enabled: bool = True,\n    covariance_matrix: ndarray = (\n        lambda: zeros((0, 0), dtype=float)\n    )(),\n    sensor_rot_x: Parameter = (\n        lambda: Parameter(\n            value=0.0,\n            default=0.0,\n            name=\"Sensor Rotation x\",\n            enabled=False,\n            unit=RADIAN,\n        )\n    )(),\n    sensor_rot_y: Parameter = (\n        lambda: Parameter(\n            value=0.0,\n            default=0.0,\n            name=\"Sensor Rotation y\",\n            enabled=False,\n            unit=RADIAN,\n        )\n    )(),\n    sensor_rot_z: Parameter = (\n        lambda: Parameter(\n            value=0.0,\n            default=0.0,\n            name=\"Sensor Rotation z\",\n            enabled=False,\n            unit=RADIAN,\n        )\n    )(),\n)\n</code></pre> <p>               Bases: <code>ParameterSet</code></p> <p>Parameter set for sensor body-frame rotation.</p> <p>Represents the rotational offset between the sensor frame and body frame.</p> <p>Attributes:</p> <ul> <li> <code>sensor_rot_x</code>               (<code>Parameter</code>)           \u2013            <p>Sensor rotation around x-axis</p> </li> <li> <code>sensor_rot_y</code>               (<code>Parameter</code>)           \u2013            <p>Sensor rotation around y-axis</p> </li> <li> <code>sensor_rot_z</code>               (<code>Parameter</code>)           \u2013            <p>Sensor rotation around z-axis</p> </li> </ul>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.SensorRotationParameters.rotation","title":"rotation  <code>property</code>","text":"<pre><code>rotation: ndarray\n</code></pre> <p>Gets the sensor rotation Euler angles.</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: Rotation angles [rx, ry, rz] in radians (XYZ order)</p> </li> </ul>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.SensorRotationParameters.rotation_set","title":"rotation_set  <code>property</code>","text":"<pre><code>rotation_set: Rotations\n</code></pre> <p>Gets the sensor rotation as a Rotations object.</p> <p>Returns:</p> <ul> <li> <code>Rotations</code> (              <code>Rotations</code> )          \u2013            <p>Rotation object from Euler angles</p> </li> </ul>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.SensorRotationParameters.rotation_matrix","title":"rotation_matrix  <code>property</code>","text":"<pre><code>rotation_matrix: ndarray\n</code></pre> <p>Gets the 3x3 sensor rotation matrix.</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: Rotation matrix (3x3)</p> </li> </ul>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.SensorRotationParameters.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(filename: str) -&gt; SensorRotationParameters\n</code></pre> <p>Reads sensor rotation parameters from a file.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>Path to the alignment file (must contain 14 lines)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SensorRotationParameters</code> (              <code>SensorRotationParameters</code> )          \u2013            <p>Loaded sensor rotation parameters</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If file doesn't contain exactly 14 lines</p> </li> </ul> Source code in <code>trajectopy\\processing\\lib\\alignment\\parameters.py</code> <pre><code>@classmethod\ndef from_file(cls, filename: str) -&gt; \"SensorRotationParameters\":\n    \"\"\"Reads sensor rotation parameters from a file.\n\n    Args:\n        filename: Path to the alignment file (must contain 14 lines)\n\n    Returns:\n        SensorRotationParameters: Loaded sensor rotation parameters\n\n    Raises:\n        ValueError: If file doesn't contain exactly 14 lines\n    \"\"\"\n    alignment_data = pd.read_csv(filename, comment=\"#\", header=None)\n\n    if len(alignment_data) != 14:\n        raise ValueError(\"Alignment file with sensor rotation information must contain 14 lines!\")\n    enabled_bool_list = [str(item).lower() != \"false\" for item in alignment_data.iloc[11:, 1].to_list()]\n    params: SensorRotationParameters = cls()\n    params.values = alignment_data.iloc[11:, 0].to_numpy()\n    params.enabled_bool_list = enabled_bool_list\n    return params\n</code></pre>"},{"location":"api/processing/parameters/#trajectopy.processing.lib.alignment.parameters.SensorRotationParameters.to_file","title":"to_file","text":"<pre><code>to_file(filename: str) -&gt; None\n</code></pre> <p>Appends sensor rotation parameters to a file.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>Path to the file to append to</p> </li> </ul> Source code in <code>trajectopy\\processing\\lib\\alignment\\parameters.py</code> <pre><code>def to_file(self, filename: str) -&gt; None:\n    \"\"\"Appends sensor rotation parameters to a file.\n\n    Args:\n        filename: Path to the file to append to\n    \"\"\"\n    with open(filename, mode=\"a\", encoding=\"utf-8\") as file:\n        file.write(f\"{self.sensor_rot_x.value},{self.sensor_rot_x.enabled}\\n\")\n        file.write(f\"{self.sensor_rot_y.value},{self.sensor_rot_y.enabled}\\n\")\n        file.write(f\"{self.sensor_rot_z.value},{self.sensor_rot_z.enabled}\\n\")\n</code></pre>"},{"location":"api/processing/sorting/","title":"Sorting","text":""},{"location":"api/processing/sorting/#trajectopy.processing.sorting","title":"sorting","text":""},{"location":"api/processing/sorting/#trajectopy.processing.sorting.sort_spatially","title":"sort_spatially","text":"<pre><code>sort_spatially(\n    trajectory: Trajectory,\n    sorting_settings: SortingSettings = SortingSettings(),\n    inplace: bool = True,\n) -&gt; Trajectory\n</code></pre> <p>Sorts the trajectory spatially. This is only useful for trajectories that describe a closed loop without intersections.</p> <p>Parameters:</p> <ul> <li> <code>trajectory</code>               (<code>Trajectory</code>)           \u2013            <p>Trajectory to sort.</p> </li> <li> <code>sorting_settings</code>               (<code>SortingSettings</code>, default:                   <code>SortingSettings()</code> )           \u2013            <p>Sorting settings.</p> </li> <li> <code>inplace</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to sort the trajectory in-place. Defaults to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Trajectory</code> (              <code>Trajectory</code> )          \u2013            <p>Sorted trajectory.</p> </li> </ul> Source code in <code>trajectopy\\processing\\sorting.py</code> <pre><code>def sort_spatially(\n    trajectory: Trajectory, sorting_settings: SortingSettings = SortingSettings(), inplace: bool = True\n) -&gt; Trajectory:\n    \"\"\"\n    Sorts the trajectory spatially. This is only useful for trajectories\n    that describe a closed loop without intersections.\n\n    Args:\n        trajectory (Trajectory): Trajectory to sort.\n        sorting_settings (SortingSettings): Sorting settings.\n        inplace (bool, optional): Whether to sort the trajectory in-place. Defaults to True.\n\n    Returns:\n        Trajectory: Sorted trajectory.\n\n    \"\"\"\n    sort_idx, arc_lengths = _sort_xyz(xyz=trajectory.positions.xyz, settings=sorting_settings)\n    arg_sort_sort_idx = np.argsort(sort_idx)\n    trajectory = trajectory.mask(sorted(sort_idx), inplace=inplace)\n    trajectory.path_lengths = arc_lengths[arg_sort_sort_idx]\n    trajectory.sorting = Sorting.PATH_LENGTH\n    return trajectory\n</code></pre>"},{"location":"api/processing/sorting/#trajectopy.processing.sorting.divide_into_laps","title":"divide_into_laps","text":"<pre><code>divide_into_laps(\n    trajectory: Trajectory,\n    sorting_settings: SortingSettings = SortingSettings(),\n    return_lap_indices: bool = False,\n) -&gt; Union[\n    List[Trajectory], Tuple[List[Trajectory], ndarray]\n]\n</code></pre> <p>Divides the trajectory into laps. This is only useful for trajectories that describe a closed loop without intersections.</p> <p>Parameters:</p> <ul> <li> <code>trajectory</code>               (<code>Trajectory</code>)           \u2013            <p>Trajectory to divide.</p> </li> <li> <code>sorting_settings</code>               (<code>SortingSettings</code>, default:                   <code>SortingSettings()</code> )           \u2013            <p>Sorting settings.</p> </li> <li> <code>return_lap_indices</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to return lap indices. Defaults to False.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Union[List[Trajectory], Tuple[List[Trajectory], ndarray]]</code>           \u2013            <p>List[Trajectory]: List of trajectories, each representing a lap.</p> </li> </ul> Source code in <code>trajectopy\\processing\\sorting.py</code> <pre><code>def divide_into_laps(\n    trajectory: Trajectory, sorting_settings: SortingSettings = SortingSettings(), return_lap_indices: bool = False\n) -&gt; Union[List[Trajectory], Tuple[List[Trajectory], np.ndarray]]:\n    \"\"\"\n    Divides the trajectory into laps. This is only useful for trajectories\n    that describe a closed loop without intersections.\n\n    Args:\n        trajectory (Trajectory): Trajectory to divide.\n        sorting_settings (SortingSettings): Sorting settings.\n        return_lap_indices (bool, optional): Whether to return lap indices. Defaults to False.\n\n    Returns:\n        List[Trajectory]: List of trajectories, each representing a lap.\n\n    \"\"\"\n    if trajectory.sorting != Sorting.PATH_LENGTH:\n        trajectory = sort_spatially(trajectory=trajectory, sorting_settings=sorting_settings, inplace=False)\n    else:\n        trajectory = trajectory.copy()\n\n    arc_length_diffs = np.diff(trajectory.path_lengths)\n    arc_length_threshold = 0.95 * np.max(trajectory.path_lengths)\n    lap_indices = np.r_[0, np.where(np.abs(arc_length_diffs) &gt; arc_length_threshold)[0], len(trajectory)]\n\n    # divide into laps\n    laps = []\n    for i in range(len(lap_indices) - 1):\n        lap = trajectory.mask(np.arange(lap_indices[i], lap_indices[i + 1]), inplace=False)\n        laps.append(lap)\n\n    return laps if (not return_lap_indices) else (laps, lap_indices)\n</code></pre>"},{"location":"api/results/alignment_result/","title":"Alignment Result","text":""},{"location":"api/results/alignment_result/#trajectopy.results.alignment_result","title":"alignment_result","text":""},{"location":"api/results/alignment_result/#trajectopy.results.alignment_result.AlignmentResult","title":"AlignmentResult  <code>dataclass</code>","text":"<pre><code>AlignmentResult(\n    name: str = \"Alignment Result\",\n    position_parameters: AlignmentParameters = AlignmentParameters(),\n    rotation_parameters: SensorRotationParameters = SensorRotationParameters(),\n    estimation_of: AlignmentEstimationSettings = AlignmentEstimationSettings(),\n    converged: bool = True,\n)\n</code></pre> <p>Class to store the result of an alignment.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name of the result.</p> </li> <li> <code>position_parameters</code>               (<code>AlignmentParameters</code>)           \u2013            <p>Estimated position alignment parameters.</p> </li> <li> <code>rotation_parameters</code>               (<code>SensorRotationParameters</code>)           \u2013            <p>Estimated rotation alignment parameters.</p> </li> <li> <code>estimation_of</code>               (<code>AlignmentEstimationSettings</code>)           \u2013            <p>Settings defining which parameters were estimated.</p> </li> <li> <code>converged</code>               (<code>bool</code>)           \u2013            <p>Whether the estimation converged.</p> </li> </ul>"},{"location":"api/results/alignment_result/#trajectopy.results.alignment_result.AlignmentResult.to_file","title":"to_file","text":"<pre><code>to_file(filename: str) -&gt; None\n</code></pre> <p>Save the result to a file.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>Path to the file.</p> </li> </ul> Source code in <code>trajectopy\\results\\alignment_result.py</code> <pre><code>def to_file(self, filename: str) -&gt; None:\n    \"\"\"\n    Save the result to a file.\n\n    Args:\n        filename (str): Path to the file.\n    \"\"\"\n    if self.position_parameters is None:\n        raise ValueError(\"No estimated parameters available!\")\n\n    with open(filename, \"a\", newline=\"\\n\", encoding=\"utf-8\") as file:\n        file.write(f\"#name {self.name}\\n\")\n\n    self.position_parameters.to_dataframe().to_csv(\n        filename, header=False, index=False, mode=\"a\", float_format=\"%.15f\"\n    )\n    self.rotation_parameters.to_file(filename=filename)\n</code></pre>"},{"location":"api/results/alignment_result/#trajectopy.results.alignment_result.AlignmentResult.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(filename: str) -&gt; AlignmentResult\n</code></pre> <p>Load the result from a file.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>Path to the file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AlignmentResult</code> (              <code>AlignmentResult</code> )          \u2013            <p>The loaded result.</p> </li> </ul> Source code in <code>trajectopy\\results\\alignment_result.py</code> <pre><code>@classmethod\ndef from_file(cls, filename: str) -&gt; \"AlignmentResult\":\n    \"\"\"\n    Load the result from a file.\n\n    Args:\n        filename (str): Path to the file.\n\n    Returns:\n        AlignmentResult: The loaded result.\n    \"\"\"\n    header_data = HeaderData.from_file(filename)\n    estimated_parameters = AlignmentParameters.from_file(filename)\n    sensor_rot_parameters = SensorRotationParameters.from_file(filename)\n    return cls(\n        name=str(header_data.data.get(\"name\", \"Alignment\")),\n        position_parameters=estimated_parameters,\n        estimation_of=AlignmentEstimationSettings.from_bool_list(\n            estimated_parameters.enabled_bool_list + sensor_rot_parameters.enabled_bool_list\n        ),\n        rotation_parameters=sensor_rot_parameters,\n    )\n</code></pre>"},{"location":"api/results/ate_result/","title":"ATE Result","text":""},{"location":"api/results/ate_result/#trajectopy.results.ate_result","title":"ate_result","text":""},{"location":"api/results/ate_result/#trajectopy.results.ate_result.AbsoluteTrajectoryDeviations","title":"AbsoluteTrajectoryDeviations  <code>dataclass</code>","text":"<pre><code>AbsoluteTrajectoryDeviations(\n    pos_dev: ndarray,\n    directed_pos_dev: ndarray,\n    rot_dev: Union[Rotations, None] = None,\n    rotations_used: bool = False,\n)\n</code></pre> <p>Container holding absolute pose deviations between two trajectories.</p> <p>The arrays stored in this dataclass represent per-epoch deviations after an optional temporal/spatial alignment of a reference (ground truth) and a test trajectory. They are later aggregated by <code>ATEResult</code> to derive metrics such as mean/median Absolute Trajectory Error (ATE), directional bias, and RMS statistics.</p> <p>Attributes:</p> <ul> <li> <code>pos_dev</code>               (<code>ndarray</code>)           \u2013            <p>3D array of absolute position deviation vectors in meters. Shape is (N, 3) for N deviation vectors with x, y, z components. These deviations are directly depending on the definition of the coordinate frame of the trajectories.</p> </li> <li> <code>directed_pos_dev</code>               (<code>ndarray</code>)           \u2013            <p>3D array of directed position deviation vectors (e.g. along-track, horizontal/vertical cross-track) in meters. Shape is (N, 3). These deviations are independent of the global coordinate frame, as they are derived based on the along-track direction of the trajectory.</p> </li> <li> <code>rot_dev</code>               (<code>Rotations | None</code>)           \u2013            <p>Optional orientation deviations represented as a <code>Rotations</code> instance (radians). <code>None</code> if rotational evaluation was not performed.</p> </li> <li> <code>rotations_used</code>               (<code>bool</code>)           \u2013            <p>Indicates whether trajectory rotation information was employed to derive the direction frame for <code>directed_pos_dev</code>. If False, directional decomposition has relied on positional differences only.</p> </li> </ul>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult","title":"ATEResult","text":"<pre><code>ATEResult(\n    trajectory: Trajectory,\n    abs_dev: AbsoluteTrajectoryDeviations,\n    name: str = \"\",\n)\n</code></pre> <p>This class represents a set of absolute trajectory deviations</p> <p>Absolute trajectory deviations describe absolute pose deviations between two trajectories. The deviations are calculated by comparing pairs of positions and orientations in the test and reference trajectory.</p> <p>Attributes:</p> <ul> <li> <code>trajectory</code>               (<code>Trajectory</code>)           \u2013            <p>The trajectory the deviations are belonging to</p> </li> <li> <code>abs_dev</code>               (<code>AbsoluteTrajectoryDeviations</code>)           \u2013            <p>The absolute trajectory deviations</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the result</p> </li> </ul> Source code in <code>trajectopy\\results\\ate_result.py</code> <pre><code>def __init__(\n    self,\n    trajectory: Trajectory,\n    abs_dev: AbsoluteTrajectoryDeviations,\n    name: str = \"\",\n) -&gt; None:\n    self.name = name or trajectory.name\n    self.trajectory = trajectory\n    self.abs_dev = abs_dev\n</code></pre>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.index","title":"index  <code>property</code>","text":"<pre><code>index: ndarray\n</code></pre> <p>Returns the variable that currently parametrizes the trajectory.</p> <p>Depending on the sorting of the trajectory, this is either time or arc length.</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: Current independent variable array (time or path-length).</p> </li> </ul>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.sorted_abs_rot_dev","title":"sorted_abs_rot_dev  <code>property</code>","text":"<pre><code>sorted_abs_rot_dev: Rotations\n</code></pre> <p>Returns absolute rotation deviations sorted according to the trajectory's sorting index.</p> <p>Returns:</p> <ul> <li> <code>Rotations</code> (              <code>Rotations</code> )          \u2013            <p>Sorted absolute rotation deviations.</p> </li> </ul>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.has_orientation","title":"has_orientation  <code>property</code>","text":"<pre><code>has_orientation: bool\n</code></pre> <p>Returns True if orientation is available.</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if rotation deviations are available, False otherwise.</p> </li> </ul>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.pos_dev_x","title":"pos_dev_x  <code>property</code>","text":"<pre><code>pos_dev_x: ndarray\n</code></pre> <p>Returns x deviations</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.pos_dev_y","title":"pos_dev_y  <code>property</code>","text":"<pre><code>pos_dev_y: ndarray\n</code></pre> <p>Returns y deviations</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.pos_dev_z","title":"pos_dev_z  <code>property</code>","text":"<pre><code>pos_dev_z: ndarray\n</code></pre> <p>Returns z deviations</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.pos_bias_x","title":"pos_bias_x  <code>property</code>","text":"<pre><code>pos_bias_x: float\n</code></pre> <p>Returns x bias</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.pos_bias_y","title":"pos_bias_y  <code>property</code>","text":"<pre><code>pos_bias_y: float\n</code></pre> <p>Returns y bias</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.pos_bias_z","title":"pos_bias_z  <code>property</code>","text":"<pre><code>pos_bias_z: float\n</code></pre> <p>Returns z bias</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.pos_bias_cross_h","title":"pos_bias_cross_h  <code>property</code>","text":"<pre><code>pos_bias_cross_h: float\n</code></pre> <p>Returns horizontal cross track bias</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.pos_bias_cross_v","title":"pos_bias_cross_v  <code>property</code>","text":"<pre><code>pos_bias_cross_v: float\n</code></pre> <p>Returns vertical cross track bias</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.pos_bias_along","title":"pos_bias_along  <code>property</code>","text":"<pre><code>pos_bias_along: float\n</code></pre> <p>Returns along track bias</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.rot_dev_x","title":"rot_dev_x  <code>property</code>","text":"<pre><code>rot_dev_x: ndarray\n</code></pre> <p>Returns roll deviations</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.rot_dev_y","title":"rot_dev_y  <code>property</code>","text":"<pre><code>rot_dev_y: ndarray\n</code></pre> <p>Returns pitch deviations</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.rot_dev_z","title":"rot_dev_z  <code>property</code>","text":"<pre><code>rot_dev_z: ndarray\n</code></pre> <p>Returns yaw deviations</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.rot_bias_xyz","title":"rot_bias_xyz  <code>cached</code> <code>property</code>","text":"<pre><code>rot_bias_xyz: ndarray\n</code></pre> <p>Returns roll, pitch and yaw bias</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.rot_bias_x","title":"rot_bias_x  <code>property</code>","text":"<pre><code>rot_bias_x: ndarray\n</code></pre> <p>Returns roll bias</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.rot_bias_y","title":"rot_bias_y  <code>property</code>","text":"<pre><code>rot_bias_y: ndarray\n</code></pre> <p>Returns pitch bias</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.rot_bias_z","title":"rot_bias_z  <code>property</code>","text":"<pre><code>rot_bias_z: ndarray\n</code></pre> <p>Returns yaw bias</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.pos_dev_along","title":"pos_dev_along  <code>property</code>","text":"<pre><code>pos_dev_along: ndarray\n</code></pre> <p>Returns deviations of along track deviations</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.pos_dev_cross_h","title":"pos_dev_cross_h  <code>property</code>","text":"<pre><code>pos_dev_cross_h: ndarray\n</code></pre> <p>Returns deviations of horizontal cross track deviations</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.pos_dev_cross_v","title":"pos_dev_cross_v  <code>property</code>","text":"<pre><code>pos_dev_cross_v: ndarray\n</code></pre> <p>Returns deviations of vertical cross track deviations</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.rot_dev_xyz","title":"rot_dev_xyz  <code>cached</code> <code>property</code>","text":"<pre><code>rot_dev_xyz: ndarray\n</code></pre> <p>Returns rpy deviations</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.pos_dev_comb","title":"pos_dev_comb  <code>property</code>","text":"<pre><code>pos_dev_comb: ndarray\n</code></pre> <p>Returns position deviations combined using the L2 norm</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.rot_dev_comb","title":"rot_dev_comb  <code>property</code>","text":"<pre><code>rot_dev_comb: ndarray\n</code></pre> <p>Returns rotation deviations as single rotation angles</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.pos_dev_rms","title":"pos_dev_rms  <code>property</code>","text":"<pre><code>pos_dev_rms: float\n</code></pre> <p>Returns RMS of 3d positions</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.pos_ate","title":"pos_ate  <code>property</code>","text":"<pre><code>pos_ate: float\n</code></pre> <p>Returns mean of 3d position deviations</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.pos_dev_max","title":"pos_dev_max  <code>property</code>","text":"<pre><code>pos_dev_max: float\n</code></pre> <p>Returns max of 3d position deviations</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.pos_dev_min","title":"pos_dev_min  <code>property</code>","text":"<pre><code>pos_dev_min: float\n</code></pre> <p>Returns min of 3d position deviations</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.pos_dev_median","title":"pos_dev_median  <code>property</code>","text":"<pre><code>pos_dev_median: float\n</code></pre> <p>Returns min of 3d position deviations</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.pos_dev_std","title":"pos_dev_std  <code>property</code>","text":"<pre><code>pos_dev_std: float\n</code></pre> <p>Returns std of 3d position deviations</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.rot_dev_rms","title":"rot_dev_rms  <code>property</code>","text":"<pre><code>rot_dev_rms: float\n</code></pre> <p>Returns RMS of rotations</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.rot_dev_std","title":"rot_dev_std  <code>property</code>","text":"<pre><code>rot_dev_std: float\n</code></pre> <p>Returns STD of rotations</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.rot_ate","title":"rot_ate  <code>property</code>","text":"<pre><code>rot_ate: float\n</code></pre> <p>Returns mean of rotation deviations</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.rot_dev_median","title":"rot_dev_median  <code>property</code>","text":"<pre><code>rot_dev_median: float\n</code></pre> <p>Returns median of rotations</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.rot_dev_min","title":"rot_dev_min  <code>property</code>","text":"<pre><code>rot_dev_min: float\n</code></pre> <p>Returns min of rotations</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.rot_dev_max","title":"rot_dev_max  <code>property</code>","text":"<pre><code>rot_dev_max: float\n</code></pre> <p>Returns max of rotations</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.pos_rms_along","title":"pos_rms_along  <code>property</code>","text":"<pre><code>pos_rms_along: float\n</code></pre> <p>Returns RMS of along track deviations</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.pos_rms_cross_h","title":"pos_rms_cross_h  <code>property</code>","text":"<pre><code>pos_rms_cross_h: float\n</code></pre> <p>Returns RMS of horizontal cross track deviations</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.pos_rms_cross_v","title":"pos_rms_cross_v  <code>property</code>","text":"<pre><code>pos_rms_cross_v: float\n</code></pre> <p>Returns RMS of vertical cross track deviations</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.pos_rms_x","title":"pos_rms_x  <code>property</code>","text":"<pre><code>pos_rms_x: float\n</code></pre> <p>Returns RMS of x deviations</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.pos_rms_y","title":"pos_rms_y  <code>property</code>","text":"<pre><code>pos_rms_y: float\n</code></pre> <p>Returns RMS of y deviations</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.pos_rms_z","title":"pos_rms_z  <code>property</code>","text":"<pre><code>pos_rms_z: float\n</code></pre> <p>Returns RMS of z deviations</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.rot_rms_x","title":"rot_rms_x  <code>property</code>","text":"<pre><code>rot_rms_x: float\n</code></pre> <p>Returns RMS of roll deviations</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.rot_rms_y","title":"rot_rms_y  <code>property</code>","text":"<pre><code>rot_rms_y: float\n</code></pre> <p>Returns RMS of pitch deviations</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.rot_rms_z","title":"rot_rms_z  <code>property</code>","text":"<pre><code>rot_rms_z: float\n</code></pre> <p>Returns RMS of yaw deviations</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.columns","title":"columns  <code>property</code>","text":"<pre><code>columns: List[str]\n</code></pre> <p>Returns the column names of the dataframe</p>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.remove_ate_above","title":"remove_ate_above","text":"<pre><code>remove_ate_above(threshold: float) -&gt; None\n</code></pre> <p>Clips the ATE at a given value.</p> <p>This is useful to remove outliers from the ATE.</p> <p>Parameters:</p> <ul> <li> <code>threshold</code>               (<code>float</code>)           \u2013            <p>Maximum ATE value to keep.</p> </li> </ul> Source code in <code>trajectopy\\results\\ate_result.py</code> <pre><code>def remove_ate_above(self, threshold: float) -&gt; None:\n    \"\"\"Clips the ATE at a given value.\n\n    This is useful to remove outliers from the ATE.\n\n    Args:\n        threshold (float): Maximum ATE value to keep.\n    \"\"\"\n    if threshold &lt;= 0.0:\n        return\n\n    ate_below_idx = [dev &lt; threshold for dev in self.pos_dev_comb]\n    self.trajectory.mask(ate_below_idx)\n\n    self.abs_dev.pos_dev = self.abs_dev.pos_dev[ate_below_idx]\n    self.abs_dev.directed_pos_dev = self.abs_dev.directed_pos_dev[ate_below_idx]\n\n    if self.abs_dev.rot_dev is not None:\n        self.abs_dev.rot_dev = Rotations.from_euler(\n            angles=self.abs_dev.rot_dev.as_euler(seq=\"xyz\")[ate_below_idx],\n            seq=\"xyz\",\n        )\n</code></pre>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.to_dataframe","title":"to_dataframe","text":"<pre><code>to_dataframe() -&gt; DataFrame\n</code></pre> <p>Exports results as pandas dataframe</p> Source code in <code>trajectopy\\results\\ate_result.py</code> <pre><code>def to_dataframe(self) -&gt; pd.DataFrame:\n    \"\"\"\n    Exports results as pandas dataframe\n    \"\"\"\n    trajectory_data = np.c_[\n        self.trajectory.timestamps,\n        self.trajectory.path_lengths,\n        self.trajectory.positions.xyz,\n    ]\n\n    if self.trajectory.has_orientation:\n        trajectory_data = np.c_[trajectory_data, self.trajectory.rotations.as_quat()]\n\n    deviation_data = np.c_[self.abs_dev.pos_dev, self.abs_dev.directed_pos_dev]\n\n    if self.abs_dev.rot_dev:\n        deviation_data = np.c_[deviation_data, self.abs_dev.rot_dev.as_quat()]\n\n    all_data = np.c_[trajectory_data, deviation_data]\n\n    return pd.DataFrame(all_data, columns=self.columns)\n</code></pre>"},{"location":"api/results/ate_result/#trajectopy.results.ate_result.ATEResult.to_file","title":"to_file","text":"<pre><code>to_file(filename: str, mode: str = 'a') -&gt; None\n</code></pre> <p>Exports results as csv</p> Source code in <code>trajectopy\\results\\ate_result.py</code> <pre><code>def to_file(self, filename: str, mode: str = \"a\") -&gt; None:\n    \"\"\"\n    Exports results as csv\n    \"\"\"\n    with open(filename, mode, newline=\"\\n\", encoding=\"utf-8\") as file:\n        file.write(f\"#name {self.name}\\n\")\n        file.write(f\"#epsg {self.trajectory.positions.epsg}\\n\")\n        file.write(f\"#sorting {self.trajectory.sorting.value}\\n\")\n    self.to_dataframe().to_csv(filename, index=False, mode=\"a\", float_format=\"%.12f\")\n</code></pre>"},{"location":"api/results/rpe_result/","title":"RPE Result","text":""},{"location":"api/results/rpe_result/#trajectopy.results.rpe_result","title":"rpe_result","text":""},{"location":"api/results/rpe_result/#trajectopy.results.rpe_result.RelativeTrajectoryDeviations","title":"RelativeTrajectoryDeviations  <code>dataclass</code>","text":"<pre><code>RelativeTrajectoryDeviations(\n    pos_dev: Dict[float, List[float]],\n    rot_dev: Dict[float, List[float]],\n    pair_distance: Dict[float, List[float]],\n    pair_distance_unit: PairDistanceUnit = METER,\n)\n</code></pre> <p>Container holding relative (drift) pose deviations grouped by separation.</p> <p>Relative deviations quantify drift between pose pairs separated by a certain spatial distance (meters) or temporal offset (seconds). Each key in the dictionaries corresponds to a separation value (bucket) and its list contains per-pair drift samples for that bucket.</p> <p>Attributes:</p> <ul> <li> <code>pos_dev</code>               (<code>Dict[float, List[float]]</code>)           \u2013            <p>Mapping from pair distance to a list of position drift magnitudes. Units depend on <code>pair_distance_unit</code>; values are normalized per 100 m (expressed as percentage) when distance-based.</p> </li> <li> <code>rot_dev</code>               (<code>Dict[float, List[float]]</code>)           \u2013            <p>Mapping from pair distance to a list of orientation drift samples in radians.</p> </li> <li> <code>pair_distance</code>               (<code>Dict[float, List[float]]</code>)           \u2013            <p>Raw separation measurements (meters or seconds) for each bucket, used for computing mean bucket spacing and step size.</p> </li> <li> <code>pair_distance_unit</code>               (<code>PairDistanceUnit</code>)           \u2013            <p>Enumeration indicating whether bucket keys represent spatial separation (<code>METER</code>) or temporal separation (<code>SECOND</code>). Affects drift normalization and reporting units in <code>RPEResult</code>.</p> </li> </ul> Properties <p>num_pairs (int): Total number of evaluated pose pairs across all buckets.</p>"},{"location":"api/results/rpe_result/#trajectopy.results.rpe_result.RPEResult","title":"RPEResult","text":"<pre><code>RPEResult(rpe_dev: RelativeTrajectoryDeviations, name: str)\n</code></pre> <p>This class represents a set of relative trajectory deviations</p> <p>Relative trajectory deviations describe relative pose deviations between two trajectories. The deviations are calculated by comparing pairs of positions and orientations in the test and reference trajectory.</p> <p>Attributes:</p> <ul> <li> <code>rpe_dev</code>               (<code>RelativeTrajectoryDeviations</code>)           \u2013            <p>The relative trajectory deviations.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name of the deviation set.</p> </li> </ul> Source code in <code>trajectopy\\results\\rpe_result.py</code> <pre><code>def __init__(\n    self,\n    rpe_dev: RelativeTrajectoryDeviations,\n    name: str,\n) -&gt; None:\n    self.name = name\n    self.rpe_dev = rpe_dev\n</code></pre>"},{"location":"api/results/rpe_result/#trajectopy.results.rpe_result.RPEResult.rot_rpe","title":"rot_rpe  <code>property</code>","text":"<pre><code>rot_rpe: float\n</code></pre> <p>Returns the average rotation drift in radians per 100 meters.</p> <p>Returns:</p> <ul> <li> <code>float</code> (              <code>float</code> )          \u2013            <p>Average rotation drift.</p> </li> </ul>"},{"location":"api/results/rpe_result/#trajectopy.results.rpe_result.RPEResult.property_dict","title":"property_dict  <code>property</code>","text":"<pre><code>property_dict: Dict[str, str]\n</code></pre> <p>Returns a dictionary containing the properties of the deviation set.</p> <p>This is relevant for time based comparisons, when pose-pairs are defined by a time difference.</p> <p>Returns:</p> <ul> <li> <code>Dict[str, str]</code>           \u2013            <p>Dict[str, str]: Dictionary of property names and values.</p> </li> </ul>"},{"location":"api/results/rpe_result/#trajectopy.results.rpe_result.RPEResult.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(filename: str)\n</code></pre> <p>Reads a set of relative trajectory deviations from a file.</p> Source code in <code>trajectopy\\results\\rpe_result.py</code> <pre><code>@classmethod\ndef from_file(cls, filename: str):\n    \"\"\"Reads a set of relative trajectory deviations from a file.\"\"\"\n    header_data = HeaderData.from_file(filename)\n    deviation_data = pd.read_csv(filename, comment=\"#\")\n\n    pos_dev: Dict[float, List[float]] = {}\n    rot_dev: Dict[float, List[float]] = {}\n    pair_distance: Dict[float, List[float]] = {}\n\n    last_index = 0\n    for index in header_data.num_pairs:\n        dev_block = deviation_data.iloc[last_index : last_index + index, :]\n        pair_distances = dev_block[\"pair_distance\"].to_numpy(dtype=float)\n        pos_devs = dev_block[\"pos_dev\"].to_numpy(dtype=float)\n        rot_devs = dev_block[\"rot_dev\"].to_numpy(dtype=float) if \"rot_dev\" in deviation_data.columns else []\n\n        mean_dist = np.mean(pair_distances)\n        pair_distance[mean_dist] = list(pair_distances)\n        pos_dev[mean_dist] = list(pos_devs)\n        rot_dev[mean_dist] = list(rot_devs)\n\n        last_index += index\n\n    rpe_dev = RelativeTrajectoryDeviations(\n        pair_distance=pair_distance,\n        pos_dev=pos_dev,\n        rot_dev=rot_dev,\n        pair_distance_unit=header_data.relative_dist_unit,\n    )\n\n    return cls(rpe_dev=rpe_dev, name=header_data.name)\n</code></pre>"},{"location":"api/visualization/mpl_plots/","title":"Matplotlib Plots","text":""},{"location":"api/visualization/mpl_plots/#trajectopy.visualization.mpl_plots","title":"mpl_plots","text":""},{"location":"api/visualization/mpl_plots/#trajectopy.visualization.mpl_plots.plot_trajectories","title":"plot_trajectories","text":"<pre><code>plot_trajectories(\n    trajectories: List[Trajectory], scatter_3d: bool = False\n) -&gt; Tuple[Figure, Figure, Union[Figure, None]]\n</code></pre> <p>Plots the trajectories in 2d or 3d using matplotlib.</p> <p>This function creates one 2D or 3D plot for the xy(z) coordinates of the trajectories, one subplot for the xyz coordinates and one subplot for the rpy angles.</p> <p>Parameters:</p> <ul> <li> <code>trajectories</code>               (<code>List[Trajectory]</code>)           \u2013            <p>List of trajectories to plot.</p> </li> <li> <code>scatter_3d</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to create a 3D scatter plot. Defaults to False.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tuple[Figure, Figure, Union[Figure, None]]</code>           \u2013            <p>Tuple[Figure, Figure, Union[Figure, None]]: Figures for the position, xyz and rpy plots.</p> </li> </ul> Source code in <code>trajectopy\\visualization\\mpl_plots.py</code> <pre><code>def plot_trajectories(\n    trajectories: List[Trajectory], scatter_3d: bool = False\n) -&gt; Tuple[Figure, Figure, Union[Figure, None]]:\n    \"\"\"Plots the trajectories in 2d or 3d using matplotlib.\n\n    This function creates one 2D or 3D plot for the xy(z) coordinates of the trajectories,\n    one subplot for the xyz coordinates and one subplot for the rpy angles.\n\n    Args:\n        trajectories (List[Trajectory]): List of trajectories to plot.\n        scatter_3d (bool, optional): Whether to create a 3D scatter plot. Defaults to False.\n\n    Returns:\n        Tuple[Figure, Figure, Union[Figure, None]]: Figures for the position, xyz and rpy plots.\n    \"\"\"\n    fig_pos = plot_positions(trajectories=trajectories, scatter_3d=scatter_3d)\n    fig_xyz = plot_xyz(trajectories=trajectories)\n    fig_rpy = plot_rpy(trajectories=trajectories)\n    return fig_pos, fig_xyz, fig_rpy\n</code></pre>"},{"location":"api/visualization/mpl_plots/#trajectopy.visualization.mpl_plots.plot_correlation_heatmap","title":"plot_correlation_heatmap","text":"<pre><code>plot_correlation_heatmap(\n    estimated_parameters: AlignmentParameters,\n    enabled_only: bool = True,\n) -&gt; Figure\n</code></pre> <p>Plots the correlation heatmap of the alignment parameters using matplotlib.</p> <p>Parameters:</p> <ul> <li> <code>estimated_parameters</code>               (<code>AlignmentParameters</code>)           \u2013            <p>Estimated parameters.</p> </li> <li> <code>enabled_only</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to consider only enabled parameters. Defaults to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Figure</code>           \u2013            <p>plt.Figure: Correlation heatmap figure.</p> </li> </ul> Source code in <code>trajectopy\\visualization\\mpl_plots.py</code> <pre><code>def plot_correlation_heatmap(estimated_parameters: AlignmentParameters, enabled_only: bool = True) -&gt; Figure:\n    \"\"\"Plots the correlation heatmap of the alignment parameters using matplotlib.\n\n    Args:\n        estimated_parameters (AlignmentParameters): Estimated parameters.\n        enabled_only (bool, optional): Whether to consider only enabled parameters. Defaults to True.\n\n    Returns:\n        plt.Figure: Correlation heatmap figure.\n    \"\"\"\n    covariance_matrix = estimated_parameters.get_covariance_matrix(enabled_only=enabled_only)\n    std_devs = np.sqrt(np.diag(covariance_matrix))\n    correlation_matrix = covariance_matrix / np.outer(std_devs, std_devs)\n    np.fill_diagonal(correlation_matrix, np.nan)\n    fig, ax = plt.subplots()\n    ax.grid(False)\n    im, _ = _heatmap(\n        correlation_matrix,\n        estimated_parameters.params_labels(enabled_only=enabled_only, lower_case=True),\n        estimated_parameters.params_labels(enabled_only=enabled_only, lower_case=True),\n        ax=ax,\n        cmap=\"coolwarm\",\n        cbarlabel=\"Correlation\",\n        cbar_kw={\"format\": \"%.2f\"},\n    )\n    _annotate_heatmap(im, valfmt=\"{x:.2f}\")\n    ax.set_aspect(\"auto\")\n\n    plt.tight_layout()\n    return fig\n</code></pre>"},{"location":"api/visualization/mpl_plots/#trajectopy.visualization.mpl_plots.plot_covariance_heatmap","title":"plot_covariance_heatmap","text":"<pre><code>plot_covariance_heatmap(\n    estimated_parameters: AlignmentParameters,\n    enabled_only: bool = True,\n) -&gt; Figure\n</code></pre> <p>Plots the covariance heatmap of the alignment parameters using matplotlib.</p> <p>Parameters:</p> <ul> <li> <code>estimated_parameters</code>               (<code>AlignmentParameters</code>)           \u2013            <p>Estimated parameters.</p> </li> <li> <code>enabled_only</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to consider only enabled parameters. Defaults to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Figure</code>           \u2013            <p>plt.Figure: Covariance heatmap figure.</p> </li> </ul> Source code in <code>trajectopy\\visualization\\mpl_plots.py</code> <pre><code>def plot_covariance_heatmap(estimated_parameters: AlignmentParameters, enabled_only: bool = True) -&gt; Figure:\n    \"\"\"Plots the covariance heatmap of the alignment parameters using matplotlib.\n\n    Args:\n        estimated_parameters (AlignmentParameters): Estimated parameters.\n        enabled_only (bool, optional): Whether to consider only enabled parameters. Defaults to True.\n\n    Returns:\n        plt.Figure: Covariance heatmap figure.\n    \"\"\"\n    covariance_matrix = estimated_parameters.get_covariance_matrix(enabled_only=enabled_only)\n    fig, ax = plt.subplots()\n    ax.grid(False)\n    im, _ = _heatmap(\n        covariance_matrix,\n        estimated_parameters.params_labels(enabled_only=enabled_only, lower_case=True),\n        estimated_parameters.params_labels(enabled_only=enabled_only, lower_case=True),\n        ax=ax,\n        cmap=\"coolwarm\",\n        cbarlabel=\"Covariance\",\n        cbar_kw={\"format\": \"%.2f\"},\n    )\n    _annotate_heatmap(im, valfmt=\"{x:.3f}\")\n    ax.set_aspect(\"auto\")\n    plt.tight_layout()\n    return fig\n</code></pre>"},{"location":"api/visualization/mpl_plots/#trajectopy.visualization.mpl_plots.plot_ate_3d","title":"plot_ate_3d","text":"<pre><code>plot_ate_3d(\n    ate_results: List[ATEResult],\n    plot_settings: MPLPlotSettings = MPLPlotSettings(),\n) -&gt; Figure\n</code></pre> <p>Plots the ATE results in 2D using matplotlib.</p> <p>Parameters:</p> <ul> <li> <code>ate_results</code>               (<code>List[ATEResult]</code>)           \u2013            <p>List of ATE results.</p> </li> <li> <code>plot_settings</code>               (<code>MPLPlotSettings</code>, default:                   <code>MPLPlotSettings()</code> )           \u2013            <p>Plot settings. Defaults to MPLPlotSettings().</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Figure</code> (              <code>Figure</code> )          \u2013            <p>Figure containing the plot.</p> </li> </ul> Source code in <code>trajectopy\\visualization\\mpl_plots.py</code> <pre><code>def plot_ate_3d(ate_results: List[ATEResult], plot_settings: MPLPlotSettings = MPLPlotSettings()) -&gt; Figure:\n    \"\"\"\n    Plots the ATE results in 2D using matplotlib.\n\n    Args:\n        ate_results (List[ATEResult]): List of ATE results.\n        plot_settings (MPLPlotSettings, optional): Plot settings. Defaults to MPLPlotSettings().\n\n    Returns:\n        Figure: Figure containing the plot.\n    \"\"\"\n    fig = plt.figure()\n    ax = fig.add_subplot(111, projection=\"3d\")\n\n    for ate_result in ate_results:\n        if len(ate_result.index) == 0:\n            logger.warning(\"Skipping %s as it has no data\", ate_result.name)\n            continue\n        ax.plot(\n            (\n                ate_result.pos_dev_cross_h * plot_settings.unit_multiplier\n                if plot_settings.directed_ate\n                else ate_result.pos_dev_x * plot_settings.unit_multiplier\n            ),\n            (\n                ate_result.pos_dev_along * plot_settings.unit_multiplier\n                if plot_settings.directed_ate\n                else ate_result.pos_dev_y * plot_settings.unit_multiplier\n            ),\n            (\n                ate_result.pos_dev_cross_v * plot_settings.unit_multiplier\n                if plot_settings.directed_ate\n                else ate_result.pos_dev_z * plot_settings.unit_multiplier\n            ),\n            \".\",\n            label=ate_result.name,\n        )\n\n    ax.set_xlabel(f\"{'Horizontal Cross-Track' if plot_settings.directed_ate else 'X'} {plot_settings.unit_str}\")\n    ax.set_ylabel(f\"{'Along-Track' if plot_settings.directed_ate else 'Y'} {plot_settings.unit_str}\")\n    ax.set_zlabel(f\"{'Vertical Cross-Track' if plot_settings.directed_ate else 'Z'} {plot_settings.unit_str}\")\n\n    ax.legend()\n    plt.tight_layout()\n    return fig\n</code></pre>"},{"location":"api/visualization/mpl_plots/#trajectopy.visualization.mpl_plots.plot_ate_bars","title":"plot_ate_bars","text":"<pre><code>plot_ate_bars(\n    ate_results: List[ATEResult],\n    plot_settings: MPLPlotSettings = MPLPlotSettings(),\n    mode: str = \"positions\",\n) -&gt; Figure\n</code></pre> <p>Plots multiple ATE results as bars for different characteristics.</p> <p>Shows min, max, mean, median, rms, std using matplotlib.</p> <p>Parameters:</p> <ul> <li> <code>ate_results</code>               (<code>List[ATEResult]</code>)           \u2013            <p>List of ATE results.</p> </li> <li> <code>plot_settings</code>               (<code>MPLPlotSettings</code>, default:                   <code>MPLPlotSettings()</code> )           \u2013            <p>Plot settings. Defaults to MPLPlotSettings().</p> </li> <li> <code>mode</code>               (<code>str</code>, default:                   <code>'positions'</code> )           \u2013            <p>Mode to plot. Either 'positions' or 'rotations'. Defaults to 'positions'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Figure</code> (              <code>Figure</code> )          \u2013            <p>Bar plot figure.</p> </li> </ul> Source code in <code>trajectopy\\visualization\\mpl_plots.py</code> <pre><code>def plot_ate_bars(\n    ate_results: List[ATEResult],\n    plot_settings: MPLPlotSettings = MPLPlotSettings(),\n    mode: str = \"positions\",\n) -&gt; Figure:\n    \"\"\"Plots multiple ATE results as bars for different characteristics.\n\n    Shows min, max, mean, median, rms, std using matplotlib.\n\n    Args:\n        ate_results (List[ATEResult]): List of ATE results.\n        plot_settings (MPLPlotSettings, optional): Plot settings. Defaults to MPLPlotSettings().\n        mode (str, optional): Mode to plot. Either 'positions' or 'rotations'. Defaults to 'positions'.\n\n    Returns:\n        Figure: Bar plot figure.\n    \"\"\"\n    fig, ax = plt.subplots()\n\n    bar_width = 0.9 / len(ate_results)\n    characteristics = [\"Min\", \"Max\", \"Mean\", \"Median\", \"RMS\", \"STD\"]\n    unit = plot_settings.unit_str if mode == \"positions\" else \"[\u00b0]\"\n    spacings = np.linspace(\n        -bar_width * (len(ate_results) - 1) / 2,\n        bar_width * (len(ate_results) - 1) / 2,\n        len(ate_results),\n    )\n    x_positions = np.arange(len(characteristics))\n    for deviation, spacing in zip(ate_results, spacings):\n        if mode == \"rotations\" and deviation.abs_dev.rot_dev is None:\n            continue\n\n        if mode == \"positions\":\n            data = [\n                deviation.pos_dev_min * plot_settings.unit_multiplier,\n                deviation.pos_dev_max * plot_settings.unit_multiplier,\n                deviation.pos_ate * plot_settings.unit_multiplier,\n                deviation.pos_dev_median * plot_settings.unit_multiplier,\n                deviation.pos_dev_rms * plot_settings.unit_multiplier,\n                deviation.pos_dev_std * plot_settings.unit_multiplier,\n            ]\n        elif mode == \"rotations\":\n            data = [\n                np.rad2deg(deviation.rot_dev_min),\n                np.rad2deg(deviation.rot_dev_max),\n                np.rad2deg(deviation.rot_ate),\n                np.rad2deg(deviation.rot_dev_median),\n                np.rad2deg(deviation.rot_dev_rms),\n                np.rad2deg(deviation.rot_dev_std),\n            ]\n        else:\n            raise ValueError(\"Mode must be either 'positions' or 'rotations'\")\n        ax.bar(x_positions + spacing, data, width=bar_width, label=deviation.name)\n\n    ax.set_xlabel(\"Characteristic\")\n    ax.set_ylabel(f\"Value {unit}\")\n    ax.set_xticks(x_positions)\n    ax.set_xticklabels(characteristics)\n    ax.legend()\n\n    return fig\n</code></pre>"},{"location":"api/visualization/mpl_plots/#trajectopy.visualization.mpl_plots.plot_compact_ate_hist","title":"plot_compact_ate_hist","text":"<pre><code>plot_compact_ate_hist(\n    ate_result: ATEResult,\n    plot_settings: MPLPlotSettings = MPLPlotSettings(),\n) -&gt; Figure\n</code></pre> <p>Plots compact ATE histograms for the given ATEResult. The plot contains histograms for the position deviations and, if available, the rotation deviations.</p> <p>Parameters:</p> <ul> <li> <code>ate_result</code>               (<code>ATEResult</code>)           \u2013            <p>ATE result to plot.</p> </li> <li> <code>plot_settings</code>               (<code>MPLPlotSettings</code>, default:                   <code>MPLPlotSettings()</code> )           \u2013            <p>Plot settings. Defaults to MPLPlotSettings().</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Figure</code> (              <code>Figure</code> )          \u2013            <p>Figure containing the plot.</p> </li> </ul> Source code in <code>trajectopy\\visualization\\mpl_plots.py</code> <pre><code>def plot_compact_ate_hist(ate_result: ATEResult, plot_settings: MPLPlotSettings = MPLPlotSettings()) -&gt; Figure:\n    \"\"\"\n    Plots compact ATE histograms for the given ATEResult.\n    The plot contains histograms for the position deviations and, if available, the rotation deviations.\n\n    Args:\n        ate_result (ATEResult): ATE result to plot.\n        plot_settings (MPLPlotSettings, optional): Plot settings. Defaults to MPLPlotSettings().\n\n    Returns:\n        Figure: Figure containing the plot.\n    \"\"\"\n    fig = plt.figure()\n    pos_ax = plt.subplot(2, 1, 1)\n    plot_position_ate_hist(ate_result, plot_settings)\n    pos_ax.ticklabel_format(style=\"sci\", axis=\"y\", scilimits=(0, 0))\n\n    if ate_result.abs_dev.rot_dev is not None:\n        rot_ax = plt.subplot(2, 1, 2)\n        plot_rotation_ate_hist(ate_result, plot_settings)\n        rot_ax.ticklabel_format(style=\"sci\", axis=\"y\", scilimits=(0, 0))\n\n    plt.tight_layout()\n    return fig\n</code></pre>"},{"location":"api/visualization/mpl_plots/#trajectopy.visualization.mpl_plots.plot_ate","title":"plot_ate","text":"<pre><code>plot_ate(\n    ate_results: Union[ATEResult, List[ATEResult]],\n    plot_settings: MPLPlotSettings = MPLPlotSettings(),\n) -&gt; Figure\n</code></pre> <p>Plots ATE for the given ATEResult(s) as a line plot using matplotlib. If available, the plot contains the position and rotation deviations. The x-axis depends on the sorting of the trajectory.</p> <p>Parameters:</p> <ul> <li> <code>ate_results</code>               (<code>Union[ATEResult, List[ATEResult]]</code>)           \u2013            <p>ATE result(s) to plot.</p> </li> <li> <code>plot_settings</code>               (<code>MPLPlotSettings</code>, default:                   <code>MPLPlotSettings()</code> )           \u2013            <p>Plot settings. Defaults to MPLPlotSettings().</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Figure</code> (              <code>Figure</code> )          \u2013            <p>Figure containing the plot.</p> </li> </ul> Source code in <code>trajectopy\\visualization\\mpl_plots.py</code> <pre><code>def plot_ate(\n    ate_results: Union[ATEResult, List[ATEResult]],\n    plot_settings: MPLPlotSettings = MPLPlotSettings(),\n) -&gt; Figure:\n    \"\"\"\n    Plots ATE for the given ATEResult(s) as a line plot using matplotlib.\n    If available, the plot contains the position and rotation deviations.\n    The x-axis depends on the sorting of the trajectory.\n\n    Args:\n        ate_results (Union[ATEResult, List[ATEResult]]): ATE result(s) to plot.\n        plot_settings (MPLPlotSettings, optional): Plot settings. Defaults to MPLPlotSettings().\n\n    Returns:\n        Figure: Figure containing the plot.\n    \"\"\"\n    deviation_list = ate_results if isinstance(ate_results, list) else [ate_results]\n    trajectories_list = [dev.trajectory for dev in deviation_list]\n    trajectories_sorting = get_sorting(traj.sorting for traj in trajectories_list)\n    all_unix = all(traj.is_unix_time for traj in trajectories_list)\n    x_label = derive_xlabel_from_sortings(trajectories_sorting, all_unix)\n\n    fig = plt.figure()\n\n    ax_pos = plt.subplot(2, 1, 1)\n    ax_pos.set_xlabel(x_label)\n    ax_pos.set_ylabel(f\"Deviation {plot_settings.unit_str}\")\n    if all_unix and trajectories_sorting == TrajectoriesSorting.ALL_TIME:\n        ax_pos.xaxis.set_major_formatter(DATE_FORMATTER)\n\n    if any(dev.abs_dev.rot_dev for dev in deviation_list):\n        ax_rot = plt.subplot(2, 1, 2)\n        ax_rot.set_xlabel(x_label)\n        ax_rot.set_ylabel(\"Deviation [\u00b0]\")\n        if all_unix and trajectories_sorting == TrajectoriesSorting.ALL_TIME:\n            ax_rot.xaxis.set_major_formatter(DATE_FORMATTER)\n    else:\n        ax_rot = None\n\n    for dev in deviation_list:\n        if len(dev.index) == 0:\n            logger.warning(\"Skipping %s as it has no data\", dev.name)\n            continue\n\n        index = (\n            dev.trajectory.datetimes\n            if all_unix and trajectories_sorting == TrajectoriesSorting.ALL_TIME\n            else dev.index\n        )\n\n        ax_pos.plot(index, dev.pos_dev_comb * plot_settings.unit_multiplier)\n        if ax_rot is not None:\n            ax_rot.plot(index, np.rad2deg(dev.rot_dev_comb))\n\n    fig.legend([dev.name for dev in deviation_list], ncol=3, loc=\"upper center\")\n    plt.tight_layout()\n    return fig\n</code></pre>"},{"location":"api/visualization/mpl_plots/#trajectopy.visualization.mpl_plots.plot_ate_dof","title":"plot_ate_dof","text":"<pre><code>plot_ate_dof(\n    ate_result: ATEResult,\n    plot_settings: MPLPlotSettings = MPLPlotSettings(),\n) -&gt; Figure\n</code></pre> <p>Plots ATE DOF (Degrees of Freedom) for the given ATEResult as a line plot using matplotlib.</p> <p>The DOF plot shows the deviations in the x, y, and z directions for position and rotation.</p> <p>Parameters:</p> <ul> <li> <code>ate_result</code>               (<code>ATEResult</code>)           \u2013            <p>ATE result to plot.</p> </li> <li> <code>plot_settings</code>               (<code>MPLPlotSettings</code>, default:                   <code>MPLPlotSettings()</code> )           \u2013            <p>Plot settings. Defaults to MPLPlotSettings().</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Figure</code> (              <code>Figure</code> )          \u2013            <p>Figure containing the plot.</p> </li> </ul> Source code in <code>trajectopy\\visualization\\mpl_plots.py</code> <pre><code>def plot_ate_dof(\n    ate_result: ATEResult,\n    plot_settings: MPLPlotSettings = MPLPlotSettings(),\n) -&gt; Figure:\n    \"\"\"Plots ATE DOF (Degrees of Freedom) for the given ATEResult as a line plot using matplotlib.\n\n    The DOF plot shows the deviations in the x, y, and z directions for position and rotation.\n\n    Args:\n        ate_result (ATEResult): ATE result to plot.\n        plot_settings (MPLPlotSettings, optional): Plot settings. Defaults to MPLPlotSettings().\n\n    Returns:\n        Figure: Figure containing the plot.\n    \"\"\"\n    trajectory = ate_result.trajectory\n    x_label = derive_xlabel_from_sortings(\n        TrajectoriesSorting.ALL_SPATIAL if trajectory.sorting == Sorting.PATH_LENGTH else TrajectoriesSorting.ALL_TIME,\n        trajectory.is_unix_time,\n    )\n\n    is_unix_time = trajectory.is_unix_time and trajectory.sorting == Sorting.TIME\n\n    fig = plt.figure()\n\n    ax_pos = plt.subplot(2, 1, 1)\n    ax_pos.set_xlabel(x_label)\n    ax_pos.set_ylabel(f\"Deviation {plot_settings.unit_str}\")\n    if is_unix_time:\n        ax_pos.xaxis.set_major_formatter(DATE_FORMATTER)\n\n    if ate_result.has_orientation:\n        ax_rot = plt.subplot(2, 1, 2)\n        ax_rot.set_xlabel(x_label)\n        ax_rot.set_ylabel(\"Deviation [\u00b0]\")\n        if is_unix_time:\n            ax_rot.xaxis.set_major_formatter(DATE_FORMATTER)\n    else:\n        ax_rot = None\n\n    if len(ate_result.index) == 0:\n        logger.warning(\"Skipping %s as it has no data\", ate_result.name)\n        return fig\n\n    pos_dev_x = ate_result.pos_dev_along if plot_settings.directed_ate else ate_result.pos_dev_x\n    pos_dev_y = ate_result.pos_dev_cross_h if plot_settings.directed_ate else ate_result.pos_dev_y\n    pos_dev_z = ate_result.pos_dev_cross_v if plot_settings.directed_ate else ate_result.pos_dev_z\n\n    index = ate_result.trajectory.datetimes if is_unix_time else ate_result.index\n\n    ax_pos.plot(\n        index,\n        pos_dev_x * plot_settings.unit_multiplier,\n        label=\"Along-Track\" if plot_settings.directed_ate else \"X\",\n    )\n    ax_pos.plot(\n        index,\n        pos_dev_y * plot_settings.unit_multiplier,\n        label=\"Horizontal Cross-Track\" if plot_settings.directed_ate else \"Y\",\n    )\n    ax_pos.plot(\n        index,\n        pos_dev_z * plot_settings.unit_multiplier,\n        label=\"Vertical Cross-Track\" if plot_settings.directed_ate else \"Z\",\n    )\n    ax_pos.legend()\n\n    if ax_rot is not None:\n        ax_rot.plot(index, np.rad2deg(ate_result.rot_dev_x), label=\"Roll\")\n        ax_rot.plot(index, np.rad2deg(ate_result.rot_dev_y), label=\"Pitch\")\n        ax_rot.plot(index, np.rad2deg(ate_result.rot_dev_z), label=\"Yaw\")\n        ax_rot.legend()\n\n    ax_pos.set_title(f\"{ate_result.name}\")\n    plt.tight_layout()\n    return fig\n</code></pre>"},{"location":"api/visualization/mpl_plots/#trajectopy.visualization.mpl_plots.plot_ate_edf","title":"plot_ate_edf","text":"<pre><code>plot_ate_edf(\n    ate_results: Union[ATEResult, List[ATEResult]],\n    plot_settings: MPLPlotSettings = MPLPlotSettings(),\n) -&gt; Figure\n</code></pre> <p>Plots ATE EDF for the given ATEResult(s) as a line plot using matplotlib. The EDF (Empirical Distribution Function) shows the cumulative probability of the deviations. Using this plot, one can easily see how many percent of the deviations are below a certain value.</p> <p>Parameters:</p> <ul> <li> <code>ate_results</code>               (<code>Union[ATEResult, List[ATEResult]]</code>)           \u2013            <p>ATE result to plot.</p> </li> <li> <code>plot_settings</code>               (<code>MPLPlotSettings</code>, default:                   <code>MPLPlotSettings()</code> )           \u2013            <p>Plot settings. Defaults to MPLPlotSettings().</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Figure</code> (              <code>Figure</code> )          \u2013            <p>Figure containing the plot.</p> </li> </ul> Source code in <code>trajectopy\\visualization\\mpl_plots.py</code> <pre><code>def plot_ate_edf(\n    ate_results: Union[ATEResult, List[ATEResult]],\n    plot_settings: MPLPlotSettings = MPLPlotSettings(),\n) -&gt; Figure:\n    \"\"\"\n    Plots ATE EDF for the given ATEResult(s) as a line plot using matplotlib.\n    The EDF (Empirical Distribution Function) shows the cumulative probability of the deviations.\n    Using this plot, one can easily see how many percent of the deviations are below a certain value.\n\n    Args:\n        ate_results (Union[ATEResult, List[ATEResult]]): ATE result to plot.\n        plot_settings (MPLPlotSettings, optional): Plot settings. Defaults to MPLPlotSettings().\n\n    Returns:\n        Figure: Figure containing the plot.\n    \"\"\"\n    deviation_list = ate_results if isinstance(ate_results, list) else [ate_results]\n\n    fig = plt.figure()\n\n    plot_position_ate_edf(deviation_list, plot_settings)\n    plot_rotation_ate_edf(deviation_list)\n\n    fig.legend([dev.name for dev in deviation_list], ncol=3, loc=\"upper center\")\n    plt.tight_layout()\n    return fig\n</code></pre>"},{"location":"api/visualization/mpl_plots/#trajectopy.visualization.mpl_plots.plot_rpe","title":"plot_rpe","text":"<pre><code>plot_rpe(\n    rpe_results: List[RPEResult],\n) -&gt; Tuple[Figure, Figure]\n</code></pre> <p>Plots the RPE results as a line plot with violin plots for the position and rotation deviations.</p> <p>Depending on the pair distance unit, the unit of the position deviations is either in meters/meters (%) or meters/seconds. The unit of the rotation deviations is respectively in degrees/m or degrees/second.</p> <p>Parameters:</p> <ul> <li> <code>rpe_results</code>               (<code>list[RelativeTrajectoryDeviations]</code>)           \u2013            <p>list of RelativeTrajectoryDeviations</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tuple[Figure, Figure]</code>           \u2013            <p>Tuple[Figure, Figure]: metric and time RPE plots</p> </li> </ul> Source code in <code>trajectopy\\visualization\\mpl_plots.py</code> <pre><code>def plot_rpe(rpe_results: List[RPEResult]) -&gt; Tuple[Figure, Figure]:\n    \"\"\"Plots the RPE results as a line plot with violin plots for the position and rotation deviations.\n\n    Depending on the pair distance unit, the unit of the position deviations\n    is either in meters/meters (%) or meters/seconds. The unit of the rotation\n    deviations is respectively in degrees/m or degrees/second.\n\n    Args:\n        rpe_results (list[RelativeTrajectoryDeviations]): list of RelativeTrajectoryDeviations\n\n    Returns:\n        Tuple[Figure, Figure]: metric and time RPE plots\n\n    \"\"\"\n    if not isinstance(rpe_results, list):\n        rpe_results = [rpe_results]\n\n    fig_metric, (fig_pos_metric, fig_rot_metric) = plt.subplots(2, 1)\n    fig_time, (fig_pos_time, fig_rot_time) = plt.subplots(2, 1)\n\n    fig_pos_metric.set_ylabel(\"Position RPE [%]\")\n    fig_pos_time.set_ylabel(\"Position RPE [m/s]\")\n\n    fig_rot_metric.set_ylabel(\"Rotation RPE [deg / 100m]\")\n    fig_rot_time.set_ylabel(\"Rotation RPE [deg/s]\")\n\n    fig_pos_metric.set_xlabel(\"pair distance [m]\")\n    fig_pos_time.set_xlabel(\"pair distance [s]\")\n    fig_rot_metric.set_xlabel(\"pair distance [m]\")\n    fig_rot_time.set_xlabel(\"pair distance [s]\")\n\n    figure_dict: Dict[str, Dict[PairDistanceUnit, Axes]] = {\n        \"pos\": {\n            PairDistanceUnit.METER: fig_pos_metric,\n            PairDistanceUnit.SECOND: fig_pos_time,\n        },\n        \"rot\": {\n            PairDistanceUnit.METER: fig_rot_metric,\n            PairDistanceUnit.SECOND: fig_rot_time,\n        },\n    }\n\n    plot_rpe_pos(figure_dict[\"pos\"], rpe_results)\n    plot_rpe_rot(figure_dict[\"rot\"], rpe_results)\n\n    add_rpy_legend(figure_dict)\n\n    ret_sum = 1 if any(dev.rpe_dev.pair_distance_unit == PairDistanceUnit.METER for dev in rpe_results) else 0\n    if any(dev.rpe_dev.pair_distance_unit == PairDistanceUnit.SECOND for dev in rpe_results):\n        ret_sum += 2\n\n    plt.close({1: fig_time, 2: fig_metric}.get(ret_sum))\n    plt.tight_layout()\n    return {\n        0: (None, None),\n        1: (fig_metric, None),\n        2: (None, fig_time),\n        3: (fig_metric, fig_time),\n    }[ret_sum]\n</code></pre>"},{"location":"api/visualization/mpl_plots/#trajectopy.visualization.mpl_plots.scatter_ate","title":"scatter_ate","text":"<pre><code>scatter_ate(\n    ate_result: ATEResult,\n    plot_settings: MPLPlotSettings = MPLPlotSettings(),\n) -&gt; Tuple[Figure, Figure]\n</code></pre> <p>Plots the ATE results as a scatter plot with color-coded deviations.</p> <p>Parameters:</p> <ul> <li> <code>ate_result</code>               (<code>ATEResult</code>)           \u2013            <p>ATE result to plot.</p> </li> <li> <code>plot_settings</code>               (<code>MPLPlotSettings</code>, default:                   <code>MPLPlotSettings()</code> )           \u2013            <p>Plot settings. Defaults to MPLPlotSettings().</p> </li> </ul> Source code in <code>trajectopy\\visualization\\mpl_plots.py</code> <pre><code>def scatter_ate(ate_result: ATEResult, plot_settings: MPLPlotSettings = MPLPlotSettings()) -&gt; Tuple[Figure, Figure]:\n    \"\"\"\n    Plots the ATE results as a scatter plot with color-coded deviations.\n\n    Args:\n        ate_result (ATEResult): ATE result to plot.\n        plot_settings (MPLPlotSettings, optional): Plot settings. Defaults to MPLPlotSettings().\n    \"\"\"\n    pos_fig = plt.figure()\n    _colored_scatter_plot(\n        xyz=ate_result.trajectory.xyz,\n        c_list=ate_result.pos_dev_comb * plot_settings.unit_multiplier,\n        c_label=f\"Deviation {plot_settings.unit_str}\",\n        plot_settings=plot_settings,\n    )\n\n    if not ate_result.has_orientation:\n        return pos_fig, None\n\n    rot_fig = plt.figure()\n    _colored_scatter_plot(\n        xyz=ate_result.trajectory.xyz,\n        c_list=ate_result.rot_dev_comb * 180 / np.pi,\n        c_label=\"Deviation [\u00b0]\",\n        plot_settings=plot_settings,\n    )\n    return pos_fig, rot_fig\n</code></pre>"},{"location":"api/visualization/mpl_plots/#trajectopy.visualization.mpl_plots.plot_positions","title":"plot_positions","text":"<pre><code>plot_positions(\n    trajectories: List[Trajectory], scatter_3d: bool = False\n) -&gt; Figure\n</code></pre> <p>Plots xy(z) coordinates of trajectories as 2d or 3d plot</p> Source code in <code>trajectopy\\visualization\\mpl_plots.py</code> <pre><code>def plot_positions(trajectories: List[Trajectory], scatter_3d: bool = False) -&gt; Figure:\n    \"\"\"Plots xy(z) coordinates of trajectories as 2d or 3d plot\"\"\"\n    x_label, y_label, z_label = get_axis_label(trajectories=trajectories)\n\n    if scatter_3d:\n        fig_pos = plt.figure()\n        ax_pos = fig_pos.add_subplot(111, projection=\"3d\")\n        ax_pos.set_zlabel(z_label)  # type: ignore\n    else:\n        fig_pos, ax_pos = plt.subplots()\n        ax_pos.axis(\"equal\")\n\n    ax_pos.set_xlabel(x_label)\n    ax_pos.set_ylabel(y_label)\n\n    legend_names = []\n    for traj in trajectories:\n        xyz = traj.xyz\n        legend_names.append(traj.name)\n\n        # pos fig\n        if scatter_3d:\n            ax_pos.plot(xyz[:, 0], xyz[:, 1], xyz[:, 2])\n        else:\n            ax_pos.plot(xyz[:, 0], xyz[:, 1])\n\n    if scatter_3d:\n        set_aspect_equal_3d(ax_pos)\n\n    fig_pos.legend(legend_names, ncol=4, loc=\"upper center\")\n    return fig_pos\n</code></pre>"},{"location":"api/visualization/mpl_plots/#trajectopy.visualization.mpl_plots.plot_xyz","title":"plot_xyz","text":"<pre><code>plot_xyz(trajectories: List[Trajectory]) -&gt; Figure\n</code></pre> <p>Plots xyz coordinates of trajectories as subplots</p> Source code in <code>trajectopy\\visualization\\mpl_plots.py</code> <pre><code>def plot_xyz(trajectories: List[Trajectory]) -&gt; Figure:\n    \"\"\"Plots xyz coordinates of trajectories as subplots\"\"\"\n    fig_xyz, axs_xyz = plt.subplots(3, 1, sharex=True)\n\n    for ax, label in zip(axs_xyz, get_axis_label(trajectories=trajectories)):\n        ax.set_ylabel(label)\n\n    trajectories_sorting = get_sorting([traj.sorting for traj in trajectories])\n    all_unix = all(traj.is_unix_time for traj in trajectories)\n    x_label = derive_xlabel_from_sortings(trajectories_sorting, all_unix)\n\n    axs_xyz[-1].set_xlabel(x_label)\n\n    if all_unix and trajectories_sorting == TrajectoriesSorting.ALL_TIME:\n        axs_xyz[-1].xaxis.set_major_formatter(DATE_FORMATTER)\n\n    legend_names = []\n    for traj in trajectories:\n        legend_names.append(traj.name)\n        xyz = traj.xyz\n\n        # xyz fig\n        for j, ax in enumerate(axs_xyz):\n            ax.plot(\n                (traj.datetimes if all_unix and trajectories_sorting == TrajectoriesSorting.ALL_TIME else traj.index),\n                xyz[:, j],\n            )\n\n    fig_xyz.legend(legend_names, ncol=4, loc=\"upper center\")\n    return fig_xyz\n</code></pre>"},{"location":"api/visualization/mpl_plots/#trajectopy.visualization.mpl_plots.plot_rpy","title":"plot_rpy","text":"<pre><code>plot_rpy(\n    trajectories: List[Trajectory],\n) -&gt; Union[Figure, None]\n</code></pre> <p>Plots rpy coordinates of trajectories as subplots</p> Source code in <code>trajectopy\\visualization\\mpl_plots.py</code> <pre><code>def plot_rpy(trajectories: List[Trajectory]) -&gt; Union[Figure, None]:\n    \"\"\"Plots rpy coordinates of trajectories as subplots\"\"\"\n    fig_rpy, axs_rpy = plt.subplots(3, 1, sharex=True)\n    trajectories_sorting = get_sorting([traj.sorting for traj in trajectories])\n    all_unix = all(traj.is_unix_time for traj in trajectories)\n    x_label = derive_xlabel_from_sortings(trajectories_sorting, all_unix)\n\n    axs_rpy[-1].set_xlabel(x_label)\n\n    if all_unix and trajectories_sorting == TrajectoriesSorting.ALL_TIME:\n        axs_rpy[-1].xaxis.set_major_formatter(DATE_FORMATTER)\n\n    not_empty = False\n    legend_names = []\n    for traj in trajectories:\n        # rpy fig\n        if traj.rotations and len(traj.rotations) &gt; 0:\n            legend_names.append(traj.name)\n            rpy = traj.rpy\n            ylabels = [\"roll [\u00b0]\", \"pitch [\u00b0]\", \"yaw [\u00b0]\"]\n            for j, (ax, yl) in enumerate(zip(axs_rpy, ylabels)):\n                ax.plot(\n                    (\n                        traj.datetimes\n                        if all_unix and trajectories_sorting == TrajectoriesSorting.ALL_TIME\n                        else traj.index\n                    ),\n                    np.rad2deg(rpy[:, j]),\n                )\n                ax.set_ylabel(yl)\n            not_empty = True\n\n    fig_rpy.legend(legend_names, ncol=4, loc=\"upper center\")\n\n    return fig_rpy if not_empty else None\n</code></pre>"},{"location":"api/visualization/plotly_plots/","title":"Plotly Plots","text":""},{"location":"api/visualization/plotly_plots/#trajectopy.visualization.plotly_plots","title":"plotly_plots","text":""},{"location":"api/visualization/plotly_plots/#trajectopy.visualization.plotly_plots.plot_heatmap","title":"plot_heatmap","text":"<pre><code>plot_heatmap(\n    dataframe: DataFrame,\n    report_settings: ReportSettings = ReportSettings(),\n) -&gt; str\n</code></pre> <p>Render a heatmap plot.</p> <p>Parameters:</p> <ul> <li> <code>dataframe</code>               (<code>DataFrame</code>)           \u2013            <p>The data to plot.</p> </li> <li> <code>report_settings</code>               (<code>ReportSettings</code>, default:                   <code>ReportSettings()</code> )           \u2013            <p>Report settings.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>HTML string of the rendered report including the heatmap plot.</p> </li> </ul> Source code in <code>trajectopy\\visualization\\plotly_plots.py</code> <pre><code>def plot_heatmap(dataframe: pd.DataFrame, report_settings: ReportSettings = ReportSettings()) -&gt; str:\n    \"\"\"\n    Render a heatmap plot.\n\n    Args:\n        dataframe: The data to plot.\n        report_settings: Report settings.\n\n    Returns:\n        HTML string of the rendered report including the heatmap plot.\n    \"\"\"\n    fig = px.imshow(\n        dataframe,\n        text_auto=\".2f\",\n        color_continuous_scale=\"RdBu_r\",\n        range_color=[-1, 1],\n        title=\"Correlation Matrix\",\n        aspect=\"auto\",\n    )\n\n    fig.update_layout(height=report_settings.single_plot_height)\n\n    return plot(fig, output_type=\"div\", config=report_settings.single_plot_export.to_config())\n</code></pre>"},{"location":"api/visualization/plotly_plots/#trajectopy.visualization.plotly_plots.plot_alignment_table","title":"plot_alignment_table","text":"<pre><code>plot_alignment_table(\n    alignment_parameters: AlignmentParameters,\n    report_settings: ReportSettings = ReportSettings(),\n) -&gt; str\n</code></pre> <p>Render a heatmap plot.</p> <p>Parameters:</p> <ul> <li> <code>alignment_parameters</code>               (<code>AlignmentParameters</code>)           \u2013            <p>Alignment parameters.</p> </li> <li> <code>report_settings</code>               (<code>ReportSettings</code>, default:                   <code>ReportSettings()</code> )           \u2013            <p>Report settings. Defaults to ReportSettings().</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>HTML string of the rendered report including the heatmap plot.</p> </li> </ul> Source code in <code>trajectopy\\visualization\\plotly_plots.py</code> <pre><code>def plot_alignment_table(\n    alignment_parameters: AlignmentParameters, report_settings: ReportSettings = ReportSettings()\n) -&gt; str:\n    \"\"\"\n    Render a heatmap plot.\n\n    Args:\n        alignment_parameters (AlignmentParameters): Alignment parameters.\n        report_settings (ReportSettings, optional): Report settings. Defaults to ReportSettings().\n\n    Returns:\n        HTML string of the rendered report including the heatmap plot.\n    \"\"\"\n\n    def extract_value(param_string: str) -&gt; str:\n        return param_string.split(\"=\")[1].split(\"s-dev\")[0].strip()\n\n    def extract_std(param_string: str) -&gt; str:\n        return param_string.split(\":\")[-1].strip()\n\n    labels = alignment_parameters.params_labels(enabled_only=True, lower_case=False)\n    alignment_data = [\n        go.Table(\n            header=dict(values=[\"Parameter\", \"Value\", \"Standard Deviation\"]),\n            cells=dict(\n                values=[\n                    labels,\n                    [extract_value(param_string) for param_string in alignment_parameters.to_string_list()],\n                    [extract_std(param_string) for param_string in alignment_parameters.to_string_list()],\n                ],\n            ),\n            name=\"Alignment Parameters\",\n        )\n    ]\n    fig = go.Figure(data=alignment_data)\n    return plot(fig, output_type=\"div\", config=report_settings.single_plot_export.to_config())\n</code></pre>"},{"location":"api/visualization/plotly_reports/","title":"HTML Reports","text":""},{"location":"api/visualization/plotly_reports/#trajectopy.visualization.plotly_reports","title":"plotly_reports","text":""},{"location":"api/visualization/plotly_reports/#trajectopy.visualization.plotly_reports.create_alignment_report","title":"create_alignment_report","text":"<pre><code>create_alignment_report(\n    *,\n    alignment_parameters: AlignmentParameters,\n    name: str = \"Alignment\",\n    report_settings: ReportSettings = ReportSettings()\n) -&gt; str\n</code></pre> <p>Render trajectory alignment heatmaps.</p> <p>Heatmaps are covariance matrix and correlation matrix.</p> <p>Parameters:</p> <ul> <li> <code>alignment_parameters</code>               (<code>AlignmentParameters</code>)           \u2013            <p>Estimated alignment parameters.</p> </li> <li> <code>name</code>               (<code>str</code>, default:                   <code>'Alignment'</code> )           \u2013            <p>Name of the report. Defaults to \"Alignment\".</p> </li> <li> <code>report_settings</code>               (<code>ReportSettings</code>, default:                   <code>ReportSettings()</code> )           \u2013            <p>Report settings. Defaults to ReportSettings()</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>HTML string of the rendered report including the heatmap plots.</p> </li> </ul> Source code in <code>trajectopy\\visualization\\plotly_reports.py</code> <pre><code>def create_alignment_report(\n    *,\n    alignment_parameters: AlignmentParameters,\n    name: str = \"Alignment\",\n    report_settings: ReportSettings = ReportSettings(),\n) -&gt; str:\n    \"\"\"\n    Render trajectory alignment heatmaps.\n\n    Heatmaps are covariance matrix and correlation matrix.\n\n    Args:\n        alignment_parameters (AlignmentParameters): Estimated alignment parameters.\n        name (str, optional): Name of the report. Defaults to \"Alignment\".\n        report_settings (ReportSettings, optional): Report settings. Defaults to ReportSettings()\n\n    Returns:\n        HTML string of the rendered report including the heatmap plots.\n    \"\"\"\n\n    template = jinja2.Environment(loader=jinja2.FileSystemLoader(TEMPLATES_PATH)).get_template(\"generic.html\")\n    icon = convert_icon_to_base64()\n\n    one_line_plots = _render_one_line_alignment_plots(alignment_parameters, report_settings)\n\n    context = {\n        \"title\": name,\n        \"one_line_plots\": one_line_plots,\n        \"icon\": icon,\n    }\n\n    return template.render(context)\n</code></pre>"},{"location":"api/visualization/plotly_reports/#trajectopy.visualization.plotly_reports.create_trajectory_report","title":"create_trajectory_report","text":"<pre><code>create_trajectory_report(\n    *,\n    trajectories: List[Trajectory],\n    report_settings: ReportSettings = ReportSettings()\n) -&gt; str\n</code></pre> <p>Render a HTML report containing trajectory plots.</p> <p>Parameters:</p> <ul> <li> <code>trajectories</code>               (<code>List[Trajectory]</code>)           \u2013            <p>List of trajectories to render.</p> </li> <li> <code>report_settings</code>               (<code>ReportSettings</code>, default:                   <code>ReportSettings()</code> )           \u2013            <p>Report settings.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>HTML string of the rendered report including the trajectory plots.</p> </li> </ul> Source code in <code>trajectopy\\visualization\\plotly_reports.py</code> <pre><code>def create_trajectory_report(\n    *, trajectories: List[Trajectory], report_settings: ReportSettings = ReportSettings()\n) -&gt; str:\n    \"\"\"\n    Render a HTML report containing trajectory plots.\n\n    Args:\n        trajectories: List of trajectories to render.\n        report_settings: Report settings.\n\n    Returns:\n        HTML string of the rendered report including the trajectory plots.\n    \"\"\"\n\n    template = jinja2.Environment(loader=jinja2.FileSystemLoader(TEMPLATES_PATH)).get_template(\"generic.html\")\n    icon = convert_icon_to_base64()\n\n    one_line_plots = _render_one_line_trajectory_plots(trajectories, report_settings)\n\n    context = {\n        \"title\": trajectories[0].name if len(trajectories) == 1 else \"Trajectory Plot\",\n        \"one_line_plots\": one_line_plots,\n        \"icon\": icon,\n    }\n\n    return template.render(context)\n</code></pre>"},{"location":"api/visualization/plotly_reports/#trajectopy.visualization.plotly_reports.create_deviation_report","title":"create_deviation_report","text":"<pre><code>create_deviation_report(\n    ate_result: Union[ATEResult, List[ATEResult]],\n    rpe_result: Union[RPEResult, List[RPEResult], None],\n    report_settings: ReportSettings = ReportSettings(),\n) -&gt; str\n</code></pre> <p>Create a HTML deviation report containing the absolute trajectory error and relative pose error results.</p> <p>Parameters:</p> <ul> <li> <code>ate_result</code>               (<code>Union[ATEResult, list[ATEResult]]</code>)           \u2013            <p>The absolute trajectory error results (one or multiple).</p> </li> <li> <code>rpe_result</code>               (<code>Union[RPEResult, list[RPEResult]]</code>)           \u2013            <p>The relative pose error results (one or multiple).</p> </li> <li> <code>report_settings</code>               (<code>ReportSettings</code>, default:                   <code>ReportSettings()</code> )           \u2013            <p>The report settings, defaults to ReportSettings().</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>The deviation report.</p> </li> </ul> Source code in <code>trajectopy\\visualization\\plotly_reports.py</code> <pre><code>def create_deviation_report(\n    ate_result: Union[ATEResult, List[ATEResult]],\n    rpe_result: Union[RPEResult, List[RPEResult], None],\n    report_settings: ReportSettings = ReportSettings(),\n) -&gt; str:\n    \"\"\"Create a HTML deviation report containing the absolute trajectory error and relative pose error results.\n\n    Args:\n        ate_result (Union[ATEResult, list[ATEResult]]): The absolute trajectory error results (one or multiple).\n        rpe_result (Union[RPEResult, list[RPEResult]]): The relative pose error results (one or multiple).\n        report_settings (ReportSettings): The report settings, defaults to ReportSettings().\n\n    Returns:\n        str: The deviation report.\n    \"\"\"\n    if (ate_result is not None and isinstance(ate_result, list)) or (\n        rpe_result is not None and isinstance(rpe_result, list)\n    ):\n        return _render_multi_deviations_report(\n            ate_results=ate_result, rpe_results=rpe_result, report_settings=report_settings\n        )\n\n    return _render_single_deviations_report(\n        ate_result=ate_result, rpe_result=rpe_result, report_settings=report_settings\n    )\n</code></pre>"},{"location":"api/visualization/plotly_reports/#trajectopy.visualization.plotly_reports.write_report","title":"write_report","text":"<pre><code>write_report(*, output_file: str, report_text: str) -&gt; None\n</code></pre> <p>Writes a report to the given output file.</p> <p>Parameters:</p> <ul> <li> <code>output_file</code>               (<code>str</code>)           \u2013            <p>The output file path</p> </li> <li> <code>report_text</code>               (<code>str</code>)           \u2013            <p>The report text</p> </li> </ul> Source code in <code>trajectopy\\visualization\\plotly_reports.py</code> <pre><code>def write_report(*, output_file: str, report_text: str) -&gt; None:\n    \"\"\"\n    Writes a report to the given output file.\n\n    Args:\n        output_file (str): The output file path\n        report_text (str): The report text\n\n    \"\"\"\n    logger.info(\"Writing report to %s\", output_file)\n    with open(output_file, \"w\", encoding=\"utf-8\") as f:\n        f.write(report_text)\n</code></pre>"},{"location":"api/visualization/plotly_reports/#trajectopy.visualization.plotly_reports.show_report","title":"show_report","text":"<pre><code>show_report(report_text: str, filepath: str = '') -&gt; None\n</code></pre> <p>This function writes a report to a file and opens it in the default web browser.</p> <p>Parameters:</p> <ul> <li> <code>report_text</code>               (<code>str</code>)           \u2013            <p>The report text</p> </li> <li> <code>filepath</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The file path to save the report. If not given, a random file name will be generated.</p> </li> </ul> Source code in <code>trajectopy\\visualization\\plotly_reports.py</code> <pre><code>def show_report(report_text: str, filepath: str = \"\") -&gt; None:\n    \"\"\"\n    This function writes a report to a file and opens it in the default web browser.\n\n    Args:\n        report_text (str): The report text\n        filepath (str, optional): The file path to save the report. If not given, a random file name will be generated.\n\n    \"\"\"\n    dirname = os.path.dirname(filepath)\n    if not os.path.exists(dirname):\n        os.mkdir(dirname)\n\n    random_string = uuid.uuid4().hex\n\n    file = filepath or os.path.join(dirname, f\"{random_string}.html\")\n\n    with open(file, \"w\", encoding=\"utf-8\") as f:\n        f.write(report_text)\n        url = f\"file://{os.path.realpath(f.name)}\"\n        webbrowser.open(url)\n</code></pre>"}]}